Detection ID,Latest Commit ID,PMD Version,Rule Name,File Path,Violation Introducing Commit ID,VIC Date,VIC Line Num.,Latest Detection Commit ID,LDC ID Date,LDC Line Num.,Violation Fixed Commit ID,VFC Date,VFC Line Num.,Fixed Period(day),Original Code,Fixed Code,Really Fixed?,Time
5809,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/ch/netcetera/wake/core/format/csv/CSVParser.java,e23e79e0ceacf38d3298e7f5207c4518ad2b5955,1134798087,229,,,,,,,,"        ret = null;",,,25502
5810,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/ch/netcetera/wake/core/format/csv/CSVParser.java,e23e79e0ceacf38d3298e7f5207c4518ad2b5955,1134798087,263,,,,,,,,"        ret = null;",,,25502
5811,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/CSVParser.java,4b5faabefd896ef24b21d7f9d3dc20741f6b89b8,1134798179,229,c6bdecabd82eebc9efce450aa4057b668984479e,1296470876,214,1166ca605bcc035654771f1ddc1092d86f2ec1e8,1296549960,-1,1296549960/1134798179,"        ret = null;","  *
  * Because CSV appears in many different dialects, the parser supports many
  * configuration settings by allowing the specification of a {@link CSVStrategy}.
- * 
+ *
  * <p>Parsing of a csv-string having tabs as separators,
  * '""' as an optional value encapsulator, and comments starting with '#':</p>
  * <pre>
- *  String[][] data = 
+ *  String[][] data =
  *   (new CSVParser(new StringReader(""a\tb\nc\td""), new CSVStrategy('\t','""','#'))).getAllValues();
  * </pre>
- * 
+ *
  * <p>Parsing of a csv-string in Excel CSV format</p>
  * <pre>
  *  String[][] data =
  *   (new CSVParser(new StringReader(""a;b\nc;d""), CSVStrategy.EXCEL_STRATEGY)).getAllValues();
  * </pre>
- * 
+ *
  * <p>
  * Internal parser state is completely covered by the strategy
  * and the reader-state.</p>
- * 
- * <p>see <a href=""package-summary.html"">package documentation</a> 
+ *
+ * <p>see <a href=""package-summary.html"">package documentation</a>
  * for more details</p>
  */
 public class CSVParser {
 
-  /** length of the initial token (content-)buffer */
-  private static final int INITIAL_TOKEN_LENGTH = 50;
-  
-  // the token types
-  /** Token has no valid content, i.e. is in its initialized state. */
-  protected static final int TT_INVALID = -1;
-  /** Token with content, at beginning or in the middle of a line. */
-  protected static final int TT_TOKEN = 0;
-  /** Token (which can have content) when end of file is reached. */
-  protected static final int TT_EOF = 1;
-  /** Token with content when end of a line is reached. */
-  protected static final int TT_EORECORD = 2;
+    /**
+     * length of the initial token (content-)buffer
+     */
+    private static final int INITIAL_TOKEN_LENGTH = 50;
 
-  /** Immutable empty String array. */
-  private static final String[] EMPTY_STRING_ARRAY = new String[0];
-   
-  // the input stream
-  private final ExtendedBufferedReader in;
+    // the token types
+    /**
+     * Token has no valid content, i.e. is in its initialized state.
+     */
+    protected static final int TT_INVALID = -1;
+    /**
+     * Token with content, at beginning or in the middle of a line.
+     */
+    protected static final int TT_TOKEN = 0;
+    /**
+     * Token (which can have content) when end of file is reached.
+     */
+    protected static final int TT_EOF = 1;
+    /**
+     * Token with content when end of a line is reached.
+     */
+    protected static final int TT_EORECORD = 2;
 
-  private final CSVStrategy strategy;
-  
-  // the following objects are shared to reduce garbage 
-  /** A record buffer for getLine(). Grows as necessary and is reused. */
-  private final ArrayList record = new ArrayList();
-  private final Token reusableToken = new Token();
-  private final CharBuffer wsBuf = new CharBuffer();
-  private final CharBuffer code = new CharBuffer(4);
+    /**
+     * Immutable empty String array.
+     */
+    private static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  
-  /**
-   * Token is an internal token representation.
-   * 
-   * It is used as contract between the lexer and the parser. 
-   */
-  static class Token {
-    /** Token type, see TT_xxx constants. */
-    int type = TT_INVALID;
-    /** The content buffer. */
-    CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
-    /** Token ready flag: indicates a valid token with content (ready for the parser). */
-    boolean isReady;
-    
-    Token reset() {
-        content.clear();
-        type = TT_INVALID;
-        isReady = false;
-        return this;
-    }
-  }
-  
-  // ======================================================
-  //  the constructor
-  // ======================================================
-  
-  /**
-   * Default strategy for the parser follows the default {@link CSVStrategy}.
-   * 
-   * @param input an InputStream containing ""csv-formatted"" stream
-   * @deprecated use {@link #CSVParser(Reader)}.
-   */
-  public CSVParser(InputStream input) {
-    this(new InputStreamReader(input));
-  }
-  
-  /**
-   * CSV parser using the default {@link CSVStrategy}.
-   * 
-   * @param input a Reader containing ""csv-formatted"" input
-   */
-  public CSVParser(Reader input) {
-    this(input, (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone());
-  }
-  
-  /**
-   * Customized value delimiter parser.
-   * 
-   * The parser follows the default {@link CSVStrategy}
-   * except for the delimiter setting.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter) {
-    this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
-  }
-  
-  /**
-   * Customized csv parser.
-   * 
-   * The parser parses according to the given CSV dialect settings.
-   * Leading whitespaces are truncated, unicode escapes are
-   * not interpreted and empty lines are ignored.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @param encapsulator a Char used as value encapsulation marker
-   * @param commentStart a Char used for comment identification
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
-    this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
-  }
+    // the input stream
+    private final ExtendedBufferedReader in;
 
-  /**
-   * Customized CSV parser using the given {@link CSVStrategy}
-   *
-   * @param input a Reader containing ""csv-formatted"" input
-   * @param strategy the CSVStrategy used for CSV parsing
-   */
-  public CSVParser(Reader input, CSVStrategy strategy) {
-    this.in = new ExtendedBufferedReader(input);
-    this.strategy = strategy;
-  }
-  
-  // ======================================================
-  //  the parser
-  // ======================================================
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the content as an array of records
-   * (whereas records are arrays of single values).
-   * <p>
-   * The returned content starts at the current parse-position in
-   * the stream.
-   * 
-   * @return matrix of records x values ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[][] getAllValues() throws IOException {
-    ArrayList records = new ArrayList();
-    String[] values;
-    String[][] ret = null;
-    while ((values = getLine()) != null)  {
-      records.add(values);
+    private final CSVStrategy strategy;
+
+    // the following objects are shared to reduce garbage
+    /**
+     * A record buffer for getLine(). Grows as necessary and is reused.
+     */
+    private final ArrayList record = new ArrayList();
+    private final Token reusableToken = new Token();
+    private final CharBuffer wsBuf = new CharBuffer();
+    private final CharBuffer code = new CharBuffer(4);
+
+
+    /**
+     * Token is an internal token representation.
+     * <p/>
+     * It is used as contract between the lexer and the parser.
+     */
+    static class Token {
+        /**
+         * Token type, see TT_xxx constants.
+         */
+        int type = TT_INVALID;
+        /**
+         * The content buffer.
+         */
+        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
+        /**
+         * Token ready flag: indicates a valid token with content (ready for the parser).
+         */
+        boolean isReady;
+
+        Token reset() {
+            content.clear();
+            type = TT_INVALID;
+            isReady = false;
+            return this;
+        }
     }
-    if (records.size() > 0) {
-      ret = new String[records.size()][];
-      records.toArray(ret);
+
+    // ======================================================
+    //  the constructor
+    // ======================================================
+
+    /**
+     * Default strategy for the parser follows the default {@link CSVStrategy}.
+     *
+     * @param input an InputStream containing ""csv-formatted"" stream
+     * @deprecated use {@link #CSVParser(Reader)}.
+     */
+    public CSVParser(InputStream input) {
+        this(new InputStreamReader(input));
     }
-    return ret;
-  }
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the next csv-value as string.
-   * 
-   * @return next value in the input stream ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String nextValue() throws IOException {
-    Token tkn = nextToken();
-    String ret = null;
-    switch (tkn.type) {
-      case TT_TOKEN:
-      case TT_EORECORD: 
-        ret = tkn.content.toString();
-        break;
-      case TT_EOF:
-        ret = null;
-        break;
-      case TT_INVALID:
-      default:
-        // error no token available (or error)
-        throw new IOException(
-          ""(line "" + getLineNumber() 
-          + "") invalid parse sequence"");
-        // unreachable: break;
+
+    /**
+     * CSV parser using the default {@link CSVStrategy}.
+     *
+     * @param input a Reader containing ""csv-formatted"" input
+     */
+    public CSVParser(Reader input) {
+        this(input, (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone());
     }
-    return ret;
-  }
-  
-  /**
-   * Parses from the current point in the stream til
-   * the end of the current line.
-   * 
-   * @return array of values til end of line 
-   *        ('null' when end of file has been reached)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[] getLine() throws IOException {
-    String[] ret = EMPTY_STRING_ARRAY;
-    record.clear();
-    while (true) {
-        reusableToken.reset();
-        nextToken(reusableToken);
-        switch (reusableToken.type) {
+
+    /**
+     * Customized value delimiter parser.
+     * <p/>
+     * The parser follows the default {@link CSVStrategy}
+     * except for the delimiter setting.
+     *
+     * @param input     a Reader based on ""csv-formatted"" input
+     * @param delimiter a Char used for value separation
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter) {
+        this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
+    }
+
+    /**
+     * Customized csv parser.
+     * <p/>
+     * The parser parses according to the given CSV dialect settings.
+     * Leading whitespaces are truncated, unicode escapes are
+     * not interpreted and empty lines are ignored.
+     *
+     * @param input        a Reader based on ""csv-formatted"" input
+     * @param delimiter    a Char used for value separation
+     * @param encapsulator a Char used as value encapsulation marker
+     * @param commentStart a Char used for comment identification
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
+        this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
+    }
+
+    /**
+     * Customized CSV parser using the given {@link CSVStrategy}
+     *
+     * @param input    a Reader containing ""csv-formatted"" input
+     * @param strategy the CSVStrategy used for CSV parsing
+     */
+    public CSVParser(Reader input, CSVStrategy strategy) {
+        this.in = new ExtendedBufferedReader(input);
+        this.strategy = strategy;
+    }
+
+    // ======================================================
+    //  the parser
+    // ======================================================
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the content as an array of records
+     * (whereas records are arrays of single values).
+     * <p/>
+     * The returned content starts at the current parse-position in
+     * the stream.
+     *
+     * @return matrix of records x values ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String[][] getAllValues() throws IOException {
+        ArrayList records = new ArrayList();
+        String[] values;
+        String[][] ret = null;
+        while ((values = getLine()) != null) {
+            records.add(values);
+        }
+        if (records.size() > 0) {
+            ret = new String[records.size()][];
+            records.toArray(ret);
+        }
+        return ret;
+    }
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the next csv-value as string.
+     *
+     * @return next value in the input stream ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String nextValue() throws IOException {
+        Token tkn = nextToken();
+        String ret = null;
+        switch (tkn.type) {
             case TT_TOKEN:
-                record.add(reusableToken.content.toString());
-                break;
             case TT_EORECORD:
-                record.add(reusableToken.content.toString());
+                ret = tkn.content.toString();
                 break;
             case TT_EOF:
-                if (reusableToken.isReady) {
-                    record.add(reusableToken.content.toString());
-                } else {
-                    ret = null;
-                }
+                ret = null;
                 break;
             case TT_INVALID:
             default:
-                // error: throw IOException
-                throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
-            // unreachable: break;
+                // error no token available (or error)
+                throw new IOException(
+                        ""(line "" + getLineNumber()
+                                + "") invalid parse sequence"");
+                // unreachable: break;
         }
-        if (reusableToken.type != TT_TOKEN) {
-            break;
-        }
+        return ret;
     }
-    if (!record.isEmpty()) {
-      ret = (String[]) record.toArray(new String[record.size()]);
-    }
-    return ret;
-  }
-  
-  /**
-   * Returns the current line number in the input stream.
-   * 
-   * ATTENTION: in case your csv has multiline-values the returned
-   *            number does not correspond to the record-number
-   * 
-   * @return  current line number
-   */
-  public int getLineNumber() {
-    return in.getLineNumber();  
-  }
-  
-  // ======================================================
-  //  the lexer(s)
-  // ======================================================
- 
-  /**
-   * Convenience method for <code>nextToken(null)</code>.
-   */
-  protected Token nextToken() throws IOException {
-      return nextToken(new Token());
-  }
-  
- /**
-   * Returns the next token.
-   * 
-   * A token corresponds to a term, a record change or an
-   * end-of-file indicator.
-   * 
-   * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
-   * Token.
-   * @return the next token found
-   * @throws IOException on stream access error
-   */
-  protected Token nextToken(Token tkn) throws IOException {
-    wsBuf.clear(); // reuse
-    
-    // get the last read char (required for empty line detection)
-    int lastChar = in.readAgain();
-    
-    //  read the next char and set eol
-    /* note: unfortunately isEndOfLine may consumes a character silently.
-     *       this has no effect outside of the method. so a simple workaround
-     *       is to call 'readAgain' on the stream...
-     *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+
+    /**
+     * Parses from the current point in the stream til
+     * the end of the current line.
+     *
+     * @return array of values til end of line
+     *         ('null' when end of file has been reached)
+     * @throws IOException on parse error or input read-failure
      */
-    int c = in.read();
-    boolean eol = isEndOfLine(c);
-    c = in.readAgain();
-     
-    //  empty line detection: eol AND (last char was EOL or beginning)
-    while (strategy.getIgnoreEmptyLines() && eol 
-      && (lastChar == '\n' 
-      || lastChar == '\r' 
-      || lastChar == ExtendedBufferedReader.UNDEFINED) 
-      && !isEndOfFile(lastChar)) {
-      // go on char ahead ...
-      lastChar = c;
-      c = in.read();
-      eol = isEndOfLine(c);
-      c = in.readAgain();
-      // reached end of file without any content (empty line at the end)
-      if (isEndOfFile(c)) {
-        tkn.type = TT_EOF;
-        return tkn;
-      }
-    }
-
-    // did we reach eof during the last iteration already ? TT_EOF
-    if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
-      tkn.type = TT_EOF;
-      return tkn;
-    } 
-    
-    //  important: make sure a new char gets consumed in each iteration
-    while (!tkn.isReady && tkn.type != TT_EOF) {
-      // ignore whitespaces at beginning of a token
-      while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
-        wsBuf.append((char) c);
-        c = in.read();
-        eol = isEndOfLine(c);
-      }
-      // ok, start of token reached: comment, encapsulated, or token
-      if (c == strategy.getCommentStart()) {
-        // ignore everything till end of line and continue (incr linecount)
-        in.readLine();
-        tkn = nextToken(tkn.reset());
-      } else if (c == strategy.getDelimiter()) {
-        // empty token return TT_TOKEN("""")
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-      } else if (eol) {
-        // empty token return TT_EORECORD("""")
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-      } else if (c == strategy.getEncapsulator()) {
-        // consume encapsulated token
-        encapsulatedTokenLexer(tkn, c);
-      } else if (isEndOfFile(c)) {
-        // end of file return TT_EOF()
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-      } else {
-        // next token must be a simple token
-        // add removed blanks when not ignoring whitespace chars...
-        if (!strategy.getIgnoreLeadingWhitespaces()) {
-          tkn.content.append(wsBuf);
-        }
-        simpleTokenLexer(tkn, c);
-      }
-    }
-    return tkn;  
-  }
-  
-  /**
-   * A simple token lexer
-   * 
-   * Simple token are tokens which are not surrounded by encapsulators.
-   * A simple token might contain escaped delimiters (as \, or \;). The
-   * token is finished when one of the following conditions become true:
-   * <ul>
-   *   <li>end of line has been reached (TT_EORECORD)</li>
-   *   <li>end of stream has been reached (TT_EOF)</li>
-   *   <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
-   * </ul>
-   *  
-   * @param tkn  the current token
-   * @param c    the current character
-   * @return the filled token
-   * 
-   * @throws IOException on stream access error
-   */
-  private Token simpleTokenLexer(Token tkn, int c) throws IOException {
-    for (;;) {
-      if (isEndOfLine(c)) {
-        // end of record
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-        break;
-      } else if (isEndOfFile(c)) {
-        // end of file
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-        break;
-      } else if (c == strategy.getDelimiter()) {
-        // end of token
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-        break;
-      } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
-        // interpret unicode escaped chars (like \u0070 -> p)
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else {
-        tkn.content.append((char) c);
-      }
-      
-      c = in.read();
-    }
-
-    if (strategy.getIgnoreTrailingWhitespaces()) {
-      tkn.content.trimTrailingWhitespace();
-    }
-
-    return tkn;
-  }
-  
-  
-  /**
-   * An encapsulated token lexer
-   * 
-   * Encapsulated tokens are surrounded by the given encapsulating-string.
-   * The encapsulator itself might be included in the token using a
-   * doubling syntax (as """", '') or using escaping (as in \"", \').
-   * Whitespaces before and after an encapsulated token are ignored.
-   * 
-   * @param tkn    the current token
-   * @param c      the current character
-   * @return a valid token object
-   * @throws IOException on invalid state
-   */
-  private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
-    // save current line
-    int startLineNumber = getLineNumber();
-    // ignore the given delimiter
-    // assert c == delimiter;
-    for (;;) {
-      c = in.read();
-
-      if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead()=='u') {
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else if (c == strategy.getEncapsulator()) {
-        if (in.lookAhead() == strategy.getEncapsulator()) {
-          // double or escaped encapsulator -> add single encapsulator to token
-          c = in.read();
-          tkn.content.append((char) c);
-        } else {
-          // token finish mark (encapsulator) reached: ignore whitespace till delimiter
-          for (;;) {
-            c = in.read();
-            if (c == strategy.getDelimiter()) {
-              tkn.type = TT_TOKEN;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfFile(c)) {
-              tkn.type = TT_EOF;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfLine(c)) {
-              // ok eo token reached
-              tkn.type = TT_EORECORD;
-              tkn.isReady = true;
-              return tkn;
-            } else if (!isWhitespace(c)) {
-              // error invalid char between token and next delimiter
-              throw new IOException(
-                      ""(line "" + getLineNumber()
-                              + "") invalid char between encapsulated token end delimiter""
-              );
+    public String[] getLine() throws IOException {
+        String[] ret = EMPTY_STRING_ARRAY;
+        record.clear();
+        while (true) {
+            reusableToken.reset();
+            nextToken(reusableToken);
+            switch (reusableToken.type) {
+                case TT_TOKEN:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EORECORD:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EOF:
+                    if (reusableToken.isReady) {
+                        record.add(reusableToken.content.toString());
+                    } else {
+                        ret = null;
+                    }
+                    break;
+                case TT_INVALID:
+                default:
+                    // error: throw IOException
+                    throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
+                    // unreachable: break;
             }
-          }
+            if (reusableToken.type != TT_TOKEN) {
+                break;
+            }
         }
-      } else if (isEndOfFile(c)) {
-        // error condition (end of file before end of token)
-        throw new IOException(
-                ""(startline "" + startLineNumber + "")""
-                        + ""eof reached before encapsulated token finished""
-        );
-      } else {
-        // consume character
-        tkn.content.append((char) c);
-      }
-    }
-  }
-  
-  
-  /**
-   * Decodes Unicode escapes.
-   * 
-   * Interpretation of ""\\uXXXX"" escape sequences
-   * where XXXX is a hex-number.
-   * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
-   * @return the decoded character
-   * @throws IOException on wrong unicode escape sequence or read error
-   */
-  protected int unicodeEscapeLexer(int c) throws IOException {
-    int ret = 0;
-    // ignore 'u' (assume c==\ now) and read 4 hex digits
-    c = in.read();
-    code.clear();
-    try {
-      for (int i = 0; i < 4; i++) {
-        c  = in.read();
-        if (isEndOfFile(c) || isEndOfLine(c)) {
-          throw new NumberFormatException(""number too short"");
+        if (!record.isEmpty()) {
+            ret = (String[]) record.toArray(new String[record.size()]);
         }
-        code.append((char) c);
-      }
-      ret = Integer.parseInt(code.toString(), 16);
-    } catch (NumberFormatException e) {
-      throw new IOException(
-        ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '"" 
-        + code.toString() + ""'"" + e.toString());
+        return ret;
     }
-    return ret;
-  }
 
-  private int readEscape(int c) throws IOException {
-    // assume c is the escape char (normally a backslash)
-    c = in.read();
-    int out;
-    switch (c) {
-      case 'r': out='\r'; break;
-      case 'n': out='\n'; break;
-      case 't': out='\t'; break;
-      case 'b': out='\b'; break;
-      case 'f': out='\f'; break;
-      default : out=c;
+    /**
+     * Returns the current line number in the input stream.
+     * <p/>
+     * ATTENTION: in case your csv has multiline-values the returned
+     * number does not correspond to the record-number
+     *
+     * @return current line number
+     */
+    public int getLineNumber() {
+        return in.getLineNumber();
     }
-    return out;
-  }
-  
-  // ======================================================
-  //  strategies
-  // ======================================================
-  
-  /**
-   * Obtain the specified CSV Strategy.  This should not be modified.
-   * 
-   * @return strategy currently being used
-   */
-  public CSVStrategy getStrategy() {
-    return this.strategy;
-  }
-  
-  // ======================================================
-  //  Character class checker
-  // ======================================================
-  
-  /**
-   * @return true if the given char is a whitespace character
-   */
-  private boolean isWhitespace(int c) {
-    return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
-  }
-  
-  /**
-   * Greedy - accepts \n, \r and \r\n 
-   * This checker consumes silently the second control-character...
-   * 
-   * @return true if the given character is a line-terminator
-   */
-  private boolean isEndOfLine(int c) throws IOException {
-    // check if we have \r\n...
-    if (c == '\r') {
-      if (in.lookAhead() == '\n') {
-        // note: does not change c outside of this method !!
+
+    // ======================================================
+    //  the lexer(s)
+    // ======================================================
+
+    /**
+     * Convenience method for <code>nextToken(null)</code>.
+     */
+    protected Token nextToken() throws IOException {
+        return nextToken(new Token());
+    }
+
+    /**
+     * Returns the next token.
+     * <p/>
+     * A token corresponds to a term, a record change or an
+     * end-of-file indicator.
+     *
+     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
+     *            Token.
+     * @return the next token found
+     * @throws IOException on stream access error
+     */
+    protected Token nextToken(Token tkn) throws IOException {
+        wsBuf.clear(); // reuse
+
+        // get the last read char (required for empty line detection)
+        int lastChar = in.readAgain();
+
+        //  read the next char and set eol
+        /* note: unfortunately isEndOfLine may consumes a character silently.
+        *       this has no effect outside of the method. so a simple workaround
+        *       is to call 'readAgain' on the stream...
+        *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+        */
+        int c = in.read();
+        boolean eol = isEndOfLine(c);
+        c = in.readAgain();
+
+        //  empty line detection: eol AND (last char was EOL or beginning)
+        while (strategy.getIgnoreEmptyLines() && eol
+                && (lastChar == '\n'
+                || lastChar == '\r'
+                || lastChar == ExtendedBufferedReader.UNDEFINED)
+                && !isEndOfFile(lastChar)) {
+            // go on char ahead ...
+            lastChar = c;
+            c = in.read();
+            eol = isEndOfLine(c);
+            c = in.readAgain();
+            // reached end of file without any content (empty line at the end)
+            if (isEndOfFile(c)) {
+                tkn.type = TT_EOF;
+                return tkn;
+            }
+        }
+
+        // did we reach eof during the last iteration already ? TT_EOF
+        if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
+            tkn.type = TT_EOF;
+            return tkn;
+        }
+
+        //  important: make sure a new char gets consumed in each iteration
+        while (!tkn.isReady && tkn.type != TT_EOF) {
+            // ignore whitespaces at beginning of a token
+            while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
+                wsBuf.append((char) c);
+                c = in.read();
+                eol = isEndOfLine(c);
+            }
+            // ok, start of token reached: comment, encapsulated, or token
+            if (c == strategy.getCommentStart()) {
+                // ignore everything till end of line and continue (incr linecount)
+                in.readLine();
+                tkn = nextToken(tkn.reset());
+            } else if (c == strategy.getDelimiter()) {
+                // empty token return TT_TOKEN("""")
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+            } else if (eol) {
+                // empty token return TT_EORECORD("""")
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+            } else if (c == strategy.getEncapsulator()) {
+                // consume encapsulated token
+                encapsulatedTokenLexer(tkn, c);
+            } else if (isEndOfFile(c)) {
+                // end of file return TT_EOF()
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+            } else {
+                // next token must be a simple token
+                // add removed blanks when not ignoring whitespace chars...
+                if (!strategy.getIgnoreLeadingWhitespaces()) {
+                    tkn.content.append(wsBuf);
+                }
+                simpleTokenLexer(tkn, c);
+            }
+        }
+        return tkn;
+    }
+
+    /**
+     * A simple token lexer
+     * <p/>
+     * Simple token are tokens which are not surrounded by encapsulators.
+     * A simple token might contain escaped delimiters (as \, or \;). The
+     * token is finished when one of the following conditions become true:
+     * <ul>
+     * <li>end of line has been reached (TT_EORECORD)</li>
+     * <li>end of stream has been reached (TT_EOF)</li>
+     * <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
+     * </ul>
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return the filled token
+     * @throws IOException on stream access error
+     */
+    private Token simpleTokenLexer(Token tkn, int c) throws IOException {
+        for (; ;) {
+            if (isEndOfLine(c)) {
+                // end of record
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+                break;
+            } else if (isEndOfFile(c)) {
+                // end of file
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+                break;
+            } else if (c == strategy.getDelimiter()) {
+                // end of token
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+                break;
+            } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                // interpret unicode escaped chars (like \u0070 -> p)
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else {
+                tkn.content.append((char) c);
+            }
+
+            c = in.read();
+        }
+
+        if (strategy.getIgnoreTrailingWhitespaces()) {
+            tkn.content.trimTrailingWhitespace();
+        }
+
+        return tkn;
+    }
+
+
+    /**
+     * An encapsulated token lexer
+     * <p/>
+     * Encapsulated tokens are surrounded by the given encapsulating-string.
+     * The encapsulator itself might be included in the token using a
+     * doubling syntax (as """", '') or using escaping (as in \"", \').
+     * Whitespaces before and after an encapsulated token are ignored.
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return a valid token object
+     * @throws IOException on invalid state
+     */
+    private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
+        // save current line
+        int startLineNumber = getLineNumber();
+        // ignore the given delimiter
+        // assert c == delimiter;
+        for (; ;) {
+            c = in.read();
+
+            if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else if (c == strategy.getEncapsulator()) {
+                if (in.lookAhead() == strategy.getEncapsulator()) {
+                    // double or escaped encapsulator -> add single encapsulator to token
+                    c = in.read();
+                    tkn.content.append((char) c);
+                } else {
+                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter
+                    for (; ;) {
+                        c = in.read();
+                        if (c == strategy.getDelimiter()) {
+                            tkn.type = TT_TOKEN;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfFile(c)) {
+                            tkn.type = TT_EOF;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfLine(c)) {
+                            // ok eo token reached
+                            tkn.type = TT_EORECORD;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (!isWhitespace(c)) {
+                            // error invalid char between token and next delimiter
+                            throw new IOException(
+                                    ""(line "" + getLineNumber()
+                                            + "") invalid char between encapsulated token end delimiter""
+                            );
+                        }
+                    }
+                }
+            } else if (isEndOfFile(c)) {
+                // error condition (end of file before end of token)
+                throw new IOException(
+                        ""(startline "" + startLineNumber + "")""
+                                + ""eof reached before encapsulated token finished""
+                );
+            } else {
+                // consume character
+                tkn.content.append((char) c);
+            }
+        }
+    }
+
+
+    /**
+     * Decodes Unicode escapes.
+     * <p/>
+     * Interpretation of ""\\uXXXX"" escape sequences
+     * where XXXX is a hex-number.
+     *
+     * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
+     * @return the decoded character
+     * @throws IOException on wrong unicode escape sequence or read error
+     */
+    protected int unicodeEscapeLexer(int c) throws IOException {
+        int ret = 0;
+        // ignore 'u' (assume c==\ now) and read 4 hex digits
         c = in.read();
-      }
+        code.clear();
+        try {
+            for (int i = 0; i < 4; i++) {
+                c = in.read();
+                if (isEndOfFile(c) || isEndOfLine(c)) {
+                    throw new NumberFormatException(""number too short"");
+                }
+                code.append((char) c);
+            }
+            ret = Integer.parseInt(code.toString(), 16);
+        } catch (NumberFormatException e) {
+            throw new IOException(
+                    ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '""
+                            + code.toString() + ""'"" + e.toString());
+        }
+        return ret;
     }
-    return (c == '\n' || c == '\r');
-  }
-  
-  /**
-   * @return true if the given character indicates end of file
-   */
-  private boolean isEndOfFile(int c) {
-    return c == ExtendedBufferedReader.END_OF_STREAM;
-  }
+
+    private int readEscape(int c) throws IOException {
+        // assume c is the escape char (normally a backslash)
+        c = in.read();
+        int out;
+        switch (c) {
+            case 'r':
+                out = '\r';
+                break;
+            case 'n':
+                out = '\n';
+                break;
+            case 't':
+                out = '\t';
+                break;
+            case 'b':
+                out = '\b';
+                break;
+            case 'f':
+                out = '\f';
+                break;
+            default:
+                out = c;
+        }
+        return out;
+    }
+
+    // ======================================================
+    //  strategies
+    // ======================================================
+
+    /**
+     * Obtain the specified CSV Strategy.  This should not be modified.
+     *
+     * @return strategy currently being used
+     */
+    public CSVStrategy getStrategy() {
+        return this.strategy;
+    }
+
+    // ======================================================
+    //  Character class checker
+    // ======================================================
+
+    /**
+     * @return true if the given char is a whitespace character
+     */
+    private boolean isWhitespace(int c) {
+        return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
+    }
+
+    /**
+     * Greedy - accepts \n, \r and \r\n
+     * This checker consumes silently the second control-character...
+     *
+     * @return true if the given character is a line-terminator
+     */
+    private boolean isEndOfLine(int c) throws IOException {
+        // check if we have \r\n...
+        if (c == '\r') {
+            if (in.lookAhead() == '\n') {
+                // note: does not change c outside of this method !!
+                c = in.read();
+            }
+        }
+        return (c == '\n' || c == '\r');
+    }
+
+    /**
+     * @return true if the given character indicates end of file
+     */
+    private boolean isEndOfFile(int c) {
+        return c == ExtendedBufferedReader.END_OF_STREAM;
+    }
 }
",,25502
5812,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/CSVParser.java,4b5faabefd896ef24b21d7f9d3dc20741f6b89b8,1134798179,263,0e1f0adb716515aba5e98e5690779f2fb73ad716,1134798372,269,1166ca605bcc035654771f1ddc1092d86f2ec1e8,1296549960,-1,1296549960/1134798179,"        ret = null;","  *
  * Because CSV appears in many different dialects, the parser supports many
  * configuration settings by allowing the specification of a {@link CSVStrategy}.
- * 
+ *
  * <p>Parsing of a csv-string having tabs as separators,
  * '""' as an optional value encapsulator, and comments starting with '#':</p>
  * <pre>
- *  String[][] data = 
+ *  String[][] data =
  *   (new CSVParser(new StringReader(""a\tb\nc\td""), new CSVStrategy('\t','""','#'))).getAllValues();
  * </pre>
- * 
+ *
  * <p>Parsing of a csv-string in Excel CSV format</p>
  * <pre>
  *  String[][] data =
  *   (new CSVParser(new StringReader(""a;b\nc;d""), CSVStrategy.EXCEL_STRATEGY)).getAllValues();
  * </pre>
- * 
+ *
  * <p>
  * Internal parser state is completely covered by the strategy
  * and the reader-state.</p>
- * 
- * <p>see <a href=""package-summary.html"">package documentation</a> 
+ *
+ * <p>see <a href=""package-summary.html"">package documentation</a>
  * for more details</p>
  */
 public class CSVParser {
 
-  /** length of the initial token (content-)buffer */
-  private static final int INITIAL_TOKEN_LENGTH = 50;
-  
-  // the token types
-  /** Token has no valid content, i.e. is in its initialized state. */
-  protected static final int TT_INVALID = -1;
-  /** Token with content, at beginning or in the middle of a line. */
-  protected static final int TT_TOKEN = 0;
-  /** Token (which can have content) when end of file is reached. */
-  protected static final int TT_EOF = 1;
-  /** Token with content when end of a line is reached. */
-  protected static final int TT_EORECORD = 2;
+    /**
+     * length of the initial token (content-)buffer
+     */
+    private static final int INITIAL_TOKEN_LENGTH = 50;
 
-  /** Immutable empty String array. */
-  private static final String[] EMPTY_STRING_ARRAY = new String[0];
-   
-  // the input stream
-  private final ExtendedBufferedReader in;
+    // the token types
+    /**
+     * Token has no valid content, i.e. is in its initialized state.
+     */
+    protected static final int TT_INVALID = -1;
+    /**
+     * Token with content, at beginning or in the middle of a line.
+     */
+    protected static final int TT_TOKEN = 0;
+    /**
+     * Token (which can have content) when end of file is reached.
+     */
+    protected static final int TT_EOF = 1;
+    /**
+     * Token with content when end of a line is reached.
+     */
+    protected static final int TT_EORECORD = 2;
 
-  private final CSVStrategy strategy;
-  
-  // the following objects are shared to reduce garbage 
-  /** A record buffer for getLine(). Grows as necessary and is reused. */
-  private final ArrayList record = new ArrayList();
-  private final Token reusableToken = new Token();
-  private final CharBuffer wsBuf = new CharBuffer();
-  private final CharBuffer code = new CharBuffer(4);
+    /**
+     * Immutable empty String array.
+     */
+    private static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  
-  /**
-   * Token is an internal token representation.
-   * 
-   * It is used as contract between the lexer and the parser. 
-   */
-  static class Token {
-    /** Token type, see TT_xxx constants. */
-    int type = TT_INVALID;
-    /** The content buffer. */
-    CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
-    /** Token ready flag: indicates a valid token with content (ready for the parser). */
-    boolean isReady;
-    
-    Token reset() {
-        content.clear();
-        type = TT_INVALID;
-        isReady = false;
-        return this;
-    }
-  }
-  
-  // ======================================================
-  //  the constructor
-  // ======================================================
-  
-  /**
-   * Default strategy for the parser follows the default {@link CSVStrategy}.
-   * 
-   * @param input an InputStream containing ""csv-formatted"" stream
-   * @deprecated use {@link #CSVParser(Reader)}.
-   */
-  public CSVParser(InputStream input) {
-    this(new InputStreamReader(input));
-  }
-  
-  /**
-   * CSV parser using the default {@link CSVStrategy}.
-   * 
-   * @param input a Reader containing ""csv-formatted"" input
-   */
-  public CSVParser(Reader input) {
-    this(input, (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone());
-  }
-  
-  /**
-   * Customized value delimiter parser.
-   * 
-   * The parser follows the default {@link CSVStrategy}
-   * except for the delimiter setting.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter) {
-    this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
-  }
-  
-  /**
-   * Customized csv parser.
-   * 
-   * The parser parses according to the given CSV dialect settings.
-   * Leading whitespaces are truncated, unicode escapes are
-   * not interpreted and empty lines are ignored.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @param encapsulator a Char used as value encapsulation marker
-   * @param commentStart a Char used for comment identification
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
-    this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
-  }
+    // the input stream
+    private final ExtendedBufferedReader in;
 
-  /**
-   * Customized CSV parser using the given {@link CSVStrategy}
-   *
-   * @param input a Reader containing ""csv-formatted"" input
-   * @param strategy the CSVStrategy used for CSV parsing
-   */
-  public CSVParser(Reader input, CSVStrategy strategy) {
-    this.in = new ExtendedBufferedReader(input);
-    this.strategy = strategy;
-  }
-  
-  // ======================================================
-  //  the parser
-  // ======================================================
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the content as an array of records
-   * (whereas records are arrays of single values).
-   * <p>
-   * The returned content starts at the current parse-position in
-   * the stream.
-   * 
-   * @return matrix of records x values ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[][] getAllValues() throws IOException {
-    ArrayList records = new ArrayList();
-    String[] values;
-    String[][] ret = null;
-    while ((values = getLine()) != null)  {
-      records.add(values);
+    private final CSVStrategy strategy;
+
+    // the following objects are shared to reduce garbage
+    /**
+     * A record buffer for getLine(). Grows as necessary and is reused.
+     */
+    private final ArrayList record = new ArrayList();
+    private final Token reusableToken = new Token();
+    private final CharBuffer wsBuf = new CharBuffer();
+    private final CharBuffer code = new CharBuffer(4);
+
+
+    /**
+     * Token is an internal token representation.
+     * <p/>
+     * It is used as contract between the lexer and the parser.
+     */
+    static class Token {
+        /**
+         * Token type, see TT_xxx constants.
+         */
+        int type = TT_INVALID;
+        /**
+         * The content buffer.
+         */
+        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
+        /**
+         * Token ready flag: indicates a valid token with content (ready for the parser).
+         */
+        boolean isReady;
+
+        Token reset() {
+            content.clear();
+            type = TT_INVALID;
+            isReady = false;
+            return this;
+        }
     }
-    if (records.size() > 0) {
-      ret = new String[records.size()][];
-      records.toArray(ret);
+
+    // ======================================================
+    //  the constructor
+    // ======================================================
+
+    /**
+     * Default strategy for the parser follows the default {@link CSVStrategy}.
+     *
+     * @param input an InputStream containing ""csv-formatted"" stream
+     * @deprecated use {@link #CSVParser(Reader)}.
+     */
+    public CSVParser(InputStream input) {
+        this(new InputStreamReader(input));
     }
-    return ret;
-  }
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the next csv-value as string.
-   * 
-   * @return next value in the input stream ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String nextValue() throws IOException {
-    Token tkn = nextToken();
-    String ret = null;
-    switch (tkn.type) {
-      case TT_TOKEN:
-      case TT_EORECORD: 
-        ret = tkn.content.toString();
-        break;
-      case TT_EOF:
-        ret = null;
-        break;
-      case TT_INVALID:
-      default:
-        // error no token available (or error)
-        throw new IOException(
-          ""(line "" + getLineNumber() 
-          + "") invalid parse sequence"");
-        // unreachable: break;
+
+    /**
+     * CSV parser using the default {@link CSVStrategy}.
+     *
+     * @param input a Reader containing ""csv-formatted"" input
+     */
+    public CSVParser(Reader input) {
+        this(input, (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone());
     }
-    return ret;
-  }
-  
-  /**
-   * Parses from the current point in the stream til
-   * the end of the current line.
-   * 
-   * @return array of values til end of line 
-   *        ('null' when end of file has been reached)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[] getLine() throws IOException {
-    String[] ret = EMPTY_STRING_ARRAY;
-    record.clear();
-    while (true) {
-        reusableToken.reset();
-        nextToken(reusableToken);
-        switch (reusableToken.type) {
+
+    /**
+     * Customized value delimiter parser.
+     * <p/>
+     * The parser follows the default {@link CSVStrategy}
+     * except for the delimiter setting.
+     *
+     * @param input     a Reader based on ""csv-formatted"" input
+     * @param delimiter a Char used for value separation
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter) {
+        this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
+    }
+
+    /**
+     * Customized csv parser.
+     * <p/>
+     * The parser parses according to the given CSV dialect settings.
+     * Leading whitespaces are truncated, unicode escapes are
+     * not interpreted and empty lines are ignored.
+     *
+     * @param input        a Reader based on ""csv-formatted"" input
+     * @param delimiter    a Char used for value separation
+     * @param encapsulator a Char used as value encapsulation marker
+     * @param commentStart a Char used for comment identification
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
+        this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
+    }
+
+    /**
+     * Customized CSV parser using the given {@link CSVStrategy}
+     *
+     * @param input    a Reader containing ""csv-formatted"" input
+     * @param strategy the CSVStrategy used for CSV parsing
+     */
+    public CSVParser(Reader input, CSVStrategy strategy) {
+        this.in = new ExtendedBufferedReader(input);
+        this.strategy = strategy;
+    }
+
+    // ======================================================
+    //  the parser
+    // ======================================================
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the content as an array of records
+     * (whereas records are arrays of single values).
+     * <p/>
+     * The returned content starts at the current parse-position in
+     * the stream.
+     *
+     * @return matrix of records x values ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String[][] getAllValues() throws IOException {
+        ArrayList records = new ArrayList();
+        String[] values;
+        String[][] ret = null;
+        while ((values = getLine()) != null) {
+            records.add(values);
+        }
+        if (records.size() > 0) {
+            ret = new String[records.size()][];
+            records.toArray(ret);
+        }
+        return ret;
+    }
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the next csv-value as string.
+     *
+     * @return next value in the input stream ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String nextValue() throws IOException {
+        Token tkn = nextToken();
+        String ret = null;
+        switch (tkn.type) {
             case TT_TOKEN:
-                record.add(reusableToken.content.toString());
-                break;
             case TT_EORECORD:
-                record.add(reusableToken.content.toString());
+                ret = tkn.content.toString();
                 break;
             case TT_EOF:
-                if (reusableToken.isReady) {
-                    record.add(reusableToken.content.toString());
-                } else {
-                    ret = null;
-                }
+                ret = null;
                 break;
             case TT_INVALID:
             default:
-                // error: throw IOException
-                throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
-            // unreachable: break;
+                // error no token available (or error)
+                throw new IOException(
+                        ""(line "" + getLineNumber()
+                                + "") invalid parse sequence"");
+                // unreachable: break;
         }
-        if (reusableToken.type != TT_TOKEN) {
-            break;
-        }
+        return ret;
     }
-    if (!record.isEmpty()) {
-      ret = (String[]) record.toArray(new String[record.size()]);
-    }
-    return ret;
-  }
-  
-  /**
-   * Returns the current line number in the input stream.
-   * 
-   * ATTENTION: in case your csv has multiline-values the returned
-   *            number does not correspond to the record-number
-   * 
-   * @return  current line number
-   */
-  public int getLineNumber() {
-    return in.getLineNumber();  
-  }
-  
-  // ======================================================
-  //  the lexer(s)
-  // ======================================================
- 
-  /**
-   * Convenience method for <code>nextToken(null)</code>.
-   */
-  protected Token nextToken() throws IOException {
-      return nextToken(new Token());
-  }
-  
- /**
-   * Returns the next token.
-   * 
-   * A token corresponds to a term, a record change or an
-   * end-of-file indicator.
-   * 
-   * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
-   * Token.
-   * @return the next token found
-   * @throws IOException on stream access error
-   */
-  protected Token nextToken(Token tkn) throws IOException {
-    wsBuf.clear(); // reuse
-    
-    // get the last read char (required for empty line detection)
-    int lastChar = in.readAgain();
-    
-    //  read the next char and set eol
-    /* note: unfortunately isEndOfLine may consumes a character silently.
-     *       this has no effect outside of the method. so a simple workaround
-     *       is to call 'readAgain' on the stream...
-     *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+
+    /**
+     * Parses from the current point in the stream til
+     * the end of the current line.
+     *
+     * @return array of values til end of line
+     *         ('null' when end of file has been reached)
+     * @throws IOException on parse error or input read-failure
      */
-    int c = in.read();
-    boolean eol = isEndOfLine(c);
-    c = in.readAgain();
-     
-    //  empty line detection: eol AND (last char was EOL or beginning)
-    while (strategy.getIgnoreEmptyLines() && eol 
-      && (lastChar == '\n' 
-      || lastChar == '\r' 
-      || lastChar == ExtendedBufferedReader.UNDEFINED) 
-      && !isEndOfFile(lastChar)) {
-      // go on char ahead ...
-      lastChar = c;
-      c = in.read();
-      eol = isEndOfLine(c);
-      c = in.readAgain();
-      // reached end of file without any content (empty line at the end)
-      if (isEndOfFile(c)) {
-        tkn.type = TT_EOF;
-        return tkn;
-      }
-    }
-
-    // did we reach eof during the last iteration already ? TT_EOF
-    if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
-      tkn.type = TT_EOF;
-      return tkn;
-    } 
-    
-    //  important: make sure a new char gets consumed in each iteration
-    while (!tkn.isReady && tkn.type != TT_EOF) {
-      // ignore whitespaces at beginning of a token
-      while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
-        wsBuf.append((char) c);
-        c = in.read();
-        eol = isEndOfLine(c);
-      }
-      // ok, start of token reached: comment, encapsulated, or token
-      if (c == strategy.getCommentStart()) {
-        // ignore everything till end of line and continue (incr linecount)
-        in.readLine();
-        tkn = nextToken(tkn.reset());
-      } else if (c == strategy.getDelimiter()) {
-        // empty token return TT_TOKEN("""")
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-      } else if (eol) {
-        // empty token return TT_EORECORD("""")
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-      } else if (c == strategy.getEncapsulator()) {
-        // consume encapsulated token
-        encapsulatedTokenLexer(tkn, c);
-      } else if (isEndOfFile(c)) {
-        // end of file return TT_EOF()
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-      } else {
-        // next token must be a simple token
-        // add removed blanks when not ignoring whitespace chars...
-        if (!strategy.getIgnoreLeadingWhitespaces()) {
-          tkn.content.append(wsBuf);
-        }
-        simpleTokenLexer(tkn, c);
-      }
-    }
-    return tkn;  
-  }
-  
-  /**
-   * A simple token lexer
-   * 
-   * Simple token are tokens which are not surrounded by encapsulators.
-   * A simple token might contain escaped delimiters (as \, or \;). The
-   * token is finished when one of the following conditions become true:
-   * <ul>
-   *   <li>end of line has been reached (TT_EORECORD)</li>
-   *   <li>end of stream has been reached (TT_EOF)</li>
-   *   <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
-   * </ul>
-   *  
-   * @param tkn  the current token
-   * @param c    the current character
-   * @return the filled token
-   * 
-   * @throws IOException on stream access error
-   */
-  private Token simpleTokenLexer(Token tkn, int c) throws IOException {
-    for (;;) {
-      if (isEndOfLine(c)) {
-        // end of record
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-        break;
-      } else if (isEndOfFile(c)) {
-        // end of file
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-        break;
-      } else if (c == strategy.getDelimiter()) {
-        // end of token
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-        break;
-      } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
-        // interpret unicode escaped chars (like \u0070 -> p)
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else {
-        tkn.content.append((char) c);
-      }
-      
-      c = in.read();
-    }
-
-    if (strategy.getIgnoreTrailingWhitespaces()) {
-      tkn.content.trimTrailingWhitespace();
-    }
-
-    return tkn;
-  }
-  
-  
-  /**
-   * An encapsulated token lexer
-   * 
-   * Encapsulated tokens are surrounded by the given encapsulating-string.
-   * The encapsulator itself might be included in the token using a
-   * doubling syntax (as """", '') or using escaping (as in \"", \').
-   * Whitespaces before and after an encapsulated token are ignored.
-   * 
-   * @param tkn    the current token
-   * @param c      the current character
-   * @return a valid token object
-   * @throws IOException on invalid state
-   */
-  private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
-    // save current line
-    int startLineNumber = getLineNumber();
-    // ignore the given delimiter
-    // assert c == delimiter;
-    for (;;) {
-      c = in.read();
-
-      if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead()=='u') {
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else if (c == strategy.getEncapsulator()) {
-        if (in.lookAhead() == strategy.getEncapsulator()) {
-          // double or escaped encapsulator -> add single encapsulator to token
-          c = in.read();
-          tkn.content.append((char) c);
-        } else {
-          // token finish mark (encapsulator) reached: ignore whitespace till delimiter
-          for (;;) {
-            c = in.read();
-            if (c == strategy.getDelimiter()) {
-              tkn.type = TT_TOKEN;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfFile(c)) {
-              tkn.type = TT_EOF;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfLine(c)) {
-              // ok eo token reached
-              tkn.type = TT_EORECORD;
-              tkn.isReady = true;
-              return tkn;
-            } else if (!isWhitespace(c)) {
-              // error invalid char between token and next delimiter
-              throw new IOException(
-                      ""(line "" + getLineNumber()
-                              + "") invalid char between encapsulated token end delimiter""
-              );
+    public String[] getLine() throws IOException {
+        String[] ret = EMPTY_STRING_ARRAY;
+        record.clear();
+        while (true) {
+            reusableToken.reset();
+            nextToken(reusableToken);
+            switch (reusableToken.type) {
+                case TT_TOKEN:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EORECORD:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EOF:
+                    if (reusableToken.isReady) {
+                        record.add(reusableToken.content.toString());
+                    } else {
+                        ret = null;
+                    }
+                    break;
+                case TT_INVALID:
+                default:
+                    // error: throw IOException
+                    throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
+                    // unreachable: break;
             }
-          }
+            if (reusableToken.type != TT_TOKEN) {
+                break;
+            }
         }
-      } else if (isEndOfFile(c)) {
-        // error condition (end of file before end of token)
-        throw new IOException(
-                ""(startline "" + startLineNumber + "")""
-                        + ""eof reached before encapsulated token finished""
-        );
-      } else {
-        // consume character
-        tkn.content.append((char) c);
-      }
-    }
-  }
-  
-  
-  /**
-   * Decodes Unicode escapes.
-   * 
-   * Interpretation of ""\\uXXXX"" escape sequences
-   * where XXXX is a hex-number.
-   * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
-   * @return the decoded character
-   * @throws IOException on wrong unicode escape sequence or read error
-   */
-  protected int unicodeEscapeLexer(int c) throws IOException {
-    int ret = 0;
-    // ignore 'u' (assume c==\ now) and read 4 hex digits
-    c = in.read();
-    code.clear();
-    try {
-      for (int i = 0; i < 4; i++) {
-        c  = in.read();
-        if (isEndOfFile(c) || isEndOfLine(c)) {
-          throw new NumberFormatException(""number too short"");
+        if (!record.isEmpty()) {
+            ret = (String[]) record.toArray(new String[record.size()]);
         }
-        code.append((char) c);
-      }
-      ret = Integer.parseInt(code.toString(), 16);
-    } catch (NumberFormatException e) {
-      throw new IOException(
-        ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '"" 
-        + code.toString() + ""'"" + e.toString());
+        return ret;
     }
-    return ret;
-  }
 
-  private int readEscape(int c) throws IOException {
-    // assume c is the escape char (normally a backslash)
-    c = in.read();
-    int out;
-    switch (c) {
-      case 'r': out='\r'; break;
-      case 'n': out='\n'; break;
-      case 't': out='\t'; break;
-      case 'b': out='\b'; break;
-      case 'f': out='\f'; break;
-      default : out=c;
+    /**
+     * Returns the current line number in the input stream.
+     * <p/>
+     * ATTENTION: in case your csv has multiline-values the returned
+     * number does not correspond to the record-number
+     *
+     * @return current line number
+     */
+    public int getLineNumber() {
+        return in.getLineNumber();
     }
-    return out;
-  }
-  
-  // ======================================================
-  //  strategies
-  // ======================================================
-  
-  /**
-   * Obtain the specified CSV Strategy.  This should not be modified.
-   * 
-   * @return strategy currently being used
-   */
-  public CSVStrategy getStrategy() {
-    return this.strategy;
-  }
-  
-  // ======================================================
-  //  Character class checker
-  // ======================================================
-  
-  /**
-   * @return true if the given char is a whitespace character
-   */
-  private boolean isWhitespace(int c) {
-    return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
-  }
-  
-  /**
-   * Greedy - accepts \n, \r and \r\n 
-   * This checker consumes silently the second control-character...
-   * 
-   * @return true if the given character is a line-terminator
-   */
-  private boolean isEndOfLine(int c) throws IOException {
-    // check if we have \r\n...
-    if (c == '\r') {
-      if (in.lookAhead() == '\n') {
-        // note: does not change c outside of this method !!
+
+    // ======================================================
+    //  the lexer(s)
+    // ======================================================
+
+    /**
+     * Convenience method for <code>nextToken(null)</code>.
+     */
+    protected Token nextToken() throws IOException {
+        return nextToken(new Token());
+    }
+
+    /**
+     * Returns the next token.
+     * <p/>
+     * A token corresponds to a term, a record change or an
+     * end-of-file indicator.
+     *
+     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
+     *            Token.
+     * @return the next token found
+     * @throws IOException on stream access error
+     */
+    protected Token nextToken(Token tkn) throws IOException {
+        wsBuf.clear(); // reuse
+
+        // get the last read char (required for empty line detection)
+        int lastChar = in.readAgain();
+
+        //  read the next char and set eol
+        /* note: unfortunately isEndOfLine may consumes a character silently.
+        *       this has no effect outside of the method. so a simple workaround
+        *       is to call 'readAgain' on the stream...
+        *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+        */
+        int c = in.read();
+        boolean eol = isEndOfLine(c);
+        c = in.readAgain();
+
+        //  empty line detection: eol AND (last char was EOL or beginning)
+        while (strategy.getIgnoreEmptyLines() && eol
+                && (lastChar == '\n'
+                || lastChar == '\r'
+                || lastChar == ExtendedBufferedReader.UNDEFINED)
+                && !isEndOfFile(lastChar)) {
+            // go on char ahead ...
+            lastChar = c;
+            c = in.read();
+            eol = isEndOfLine(c);
+            c = in.readAgain();
+            // reached end of file without any content (empty line at the end)
+            if (isEndOfFile(c)) {
+                tkn.type = TT_EOF;
+                return tkn;
+            }
+        }
+
+        // did we reach eof during the last iteration already ? TT_EOF
+        if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
+            tkn.type = TT_EOF;
+            return tkn;
+        }
+
+        //  important: make sure a new char gets consumed in each iteration
+        while (!tkn.isReady && tkn.type != TT_EOF) {
+            // ignore whitespaces at beginning of a token
+            while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
+                wsBuf.append((char) c);
+                c = in.read();
+                eol = isEndOfLine(c);
+            }
+            // ok, start of token reached: comment, encapsulated, or token
+            if (c == strategy.getCommentStart()) {
+                // ignore everything till end of line and continue (incr linecount)
+                in.readLine();
+                tkn = nextToken(tkn.reset());
+            } else if (c == strategy.getDelimiter()) {
+                // empty token return TT_TOKEN("""")
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+            } else if (eol) {
+                // empty token return TT_EORECORD("""")
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+            } else if (c == strategy.getEncapsulator()) {
+                // consume encapsulated token
+                encapsulatedTokenLexer(tkn, c);
+            } else if (isEndOfFile(c)) {
+                // end of file return TT_EOF()
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+            } else {
+                // next token must be a simple token
+                // add removed blanks when not ignoring whitespace chars...
+                if (!strategy.getIgnoreLeadingWhitespaces()) {
+                    tkn.content.append(wsBuf);
+                }
+                simpleTokenLexer(tkn, c);
+            }
+        }
+        return tkn;
+    }
+
+    /**
+     * A simple token lexer
+     * <p/>
+     * Simple token are tokens which are not surrounded by encapsulators.
+     * A simple token might contain escaped delimiters (as \, or \;). The
+     * token is finished when one of the following conditions become true:
+     * <ul>
+     * <li>end of line has been reached (TT_EORECORD)</li>
+     * <li>end of stream has been reached (TT_EOF)</li>
+     * <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
+     * </ul>
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return the filled token
+     * @throws IOException on stream access error
+     */
+    private Token simpleTokenLexer(Token tkn, int c) throws IOException {
+        for (; ;) {
+            if (isEndOfLine(c)) {
+                // end of record
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+                break;
+            } else if (isEndOfFile(c)) {
+                // end of file
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+                break;
+            } else if (c == strategy.getDelimiter()) {
+                // end of token
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+                break;
+            } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                // interpret unicode escaped chars (like \u0070 -> p)
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else {
+                tkn.content.append((char) c);
+            }
+
+            c = in.read();
+        }
+
+        if (strategy.getIgnoreTrailingWhitespaces()) {
+            tkn.content.trimTrailingWhitespace();
+        }
+
+        return tkn;
+    }
+
+
+    /**
+     * An encapsulated token lexer
+     * <p/>
+     * Encapsulated tokens are surrounded by the given encapsulating-string.
+     * The encapsulator itself might be included in the token using a
+     * doubling syntax (as """", '') or using escaping (as in \"", \').
+     * Whitespaces before and after an encapsulated token are ignored.
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return a valid token object
+     * @throws IOException on invalid state
+     */
+    private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
+        // save current line
+        int startLineNumber = getLineNumber();
+        // ignore the given delimiter
+        // assert c == delimiter;
+        for (; ;) {
+            c = in.read();
+
+            if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else if (c == strategy.getEncapsulator()) {
+                if (in.lookAhead() == strategy.getEncapsulator()) {
+                    // double or escaped encapsulator -> add single encapsulator to token
+                    c = in.read();
+                    tkn.content.append((char) c);
+                } else {
+                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter
+                    for (; ;) {
+                        c = in.read();
+                        if (c == strategy.getDelimiter()) {
+                            tkn.type = TT_TOKEN;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfFile(c)) {
+                            tkn.type = TT_EOF;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfLine(c)) {
+                            // ok eo token reached
+                            tkn.type = TT_EORECORD;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (!isWhitespace(c)) {
+                            // error invalid char between token and next delimiter
+                            throw new IOException(
+                                    ""(line "" + getLineNumber()
+                                            + "") invalid char between encapsulated token end delimiter""
+                            );
+                        }
+                    }
+                }
+            } else if (isEndOfFile(c)) {
+                // error condition (end of file before end of token)
+                throw new IOException(
+                        ""(startline "" + startLineNumber + "")""
+                                + ""eof reached before encapsulated token finished""
+                );
+            } else {
+                // consume character
+                tkn.content.append((char) c);
+            }
+        }
+    }
+
+
+    /**
+     * Decodes Unicode escapes.
+     * <p/>
+     * Interpretation of ""\\uXXXX"" escape sequences
+     * where XXXX is a hex-number.
+     *
+     * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
+     * @return the decoded character
+     * @throws IOException on wrong unicode escape sequence or read error
+     */
+    protected int unicodeEscapeLexer(int c) throws IOException {
+        int ret = 0;
+        // ignore 'u' (assume c==\ now) and read 4 hex digits
         c = in.read();
-      }
+        code.clear();
+        try {
+            for (int i = 0; i < 4; i++) {
+                c = in.read();
+                if (isEndOfFile(c) || isEndOfLine(c)) {
+                    throw new NumberFormatException(""number too short"");
+                }
+                code.append((char) c);
+            }
+            ret = Integer.parseInt(code.toString(), 16);
+        } catch (NumberFormatException e) {
+            throw new IOException(
+                    ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '""
+                            + code.toString() + ""'"" + e.toString());
+        }
+        return ret;
     }
-    return (c == '\n' || c == '\r');
-  }
-  
-  /**
-   * @return true if the given character indicates end of file
-   */
-  private boolean isEndOfFile(int c) {
-    return c == ExtendedBufferedReader.END_OF_STREAM;
-  }
+
+    private int readEscape(int c) throws IOException {
+        // assume c is the escape char (normally a backslash)
+        c = in.read();
+        int out;
+        switch (c) {
+            case 'r':
+                out = '\r';
+                break;
+            case 'n':
+                out = '\n';
+                break;
+            case 't':
+                out = '\t';
+                break;
+            case 'b':
+                out = '\b';
+                break;
+            case 'f':
+                out = '\f';
+                break;
+            default:
+                out = c;
+        }
+        return out;
+    }
+
+    // ======================================================
+    //  strategies
+    // ======================================================
+
+    /**
+     * Obtain the specified CSV Strategy.  This should not be modified.
+     *
+     * @return strategy currently being used
+     */
+    public CSVStrategy getStrategy() {
+        return this.strategy;
+    }
+
+    // ======================================================
+    //  Character class checker
+    // ======================================================
+
+    /**
+     * @return true if the given char is a whitespace character
+     */
+    private boolean isWhitespace(int c) {
+        return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
+    }
+
+    /**
+     * Greedy - accepts \n, \r and \r\n
+     * This checker consumes silently the second control-character...
+     *
+     * @return true if the given character is a line-terminator
+     */
+    private boolean isEndOfLine(int c) throws IOException {
+        // check if we have \r\n...
+        if (c == '\r') {
+            if (in.lookAhead() == '\n') {
+                // note: does not change c outside of this method !!
+                c = in.read();
+            }
+        }
+        return (c == '\n' || c == '\r');
+    }
+
+    /**
+     * @return true if the given character indicates end of file
+     */
+    private boolean isEndOfFile(int c) {
+        return c == ExtendedBufferedReader.END_OF_STREAM;
+    }
 }
",,25502
5813,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/writer/CSVConfigGuesser.java,366598c77c097855b4b2e790ab6c4353031747e9,1138750608,105,1166ca605bcc035654771f1ddc1092d86f2ec1e8,1296549960,112,1c642fc7ecea497c92b961614ebba569ac151aa8,1168098040,-1,1168098040/1138750608,"        config = null;","-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.commons.csv.writer;
-
-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-
-/**
- * Tries to guess a config based on an InputStream.
- *
- * @author Martin van den Bemt
- * @version $Id: $
- */
-public class CSVConfigGuesser {
-
-    /** The stream to read */
-    private InputStream in;
-    /** 
-     * if the file has a field header (need this info, to be able to guess better)
-     * Defaults to false
-     */
-    private boolean hasFieldHeader = false;
-    /** The found config */
-    protected CSVConfig config;
-    
-    /**
-     * 
-     */
-    public CSVConfigGuesser() {
-        this.config = new CSVConfig();
-    }
-    
-    /**
-     * @param in the inputstream to guess from
-     */
-    public CSVConfigGuesser(InputStream in) {
-        this();
-        setInputStream(in);
-    }
-    
-    public void setInputStream(InputStream in) {
-        this.in = in;
-    }
-    
-    /**
-     * Allow override.
-     * @return the inputstream that was set.
-     */
-    protected InputStream getInputStream() {
-        return in;
-    }
-    
-    /**
-     * Guess the config based on the first 10 (or less when less available) 
-     * records of a CSV file.
-     * 
-     * @return the guessed config.
-     */
-    public CSVConfig guess() {
-        try {
-            // tralalal
-            BufferedReader bIn = new BufferedReader(new InputStreamReader((getInputStream())));
-            String[] lines = new String[10];
-            String line = null;
-            int counter = 0;
-            while ( (line = bIn.readLine()) != null || counter > 10) {
-                lines[counter] = line;
-                counter++;
-            }
-            if (counter < 10) {
-                // remove nulls from the array, so we can skip the null checking.
-                String[] newLines = new String[counter];
-                System.arraycopy(lines, 0, newLines, 0, counter);
-                lines = newLines;
-            }
-            analyseLines(lines);
-        } catch(Exception e) {
-            e.printStackTrace();
-        } finally {
-            if (in != null) {
-                try {
-                    in.close();
-                } catch(Exception e) {
-                    // ignore exception.
-                }
-            }
-        }
-        CSVConfig conf = config;
-        // cleanup the config.
-        config = null;
-        return conf;
-    }
-    
-    protected void analyseLines(String[] lines) {
-        guessFixedWidth(lines);
-        guessFieldSeperator(lines);
-    }
-    
-    /**
-     * Guess if this file is fixedwidth.
-     * Just basing the fact on all lines being of the same length
-     * @param lines
-     */
-    protected void guessFixedWidth(String[] lines) {
-        int lastLength = 0;
-        // assume fixedlength.
-        config.setFixedWidth(true);
-        for (int i = 0; i < lines.length; i++) {
-            if (i == 0) {
-                lastLength = lines[i].length();
-            } else {
-                if (lastLength != lines[i].length()) {
-                    config.setFixedWidth(false);
-                }
-            }
-        }
-    }
-        
-
-    protected void guessFieldSeperator(String[] lines) {
-        if (config.isFixedWidth()) {
-            guessFixedWidthSeperator(lines);
-            return;
-        }
-        for (int i = 0; i < lines.length; i++) {
-        }
-    }
-    
-    protected void guessFixedWidthSeperator(String[] lines) {
-        // keep track of the fieldlength
-        int previousMatch = -1;
-        for (int i = 0; i < lines[0].length(); i++) {
-            char last = ' ';
-            boolean charMatches = true;
-            for (int j = 0; j < lines.length; j++) {
-                if (j == 0) {
-                    last = lines[j].charAt(i);
-                }
-                if (last != lines[j].charAt(i)) {
-                    charMatches = false;
-                    break;
-                } 
-            }
-            if (charMatches) {
-                if (previousMatch == -1) {
-                    previousMatch = 0;
-                }
-                CSVField field = new CSVField();
-                field.setName(""field""+config.getFields().length+1);
-                field.setSize((i-previousMatch));
-                config.addField(field);
-            }
-        }
-    }
-    /**
-     * 
-     * @return if the field uses a field header. Defaults to false.
-     */
-    public boolean hasFieldHeader() {
-        return hasFieldHeader;
-    }
-
-    /**
-     * Specify if the CSV file has a field header
-     * @param hasFieldHeader true or false
-     */
-    public void setHasFieldHeader(boolean hasFieldHeader) {
-        this.hasFieldHeader = hasFieldHeader;
-    }
-    
- 
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.commons.csv.writer;
+
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+/**
+ * Tries to guess a config based on an InputStream.
+ *
+ * @author Martin van den Bemt
+ * @version $Id: $
+ */
+public class CSVConfigGuesser {
+
+    /** The stream to read */
+    private InputStream in;
+    /** 
+     * if the file has a field header (need this info, to be able to guess better)
+     * Defaults to false
+     */
+    private boolean hasFieldHeader = false;
+    /** The found config */
+    protected CSVConfig config;
+    
+    /**
+     * 
+     */
+    public CSVConfigGuesser() {
+        this.config = new CSVConfig();
+    }
+    
+    /**
+     * @param in the inputstream to guess from
+     */
+    public CSVConfigGuesser(InputStream in) {
+        this();
+        setInputStream(in);
+    }
+    
+    public void setInputStream(InputStream in) {
+        this.in = in;
+    }
+    
+    /**
+     * Allow override.
+     * @return the inputstream that was set.
+     */
+    protected InputStream getInputStream() {
+        return in;
+    }
+    
+    /**
+     * Guess the config based on the first 10 (or less when less available) 
+     * records of a CSV file.
+     * 
+     * @return the guessed config.
+     */
+    public CSVConfig guess() {
+        try {
+            // tralalal
+            BufferedReader bIn = new BufferedReader(new InputStreamReader((getInputStream())));
+            String[] lines = new String[10];
+            String line = null;
+            int counter = 0;
+            while ( (line = bIn.readLine()) != null || counter > 10) {
+                lines[counter] = line;
+                counter++;
+            }
+            if (counter < 10) {
+                // remove nulls from the array, so we can skip the null checking.
+                String[] newLines = new String[counter];
+                System.arraycopy(lines, 0, newLines, 0, counter);
+                lines = newLines;
+            }
+            analyseLines(lines);
+        } catch(Exception e) {
+            e.printStackTrace();
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch(Exception e) {
+                    // ignore exception.
+                }
+            }
+        }
+        CSVConfig conf = config;
+        // cleanup the config.
+        config = null;
+        return conf;
+    }
+    
+    protected void analyseLines(String[] lines) {
+        guessFixedWidth(lines);
+        guessFieldSeperator(lines);
+    }
+    
+    /**
+     * Guess if this file is fixedwidth.
+     * Just basing the fact on all lines being of the same length
+     * @param lines
+     */
+    protected void guessFixedWidth(String[] lines) {
+        int lastLength = 0;
+        // assume fixedlength.
+        config.setFixedWidth(true);
+        for (int i = 0; i < lines.length; i++) {
+            if (i == 0) {
+                lastLength = lines[i].length();
+            } else {
+                if (lastLength != lines[i].length()) {
+                    config.setFixedWidth(false);
+                }
+            }
+        }
+    }
+        
+
+    protected void guessFieldSeperator(String[] lines) {
+        if (config.isFixedWidth()) {
+            guessFixedWidthSeperator(lines);
+            return;
+        }
+        for (int i = 0; i < lines.length; i++) {
+        }
+    }
+    
+    protected void guessFixedWidthSeperator(String[] lines) {
+        // keep track of the fieldlength
+        int previousMatch = -1;
+        for (int i = 0; i < lines[0].length(); i++) {
+            char last = ' ';
+            boolean charMatches = true;
+            for (int j = 0; j < lines.length; j++) {
+                if (j == 0) {
+                    last = lines[j].charAt(i);
+                }
+                if (last != lines[j].charAt(i)) {
+                    charMatches = false;
+                    break;
+                } 
+            }
+            if (charMatches) {
+                if (previousMatch == -1) {
+                    previousMatch = 0;
+                }
+                CSVField field = new CSVField();
+                field.setName(""field""+config.getFields().length+1);
+                field.setSize((i-previousMatch));
+                config.addField(field);
+            }
+        }
+    }
+    /**
+     * 
+     * @return if the field uses a field header. Defaults to false.
+     */
+    public boolean hasFieldHeader() {
+        return hasFieldHeader;
+    }
+
+    /**
+     * Specify if the CSV file has a field header
+     * @param hasFieldHeader true or false
+     */
+    public void setHasFieldHeader(boolean hasFieldHeader) {
+        this.hasFieldHeader = hasFieldHeader;
+    }
+    
+ 
+}
",,25502
5814,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/CSVParser.java,f047581f9526aad1c9c9e624710a4e860f88ecaa,1141621881,292,ce34196827e6ac834b4c566e1e6fbe863c8e8d1c,1154415008,229,1166ca605bcc035654771f1ddc1092d86f2ec1e8,1296549960,-1,1296549960/1141621881,"          ret = null;","  *
  * Because CSV appears in many different dialects, the parser supports many
  * configuration settings by allowing the specification of a {@link CSVStrategy}.
- * 
+ *
  * <p>Parsing of a csv-string having tabs as separators,
  * '""' as an optional value encapsulator, and comments starting with '#':</p>
  * <pre>
- *  String[][] data = 
+ *  String[][] data =
  *   (new CSVParser(new StringReader(""a\tb\nc\td""), new CSVStrategy('\t','""','#'))).getAllValues();
  * </pre>
- * 
+ *
  * <p>Parsing of a csv-string in Excel CSV format</p>
  * <pre>
  *  String[][] data =
  *   (new CSVParser(new StringReader(""a;b\nc;d""), CSVStrategy.EXCEL_STRATEGY)).getAllValues();
  * </pre>
- * 
+ *
  * <p>
  * Internal parser state is completely covered by the strategy
  * and the reader-state.</p>
- * 
- * <p>see <a href=""package-summary.html"">package documentation</a> 
+ *
+ * <p>see <a href=""package-summary.html"">package documentation</a>
  * for more details</p>
  */
 public class CSVParser {
 
-  /** length of the initial token (content-)buffer */
-  private static final int INITIAL_TOKEN_LENGTH = 50;
-  
-  // the token types
-  /** Token has no valid content, i.e. is in its initialized state. */
-  protected static final int TT_INVALID = -1;
-  /** Token with content, at beginning or in the middle of a line. */
-  protected static final int TT_TOKEN = 0;
-  /** Token (which can have content) when end of file is reached. */
-  protected static final int TT_EOF = 1;
-  /** Token with content when end of a line is reached. */
-  protected static final int TT_EORECORD = 2;
+    /**
+     * length of the initial token (content-)buffer
+     */
+    private static final int INITIAL_TOKEN_LENGTH = 50;
 
-  /** Immutable empty String array. */
-  private static final String[] EMPTY_STRING_ARRAY = new String[0];
-   
-  // the input stream
-  private final ExtendedBufferedReader in;
+    // the token types
+    /**
+     * Token has no valid content, i.e. is in its initialized state.
+     */
+    protected static final int TT_INVALID = -1;
+    /**
+     * Token with content, at beginning or in the middle of a line.
+     */
+    protected static final int TT_TOKEN = 0;
+    /**
+     * Token (which can have content) when end of file is reached.
+     */
+    protected static final int TT_EOF = 1;
+    /**
+     * Token with content when end of a line is reached.
+     */
+    protected static final int TT_EORECORD = 2;
 
-  private final CSVStrategy strategy;
-  
-  // the following objects are shared to reduce garbage 
-  /** A record buffer for getLine(). Grows as necessary and is reused. */
-  private final ArrayList record = new ArrayList();
-  private final Token reusableToken = new Token();
-  private final CharBuffer wsBuf = new CharBuffer();
-  private final CharBuffer code = new CharBuffer(4);
+    /**
+     * Immutable empty String array.
+     */
+    private static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  
-  /**
-   * Token is an internal token representation.
-   * 
-   * It is used as contract between the lexer and the parser. 
-   */
-  static class Token {
-    /** Token type, see TT_xxx constants. */
-    int type = TT_INVALID;
-    /** The content buffer. */
-    CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
-    /** Token ready flag: indicates a valid token with content (ready for the parser). */
-    boolean isReady;
-    
-    Token reset() {
-        content.clear();
-        type = TT_INVALID;
-        isReady = false;
-        return this;
-    }
-  }
-  
-  // ======================================================
-  //  the constructor
-  // ======================================================
-  
-  /**
-   * Default strategy for the parser follows the default {@link CSVStrategy}.
-   * 
-   * @param input an InputStream containing ""csv-formatted"" stream
-   * @deprecated use {@link #CSVParser(Reader)}.
-   */
-  public CSVParser(InputStream input) {
-    this(new InputStreamReader(input));
-  }
-  
-  /**
-   * CSV parser using the default {@link CSVStrategy}.
-   * 
-   * @param input a Reader containing ""csv-formatted"" input
-   */
-  public CSVParser(Reader input) {
-    this(input, (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone());
-  }
-  
-  /**
-   * Customized value delimiter parser.
-   * 
-   * The parser follows the default {@link CSVStrategy}
-   * except for the delimiter setting.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter) {
-    this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
-  }
-  
-  /**
-   * Customized csv parser.
-   * 
-   * The parser parses according to the given CSV dialect settings.
-   * Leading whitespaces are truncated, unicode escapes are
-   * not interpreted and empty lines are ignored.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @param encapsulator a Char used as value encapsulation marker
-   * @param commentStart a Char used for comment identification
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
-    this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
-  }
+    // the input stream
+    private final ExtendedBufferedReader in;
 
-  /**
-   * Customized CSV parser using the given {@link CSVStrategy}
-   *
-   * @param input a Reader containing ""csv-formatted"" input
-   * @param strategy the CSVStrategy used for CSV parsing
-   */
-  public CSVParser(Reader input, CSVStrategy strategy) {
-    this.in = new ExtendedBufferedReader(input);
-    this.strategy = strategy;
-  }
-  
-  // ======================================================
-  //  the parser
-  // ======================================================
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the content as an array of records
-   * (whereas records are arrays of single values).
-   * <p>
-   * The returned content starts at the current parse-position in
-   * the stream.
-   * 
-   * @return matrix of records x values ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[][] getAllValues() throws IOException {
-    ArrayList records = new ArrayList();
-    String[] values;
-    String[][] ret = null;
-    while ((values = getLine()) != null)  {
-      records.add(values);
+    private final CSVStrategy strategy;
+
+    // the following objects are shared to reduce garbage
+    /**
+     * A record buffer for getLine(). Grows as necessary and is reused.
+     */
+    private final ArrayList record = new ArrayList();
+    private final Token reusableToken = new Token();
+    private final CharBuffer wsBuf = new CharBuffer();
+    private final CharBuffer code = new CharBuffer(4);
+
+
+    /**
+     * Token is an internal token representation.
+     * <p/>
+     * It is used as contract between the lexer and the parser.
+     */
+    static class Token {
+        /**
+         * Token type, see TT_xxx constants.
+         */
+        int type = TT_INVALID;
+        /**
+         * The content buffer.
+         */
+        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
+        /**
+         * Token ready flag: indicates a valid token with content (ready for the parser).
+         */
+        boolean isReady;
+
+        Token reset() {
+            content.clear();
+            type = TT_INVALID;
+            isReady = false;
+            return this;
+        }
     }
-    if (records.size() > 0) {
-      ret = new String[records.size()][];
-      records.toArray(ret);
+
+    // ======================================================
+    //  the constructor
+    // ======================================================
+
+    /**
+     * Default strategy for the parser follows the default {@link CSVStrategy}.
+     *
+     * @param input an InputStream containing ""csv-formatted"" stream
+     * @deprecated use {@link #CSVParser(Reader)}.
+     */
+    public CSVParser(InputStream input) {
+        this(new InputStreamReader(input));
     }
-    return ret;
-  }
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the next csv-value as string.
-   * 
-   * @return next value in the input stream ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String nextValue() throws IOException {
-    Token tkn = nextToken();
-    String ret = null;
-    switch (tkn.type) {
-      case TT_TOKEN:
-      case TT_EORECORD: 
-        ret = tkn.content.toString();
-        break;
-      case TT_EOF:
-        ret = null;
-        break;
-      case TT_INVALID:
-      default:
-        // error no token available (or error)
-        throw new IOException(
-          ""(line "" + getLineNumber() 
-          + "") invalid parse sequence"");
-        // unreachable: break;
+
+    /**
+     * CSV parser using the default {@link CSVStrategy}.
+     *
+     * @param input a Reader containing ""csv-formatted"" input
+     */
+    public CSVParser(Reader input) {
+        this(input, (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone());
     }
-    return ret;
-  }
-  
-  /**
-   * Parses from the current point in the stream til
-   * the end of the current line.
-   * 
-   * @return array of values til end of line 
-   *        ('null' when end of file has been reached)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[] getLine() throws IOException {
-    String[] ret = EMPTY_STRING_ARRAY;
-    record.clear();
-    while (true) {
-        reusableToken.reset();
-        nextToken(reusableToken);
-        switch (reusableToken.type) {
+
+    /**
+     * Customized value delimiter parser.
+     * <p/>
+     * The parser follows the default {@link CSVStrategy}
+     * except for the delimiter setting.
+     *
+     * @param input     a Reader based on ""csv-formatted"" input
+     * @param delimiter a Char used for value separation
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter) {
+        this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
+    }
+
+    /**
+     * Customized csv parser.
+     * <p/>
+     * The parser parses according to the given CSV dialect settings.
+     * Leading whitespaces are truncated, unicode escapes are
+     * not interpreted and empty lines are ignored.
+     *
+     * @param input        a Reader based on ""csv-formatted"" input
+     * @param delimiter    a Char used for value separation
+     * @param encapsulator a Char used as value encapsulation marker
+     * @param commentStart a Char used for comment identification
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
+        this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
+    }
+
+    /**
+     * Customized CSV parser using the given {@link CSVStrategy}
+     *
+     * @param input    a Reader containing ""csv-formatted"" input
+     * @param strategy the CSVStrategy used for CSV parsing
+     */
+    public CSVParser(Reader input, CSVStrategy strategy) {
+        this.in = new ExtendedBufferedReader(input);
+        this.strategy = strategy;
+    }
+
+    // ======================================================
+    //  the parser
+    // ======================================================
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the content as an array of records
+     * (whereas records are arrays of single values).
+     * <p/>
+     * The returned content starts at the current parse-position in
+     * the stream.
+     *
+     * @return matrix of records x values ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String[][] getAllValues() throws IOException {
+        ArrayList records = new ArrayList();
+        String[] values;
+        String[][] ret = null;
+        while ((values = getLine()) != null) {
+            records.add(values);
+        }
+        if (records.size() > 0) {
+            ret = new String[records.size()][];
+            records.toArray(ret);
+        }
+        return ret;
+    }
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the next csv-value as string.
+     *
+     * @return next value in the input stream ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String nextValue() throws IOException {
+        Token tkn = nextToken();
+        String ret = null;
+        switch (tkn.type) {
             case TT_TOKEN:
-                record.add(reusableToken.content.toString());
-                break;
             case TT_EORECORD:
-                record.add(reusableToken.content.toString());
+                ret = tkn.content.toString();
                 break;
             case TT_EOF:
-                if (reusableToken.isReady) {
-                    record.add(reusableToken.content.toString());
-                } else {
-                    ret = null;
-                }
+                ret = null;
                 break;
             case TT_INVALID:
             default:
-                // error: throw IOException
-                throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
-            // unreachable: break;
+                // error no token available (or error)
+                throw new IOException(
+                        ""(line "" + getLineNumber()
+                                + "") invalid parse sequence"");
+                // unreachable: break;
         }
-        if (reusableToken.type != TT_TOKEN) {
-            break;
-        }
+        return ret;
     }
-    if (!record.isEmpty()) {
-      ret = (String[]) record.toArray(new String[record.size()]);
-    }
-    return ret;
-  }
-  
-  /**
-   * Returns the current line number in the input stream.
-   * 
-   * ATTENTION: in case your csv has multiline-values the returned
-   *            number does not correspond to the record-number
-   * 
-   * @return  current line number
-   */
-  public int getLineNumber() {
-    return in.getLineNumber();  
-  }
-  
-  // ======================================================
-  //  the lexer(s)
-  // ======================================================
- 
-  /**
-   * Convenience method for <code>nextToken(null)</code>.
-   */
-  protected Token nextToken() throws IOException {
-      return nextToken(new Token());
-  }
-  
- /**
-   * Returns the next token.
-   * 
-   * A token corresponds to a term, a record change or an
-   * end-of-file indicator.
-   * 
-   * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
-   * Token.
-   * @return the next token found
-   * @throws IOException on stream access error
-   */
-  protected Token nextToken(Token tkn) throws IOException {
-    wsBuf.clear(); // reuse
-    
-    // get the last read char (required for empty line detection)
-    int lastChar = in.readAgain();
-    
-    //  read the next char and set eol
-    /* note: unfortunately isEndOfLine may consumes a character silently.
-     *       this has no effect outside of the method. so a simple workaround
-     *       is to call 'readAgain' on the stream...
-     *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+
+    /**
+     * Parses from the current point in the stream til
+     * the end of the current line.
+     *
+     * @return array of values til end of line
+     *         ('null' when end of file has been reached)
+     * @throws IOException on parse error or input read-failure
      */
-    int c = in.read();
-    boolean eol = isEndOfLine(c);
-    c = in.readAgain();
-     
-    //  empty line detection: eol AND (last char was EOL or beginning)
-    while (strategy.getIgnoreEmptyLines() && eol 
-      && (lastChar == '\n' 
-      || lastChar == '\r' 
-      || lastChar == ExtendedBufferedReader.UNDEFINED) 
-      && !isEndOfFile(lastChar)) {
-      // go on char ahead ...
-      lastChar = c;
-      c = in.read();
-      eol = isEndOfLine(c);
-      c = in.readAgain();
-      // reached end of file without any content (empty line at the end)
-      if (isEndOfFile(c)) {
-        tkn.type = TT_EOF;
-        return tkn;
-      }
-    }
-
-    // did we reach eof during the last iteration already ? TT_EOF
-    if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
-      tkn.type = TT_EOF;
-      return tkn;
-    } 
-    
-    //  important: make sure a new char gets consumed in each iteration
-    while (!tkn.isReady && tkn.type != TT_EOF) {
-      // ignore whitespaces at beginning of a token
-      while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
-        wsBuf.append((char) c);
-        c = in.read();
-        eol = isEndOfLine(c);
-      }
-      // ok, start of token reached: comment, encapsulated, or token
-      if (c == strategy.getCommentStart()) {
-        // ignore everything till end of line and continue (incr linecount)
-        in.readLine();
-        tkn = nextToken(tkn.reset());
-      } else if (c == strategy.getDelimiter()) {
-        // empty token return TT_TOKEN("""")
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-      } else if (eol) {
-        // empty token return TT_EORECORD("""")
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-      } else if (c == strategy.getEncapsulator()) {
-        // consume encapsulated token
-        encapsulatedTokenLexer(tkn, c);
-      } else if (isEndOfFile(c)) {
-        // end of file return TT_EOF()
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-      } else {
-        // next token must be a simple token
-        // add removed blanks when not ignoring whitespace chars...
-        if (!strategy.getIgnoreLeadingWhitespaces()) {
-          tkn.content.append(wsBuf);
-        }
-        simpleTokenLexer(tkn, c);
-      }
-    }
-    return tkn;  
-  }
-  
-  /**
-   * A simple token lexer
-   * 
-   * Simple token are tokens which are not surrounded by encapsulators.
-   * A simple token might contain escaped delimiters (as \, or \;). The
-   * token is finished when one of the following conditions become true:
-   * <ul>
-   *   <li>end of line has been reached (TT_EORECORD)</li>
-   *   <li>end of stream has been reached (TT_EOF)</li>
-   *   <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
-   * </ul>
-   *  
-   * @param tkn  the current token
-   * @param c    the current character
-   * @return the filled token
-   * 
-   * @throws IOException on stream access error
-   */
-  private Token simpleTokenLexer(Token tkn, int c) throws IOException {
-    for (;;) {
-      if (isEndOfLine(c)) {
-        // end of record
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-        break;
-      } else if (isEndOfFile(c)) {
-        // end of file
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-        break;
-      } else if (c == strategy.getDelimiter()) {
-        // end of token
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-        break;
-      } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
-        // interpret unicode escaped chars (like \u0070 -> p)
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else {
-        tkn.content.append((char) c);
-      }
-      
-      c = in.read();
-    }
-
-    if (strategy.getIgnoreTrailingWhitespaces()) {
-      tkn.content.trimTrailingWhitespace();
-    }
-
-    return tkn;
-  }
-  
-  
-  /**
-   * An encapsulated token lexer
-   * 
-   * Encapsulated tokens are surrounded by the given encapsulating-string.
-   * The encapsulator itself might be included in the token using a
-   * doubling syntax (as """", '') or using escaping (as in \"", \').
-   * Whitespaces before and after an encapsulated token are ignored.
-   * 
-   * @param tkn    the current token
-   * @param c      the current character
-   * @return a valid token object
-   * @throws IOException on invalid state
-   */
-  private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
-    // save current line
-    int startLineNumber = getLineNumber();
-    // ignore the given delimiter
-    // assert c == delimiter;
-    for (;;) {
-      c = in.read();
-
-      if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead()=='u') {
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else if (c == strategy.getEncapsulator()) {
-        if (in.lookAhead() == strategy.getEncapsulator()) {
-          // double or escaped encapsulator -> add single encapsulator to token
-          c = in.read();
-          tkn.content.append((char) c);
-        } else {
-          // token finish mark (encapsulator) reached: ignore whitespace till delimiter
-          for (;;) {
-            c = in.read();
-            if (c == strategy.getDelimiter()) {
-              tkn.type = TT_TOKEN;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfFile(c)) {
-              tkn.type = TT_EOF;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfLine(c)) {
-              // ok eo token reached
-              tkn.type = TT_EORECORD;
-              tkn.isReady = true;
-              return tkn;
-            } else if (!isWhitespace(c)) {
-              // error invalid char between token and next delimiter
-              throw new IOException(
-                      ""(line "" + getLineNumber()
-                              + "") invalid char between encapsulated token end delimiter""
-              );
+    public String[] getLine() throws IOException {
+        String[] ret = EMPTY_STRING_ARRAY;
+        record.clear();
+        while (true) {
+            reusableToken.reset();
+            nextToken(reusableToken);
+            switch (reusableToken.type) {
+                case TT_TOKEN:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EORECORD:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EOF:
+                    if (reusableToken.isReady) {
+                        record.add(reusableToken.content.toString());
+                    } else {
+                        ret = null;
+                    }
+                    break;
+                case TT_INVALID:
+                default:
+                    // error: throw IOException
+                    throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
+                    // unreachable: break;
             }
-          }
+            if (reusableToken.type != TT_TOKEN) {
+                break;
+            }
         }
-      } else if (isEndOfFile(c)) {
-        // error condition (end of file before end of token)
-        throw new IOException(
-                ""(startline "" + startLineNumber + "")""
-                        + ""eof reached before encapsulated token finished""
-        );
-      } else {
-        // consume character
-        tkn.content.append((char) c);
-      }
-    }
-  }
-  
-  
-  /**
-   * Decodes Unicode escapes.
-   * 
-   * Interpretation of ""\\uXXXX"" escape sequences
-   * where XXXX is a hex-number.
-   * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
-   * @return the decoded character
-   * @throws IOException on wrong unicode escape sequence or read error
-   */
-  protected int unicodeEscapeLexer(int c) throws IOException {
-    int ret = 0;
-    // ignore 'u' (assume c==\ now) and read 4 hex digits
-    c = in.read();
-    code.clear();
-    try {
-      for (int i = 0; i < 4; i++) {
-        c  = in.read();
-        if (isEndOfFile(c) || isEndOfLine(c)) {
-          throw new NumberFormatException(""number too short"");
+        if (!record.isEmpty()) {
+            ret = (String[]) record.toArray(new String[record.size()]);
         }
-        code.append((char) c);
-      }
-      ret = Integer.parseInt(code.toString(), 16);
-    } catch (NumberFormatException e) {
-      throw new IOException(
-        ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '"" 
-        + code.toString() + ""'"" + e.toString());
+        return ret;
     }
-    return ret;
-  }
 
-  private int readEscape(int c) throws IOException {
-    // assume c is the escape char (normally a backslash)
-    c = in.read();
-    int out;
-    switch (c) {
-      case 'r': out='\r'; break;
-      case 'n': out='\n'; break;
-      case 't': out='\t'; break;
-      case 'b': out='\b'; break;
-      case 'f': out='\f'; break;
-      default : out=c;
+    /**
+     * Returns the current line number in the input stream.
+     * <p/>
+     * ATTENTION: in case your csv has multiline-values the returned
+     * number does not correspond to the record-number
+     *
+     * @return current line number
+     */
+    public int getLineNumber() {
+        return in.getLineNumber();
     }
-    return out;
-  }
-  
-  // ======================================================
-  //  strategies
-  // ======================================================
-  
-  /**
-   * Obtain the specified CSV Strategy.  This should not be modified.
-   * 
-   * @return strategy currently being used
-   */
-  public CSVStrategy getStrategy() {
-    return this.strategy;
-  }
-  
-  // ======================================================
-  //  Character class checker
-  // ======================================================
-  
-  /**
-   * @return true if the given char is a whitespace character
-   */
-  private boolean isWhitespace(int c) {
-    return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
-  }
-  
-  /**
-   * Greedy - accepts \n, \r and \r\n 
-   * This checker consumes silently the second control-character...
-   * 
-   * @return true if the given character is a line-terminator
-   */
-  private boolean isEndOfLine(int c) throws IOException {
-    // check if we have \r\n...
-    if (c == '\r') {
-      if (in.lookAhead() == '\n') {
-        // note: does not change c outside of this method !!
+
+    // ======================================================
+    //  the lexer(s)
+    // ======================================================
+
+    /**
+     * Convenience method for <code>nextToken(null)</code>.
+     */
+    protected Token nextToken() throws IOException {
+        return nextToken(new Token());
+    }
+
+    /**
+     * Returns the next token.
+     * <p/>
+     * A token corresponds to a term, a record change or an
+     * end-of-file indicator.
+     *
+     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
+     *            Token.
+     * @return the next token found
+     * @throws IOException on stream access error
+     */
+    protected Token nextToken(Token tkn) throws IOException {
+        wsBuf.clear(); // reuse
+
+        // get the last read char (required for empty line detection)
+        int lastChar = in.readAgain();
+
+        //  read the next char and set eol
+        /* note: unfortunately isEndOfLine may consumes a character silently.
+        *       this has no effect outside of the method. so a simple workaround
+        *       is to call 'readAgain' on the stream...
+        *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+        */
+        int c = in.read();
+        boolean eol = isEndOfLine(c);
+        c = in.readAgain();
+
+        //  empty line detection: eol AND (last char was EOL or beginning)
+        while (strategy.getIgnoreEmptyLines() && eol
+                && (lastChar == '\n'
+                || lastChar == '\r'
+                || lastChar == ExtendedBufferedReader.UNDEFINED)
+                && !isEndOfFile(lastChar)) {
+            // go on char ahead ...
+            lastChar = c;
+            c = in.read();
+            eol = isEndOfLine(c);
+            c = in.readAgain();
+            // reached end of file without any content (empty line at the end)
+            if (isEndOfFile(c)) {
+                tkn.type = TT_EOF;
+                return tkn;
+            }
+        }
+
+        // did we reach eof during the last iteration already ? TT_EOF
+        if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
+            tkn.type = TT_EOF;
+            return tkn;
+        }
+
+        //  important: make sure a new char gets consumed in each iteration
+        while (!tkn.isReady && tkn.type != TT_EOF) {
+            // ignore whitespaces at beginning of a token
+            while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
+                wsBuf.append((char) c);
+                c = in.read();
+                eol = isEndOfLine(c);
+            }
+            // ok, start of token reached: comment, encapsulated, or token
+            if (c == strategy.getCommentStart()) {
+                // ignore everything till end of line and continue (incr linecount)
+                in.readLine();
+                tkn = nextToken(tkn.reset());
+            } else if (c == strategy.getDelimiter()) {
+                // empty token return TT_TOKEN("""")
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+            } else if (eol) {
+                // empty token return TT_EORECORD("""")
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+            } else if (c == strategy.getEncapsulator()) {
+                // consume encapsulated token
+                encapsulatedTokenLexer(tkn, c);
+            } else if (isEndOfFile(c)) {
+                // end of file return TT_EOF()
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+            } else {
+                // next token must be a simple token
+                // add removed blanks when not ignoring whitespace chars...
+                if (!strategy.getIgnoreLeadingWhitespaces()) {
+                    tkn.content.append(wsBuf);
+                }
+                simpleTokenLexer(tkn, c);
+            }
+        }
+        return tkn;
+    }
+
+    /**
+     * A simple token lexer
+     * <p/>
+     * Simple token are tokens which are not surrounded by encapsulators.
+     * A simple token might contain escaped delimiters (as \, or \;). The
+     * token is finished when one of the following conditions become true:
+     * <ul>
+     * <li>end of line has been reached (TT_EORECORD)</li>
+     * <li>end of stream has been reached (TT_EOF)</li>
+     * <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
+     * </ul>
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return the filled token
+     * @throws IOException on stream access error
+     */
+    private Token simpleTokenLexer(Token tkn, int c) throws IOException {
+        for (; ;) {
+            if (isEndOfLine(c)) {
+                // end of record
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+                break;
+            } else if (isEndOfFile(c)) {
+                // end of file
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+                break;
+            } else if (c == strategy.getDelimiter()) {
+                // end of token
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+                break;
+            } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                // interpret unicode escaped chars (like \u0070 -> p)
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else {
+                tkn.content.append((char) c);
+            }
+
+            c = in.read();
+        }
+
+        if (strategy.getIgnoreTrailingWhitespaces()) {
+            tkn.content.trimTrailingWhitespace();
+        }
+
+        return tkn;
+    }
+
+
+    /**
+     * An encapsulated token lexer
+     * <p/>
+     * Encapsulated tokens are surrounded by the given encapsulating-string.
+     * The encapsulator itself might be included in the token using a
+     * doubling syntax (as """", '') or using escaping (as in \"", \').
+     * Whitespaces before and after an encapsulated token are ignored.
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return a valid token object
+     * @throws IOException on invalid state
+     */
+    private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
+        // save current line
+        int startLineNumber = getLineNumber();
+        // ignore the given delimiter
+        // assert c == delimiter;
+        for (; ;) {
+            c = in.read();
+
+            if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else if (c == strategy.getEncapsulator()) {
+                if (in.lookAhead() == strategy.getEncapsulator()) {
+                    // double or escaped encapsulator -> add single encapsulator to token
+                    c = in.read();
+                    tkn.content.append((char) c);
+                } else {
+                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter
+                    for (; ;) {
+                        c = in.read();
+                        if (c == strategy.getDelimiter()) {
+                            tkn.type = TT_TOKEN;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfFile(c)) {
+                            tkn.type = TT_EOF;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfLine(c)) {
+                            // ok eo token reached
+                            tkn.type = TT_EORECORD;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (!isWhitespace(c)) {
+                            // error invalid char between token and next delimiter
+                            throw new IOException(
+                                    ""(line "" + getLineNumber()
+                                            + "") invalid char between encapsulated token end delimiter""
+                            );
+                        }
+                    }
+                }
+            } else if (isEndOfFile(c)) {
+                // error condition (end of file before end of token)
+                throw new IOException(
+                        ""(startline "" + startLineNumber + "")""
+                                + ""eof reached before encapsulated token finished""
+                );
+            } else {
+                // consume character
+                tkn.content.append((char) c);
+            }
+        }
+    }
+
+
+    /**
+     * Decodes Unicode escapes.
+     * <p/>
+     * Interpretation of ""\\uXXXX"" escape sequences
+     * where XXXX is a hex-number.
+     *
+     * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
+     * @return the decoded character
+     * @throws IOException on wrong unicode escape sequence or read error
+     */
+    protected int unicodeEscapeLexer(int c) throws IOException {
+        int ret = 0;
+        // ignore 'u' (assume c==\ now) and read 4 hex digits
         c = in.read();
-      }
+        code.clear();
+        try {
+            for (int i = 0; i < 4; i++) {
+                c = in.read();
+                if (isEndOfFile(c) || isEndOfLine(c)) {
+                    throw new NumberFormatException(""number too short"");
+                }
+                code.append((char) c);
+            }
+            ret = Integer.parseInt(code.toString(), 16);
+        } catch (NumberFormatException e) {
+            throw new IOException(
+                    ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '""
+                            + code.toString() + ""'"" + e.toString());
+        }
+        return ret;
     }
-    return (c == '\n' || c == '\r');
-  }
-  
-  /**
-   * @return true if the given character indicates end of file
-   */
-  private boolean isEndOfFile(int c) {
-    return c == ExtendedBufferedReader.END_OF_STREAM;
-  }
+
+    private int readEscape(int c) throws IOException {
+        // assume c is the escape char (normally a backslash)
+        c = in.read();
+        int out;
+        switch (c) {
+            case 'r':
+                out = '\r';
+                break;
+            case 'n':
+                out = '\n';
+                break;
+            case 't':
+                out = '\t';
+                break;
+            case 'b':
+                out = '\b';
+                break;
+            case 'f':
+                out = '\f';
+                break;
+            default:
+                out = c;
+        }
+        return out;
+    }
+
+    // ======================================================
+    //  strategies
+    // ======================================================
+
+    /**
+     * Obtain the specified CSV Strategy.  This should not be modified.
+     *
+     * @return strategy currently being used
+     */
+    public CSVStrategy getStrategy() {
+        return this.strategy;
+    }
+
+    // ======================================================
+    //  Character class checker
+    // ======================================================
+
+    /**
+     * @return true if the given char is a whitespace character
+     */
+    private boolean isWhitespace(int c) {
+        return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
+    }
+
+    /**
+     * Greedy - accepts \n, \r and \r\n
+     * This checker consumes silently the second control-character...
+     *
+     * @return true if the given character is a line-terminator
+     */
+    private boolean isEndOfLine(int c) throws IOException {
+        // check if we have \r\n...
+        if (c == '\r') {
+            if (in.lookAhead() == '\n') {
+                // note: does not change c outside of this method !!
+                c = in.read();
+            }
+        }
+        return (c == '\n' || c == '\r');
+    }
+
+    /**
+     * @return true if the given character indicates end of file
+     */
+    private boolean isEndOfFile(int c) {
+        return c == ExtendedBufferedReader.END_OF_STREAM;
+    }
 }
",,25502
5815,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/CSVParser.java,d7e94581d784067fccddd34e19ae46aea526f9fa,1155200478,242,c6bdecabd82eebc9efce450aa4057b668984479e,1296470876,252,1166ca605bcc035654771f1ddc1092d86f2ec1e8,1296549960,-1,1296549960/1155200478,"                    ret = null;","  *
  * Because CSV appears in many different dialects, the parser supports many
  * configuration settings by allowing the specification of a {@link CSVStrategy}.
- * 
+ *
  * <p>Parsing of a csv-string having tabs as separators,
  * '""' as an optional value encapsulator, and comments starting with '#':</p>
  * <pre>
- *  String[][] data = 
+ *  String[][] data =
  *   (new CSVParser(new StringReader(""a\tb\nc\td""), new CSVStrategy('\t','""','#'))).getAllValues();
  * </pre>
- * 
+ *
  * <p>Parsing of a csv-string in Excel CSV format</p>
  * <pre>
  *  String[][] data =
  *   (new CSVParser(new StringReader(""a;b\nc;d""), CSVStrategy.EXCEL_STRATEGY)).getAllValues();
  * </pre>
- * 
+ *
  * <p>
  * Internal parser state is completely covered by the strategy
  * and the reader-state.</p>
- * 
- * <p>see <a href=""package-summary.html"">package documentation</a> 
+ *
+ * <p>see <a href=""package-summary.html"">package documentation</a>
  * for more details</p>
  */
 public class CSVParser {
 
-  /** length of the initial token (content-)buffer */
-  private static final int INITIAL_TOKEN_LENGTH = 50;
-  
-  // the token types
-  /** Token has no valid content, i.e. is in its initialized state. */
-  protected static final int TT_INVALID = -1;
-  /** Token with content, at beginning or in the middle of a line. */
-  protected static final int TT_TOKEN = 0;
-  /** Token (which can have content) when end of file is reached. */
-  protected static final int TT_EOF = 1;
-  /** Token with content when end of a line is reached. */
-  protected static final int TT_EORECORD = 2;
+    /**
+     * length of the initial token (content-)buffer
+     */
+    private static final int INITIAL_TOKEN_LENGTH = 50;
 
-  /** Immutable empty String array. */
-  private static final String[] EMPTY_STRING_ARRAY = new String[0];
-   
-  // the input stream
-  private final ExtendedBufferedReader in;
+    // the token types
+    /**
+     * Token has no valid content, i.e. is in its initialized state.
+     */
+    protected static final int TT_INVALID = -1;
+    /**
+     * Token with content, at beginning or in the middle of a line.
+     */
+    protected static final int TT_TOKEN = 0;
+    /**
+     * Token (which can have content) when end of file is reached.
+     */
+    protected static final int TT_EOF = 1;
+    /**
+     * Token with content when end of a line is reached.
+     */
+    protected static final int TT_EORECORD = 2;
 
-  private final CSVStrategy strategy;
-  
-  // the following objects are shared to reduce garbage 
-  /** A record buffer for getLine(). Grows as necessary and is reused. */
-  private final ArrayList record = new ArrayList();
-  private final Token reusableToken = new Token();
-  private final CharBuffer wsBuf = new CharBuffer();
-  private final CharBuffer code = new CharBuffer(4);
+    /**
+     * Immutable empty String array.
+     */
+    private static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  
-  /**
-   * Token is an internal token representation.
-   * 
-   * It is used as contract between the lexer and the parser. 
-   */
-  static class Token {
-    /** Token type, see TT_xxx constants. */
-    int type = TT_INVALID;
-    /** The content buffer. */
-    CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
-    /** Token ready flag: indicates a valid token with content (ready for the parser). */
-    boolean isReady;
-    
-    Token reset() {
-        content.clear();
-        type = TT_INVALID;
-        isReady = false;
-        return this;
-    }
-  }
-  
-  // ======================================================
-  //  the constructor
-  // ======================================================
-  
-  /**
-   * Default strategy for the parser follows the default {@link CSVStrategy}.
-   * 
-   * @param input an InputStream containing ""csv-formatted"" stream
-   * @deprecated use {@link #CSVParser(Reader)}.
-   */
-  public CSVParser(InputStream input) {
-    this(new InputStreamReader(input));
-  }
-  
-  /**
-   * CSV parser using the default {@link CSVStrategy}.
-   * 
-   * @param input a Reader containing ""csv-formatted"" input
-   */
-  public CSVParser(Reader input) {
-    this(input, (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone());
-  }
-  
-  /**
-   * Customized value delimiter parser.
-   * 
-   * The parser follows the default {@link CSVStrategy}
-   * except for the delimiter setting.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter) {
-    this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
-  }
-  
-  /**
-   * Customized csv parser.
-   * 
-   * The parser parses according to the given CSV dialect settings.
-   * Leading whitespaces are truncated, unicode escapes are
-   * not interpreted and empty lines are ignored.
-   * 
-   * @param input a Reader based on ""csv-formatted"" input
-   * @param delimiter a Char used for value separation
-   * @param encapsulator a Char used as value encapsulation marker
-   * @param commentStart a Char used for comment identification
-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.
-   */
-  public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
-    this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
-  }
+    // the input stream
+    private final ExtendedBufferedReader in;
 
-  /**
-   * Customized CSV parser using the given {@link CSVStrategy}
-   *
-   * @param input a Reader containing ""csv-formatted"" input
-   * @param strategy the CSVStrategy used for CSV parsing
-   */
-  public CSVParser(Reader input, CSVStrategy strategy) {
-    this.in = new ExtendedBufferedReader(input);
-    this.strategy = strategy;
-  }
-  
-  // ======================================================
-  //  the parser
-  // ======================================================
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the content as an array of records
-   * (whereas records are arrays of single values).
-   * <p>
-   * The returned content starts at the current parse-position in
-   * the stream.
-   * 
-   * @return matrix of records x values ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[][] getAllValues() throws IOException {
-    ArrayList records = new ArrayList();
-    String[] values;
-    String[][] ret = null;
-    while ((values = getLine()) != null)  {
-      records.add(values);
+    private final CSVStrategy strategy;
+
+    // the following objects are shared to reduce garbage
+    /**
+     * A record buffer for getLine(). Grows as necessary and is reused.
+     */
+    private final ArrayList record = new ArrayList();
+    private final Token reusableToken = new Token();
+    private final CharBuffer wsBuf = new CharBuffer();
+    private final CharBuffer code = new CharBuffer(4);
+
+
+    /**
+     * Token is an internal token representation.
+     * <p/>
+     * It is used as contract between the lexer and the parser.
+     */
+    static class Token {
+        /**
+         * Token type, see TT_xxx constants.
+         */
+        int type = TT_INVALID;
+        /**
+         * The content buffer.
+         */
+        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);
+        /**
+         * Token ready flag: indicates a valid token with content (ready for the parser).
+         */
+        boolean isReady;
+
+        Token reset() {
+            content.clear();
+            type = TT_INVALID;
+            isReady = false;
+            return this;
+        }
     }
-    if (records.size() > 0) {
-      ret = new String[records.size()][];
-      records.toArray(ret);
+
+    // ======================================================
+    //  the constructor
+    // ======================================================
+
+    /**
+     * Default strategy for the parser follows the default {@link CSVStrategy}.
+     *
+     * @param input an InputStream containing ""csv-formatted"" stream
+     * @deprecated use {@link #CSVParser(Reader)}.
+     */
+    public CSVParser(InputStream input) {
+        this(new InputStreamReader(input));
     }
-    return ret;
-  }
-  
-  /**
-   * Parses the CSV according to the given strategy
-   * and returns the next csv-value as string.
-   * 
-   * @return next value in the input stream ('null' when end of file)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String nextValue() throws IOException {
-    Token tkn = nextToken();
-    String ret = null;
-    switch (tkn.type) {
-      case TT_TOKEN:
-      case TT_EORECORD: 
-        ret = tkn.content.toString();
-        break;
-      case TT_EOF:
-        ret = null;
-        break;
-      case TT_INVALID:
-      default:
-        // error no token available (or error)
-        throw new IOException(
-          ""(line "" + getLineNumber() 
-          + "") invalid parse sequence"");
-        // unreachable: break;
+
+    /**
+     * CSV parser using the default {@link CSVStrategy}.
+     *
+     * @param input a Reader containing ""csv-formatted"" input
+     */
+    public CSVParser(Reader input) {
+        this(input, (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone());
     }
-    return ret;
-  }
-  
-  /**
-   * Parses from the current point in the stream til
-   * the end of the current line.
-   * 
-   * @return array of values til end of line 
-   *        ('null' when end of file has been reached)
-   * @throws IOException on parse error or input read-failure
-   */
-  public String[] getLine() throws IOException {
-    String[] ret = EMPTY_STRING_ARRAY;
-    record.clear();
-    while (true) {
-        reusableToken.reset();
-        nextToken(reusableToken);
-        switch (reusableToken.type) {
+
+    /**
+     * Customized value delimiter parser.
+     * <p/>
+     * The parser follows the default {@link CSVStrategy}
+     * except for the delimiter setting.
+     *
+     * @param input     a Reader based on ""csv-formatted"" input
+     * @param delimiter a Char used for value separation
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter) {
+        this(input, delimiter, '""', CSVStrategy.COMMENTS_DISABLED);
+    }
+
+    /**
+     * Customized csv parser.
+     * <p/>
+     * The parser parses according to the given CSV dialect settings.
+     * Leading whitespaces are truncated, unicode escapes are
+     * not interpreted and empty lines are ignored.
+     *
+     * @param input        a Reader based on ""csv-formatted"" input
+     * @param delimiter    a Char used for value separation
+     * @param encapsulator a Char used as value encapsulation marker
+     * @param commentStart a Char used for comment identification
+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.
+     */
+    public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {
+        this(input, new CSVStrategy(delimiter, encapsulator, commentStart));
+    }
+
+    /**
+     * Customized CSV parser using the given {@link CSVStrategy}
+     *
+     * @param input    a Reader containing ""csv-formatted"" input
+     * @param strategy the CSVStrategy used for CSV parsing
+     */
+    public CSVParser(Reader input, CSVStrategy strategy) {
+        this.in = new ExtendedBufferedReader(input);
+        this.strategy = strategy;
+    }
+
+    // ======================================================
+    //  the parser
+    // ======================================================
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the content as an array of records
+     * (whereas records are arrays of single values).
+     * <p/>
+     * The returned content starts at the current parse-position in
+     * the stream.
+     *
+     * @return matrix of records x values ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String[][] getAllValues() throws IOException {
+        ArrayList records = new ArrayList();
+        String[] values;
+        String[][] ret = null;
+        while ((values = getLine()) != null) {
+            records.add(values);
+        }
+        if (records.size() > 0) {
+            ret = new String[records.size()][];
+            records.toArray(ret);
+        }
+        return ret;
+    }
+
+    /**
+     * Parses the CSV according to the given strategy
+     * and returns the next csv-value as string.
+     *
+     * @return next value in the input stream ('null' when end of file)
+     * @throws IOException on parse error or input read-failure
+     */
+    public String nextValue() throws IOException {
+        Token tkn = nextToken();
+        String ret = null;
+        switch (tkn.type) {
             case TT_TOKEN:
-                record.add(reusableToken.content.toString());
-                break;
             case TT_EORECORD:
-                record.add(reusableToken.content.toString());
+                ret = tkn.content.toString();
                 break;
             case TT_EOF:
-                if (reusableToken.isReady) {
-                    record.add(reusableToken.content.toString());
-                } else {
-                    ret = null;
-                }
+                ret = null;
                 break;
             case TT_INVALID:
             default:
-                // error: throw IOException
-                throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
-            // unreachable: break;
+                // error no token available (or error)
+                throw new IOException(
+                        ""(line "" + getLineNumber()
+                                + "") invalid parse sequence"");
+                // unreachable: break;
         }
-        if (reusableToken.type != TT_TOKEN) {
-            break;
-        }
+        return ret;
     }
-    if (!record.isEmpty()) {
-      ret = (String[]) record.toArray(new String[record.size()]);
-    }
-    return ret;
-  }
-  
-  /**
-   * Returns the current line number in the input stream.
-   * 
-   * ATTENTION: in case your csv has multiline-values the returned
-   *            number does not correspond to the record-number
-   * 
-   * @return  current line number
-   */
-  public int getLineNumber() {
-    return in.getLineNumber();  
-  }
-  
-  // ======================================================
-  //  the lexer(s)
-  // ======================================================
- 
-  /**
-   * Convenience method for <code>nextToken(null)</code>.
-   */
-  protected Token nextToken() throws IOException {
-      return nextToken(new Token());
-  }
-  
- /**
-   * Returns the next token.
-   * 
-   * A token corresponds to a term, a record change or an
-   * end-of-file indicator.
-   * 
-   * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
-   * Token.
-   * @return the next token found
-   * @throws IOException on stream access error
-   */
-  protected Token nextToken(Token tkn) throws IOException {
-    wsBuf.clear(); // reuse
-    
-    // get the last read char (required for empty line detection)
-    int lastChar = in.readAgain();
-    
-    //  read the next char and set eol
-    /* note: unfortunately isEndOfLine may consumes a character silently.
-     *       this has no effect outside of the method. so a simple workaround
-     *       is to call 'readAgain' on the stream...
-     *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+
+    /**
+     * Parses from the current point in the stream til
+     * the end of the current line.
+     *
+     * @return array of values til end of line
+     *         ('null' when end of file has been reached)
+     * @throws IOException on parse error or input read-failure
      */
-    int c = in.read();
-    boolean eol = isEndOfLine(c);
-    c = in.readAgain();
-     
-    //  empty line detection: eol AND (last char was EOL or beginning)
-    while (strategy.getIgnoreEmptyLines() && eol 
-      && (lastChar == '\n' 
-      || lastChar == '\r' 
-      || lastChar == ExtendedBufferedReader.UNDEFINED) 
-      && !isEndOfFile(lastChar)) {
-      // go on char ahead ...
-      lastChar = c;
-      c = in.read();
-      eol = isEndOfLine(c);
-      c = in.readAgain();
-      // reached end of file without any content (empty line at the end)
-      if (isEndOfFile(c)) {
-        tkn.type = TT_EOF;
-        return tkn;
-      }
-    }
-
-    // did we reach eof during the last iteration already ? TT_EOF
-    if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
-      tkn.type = TT_EOF;
-      return tkn;
-    } 
-    
-    //  important: make sure a new char gets consumed in each iteration
-    while (!tkn.isReady && tkn.type != TT_EOF) {
-      // ignore whitespaces at beginning of a token
-      while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
-        wsBuf.append((char) c);
-        c = in.read();
-        eol = isEndOfLine(c);
-      }
-      // ok, start of token reached: comment, encapsulated, or token
-      if (c == strategy.getCommentStart()) {
-        // ignore everything till end of line and continue (incr linecount)
-        in.readLine();
-        tkn = nextToken(tkn.reset());
-      } else if (c == strategy.getDelimiter()) {
-        // empty token return TT_TOKEN("""")
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-      } else if (eol) {
-        // empty token return TT_EORECORD("""")
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-      } else if (c == strategy.getEncapsulator()) {
-        // consume encapsulated token
-        encapsulatedTokenLexer(tkn, c);
-      } else if (isEndOfFile(c)) {
-        // end of file return TT_EOF()
-        //noop: tkn.content.append("""");
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-      } else {
-        // next token must be a simple token
-        // add removed blanks when not ignoring whitespace chars...
-        if (!strategy.getIgnoreLeadingWhitespaces()) {
-          tkn.content.append(wsBuf);
-        }
-        simpleTokenLexer(tkn, c);
-      }
-    }
-    return tkn;  
-  }
-  
-  /**
-   * A simple token lexer
-   * 
-   * Simple token are tokens which are not surrounded by encapsulators.
-   * A simple token might contain escaped delimiters (as \, or \;). The
-   * token is finished when one of the following conditions become true:
-   * <ul>
-   *   <li>end of line has been reached (TT_EORECORD)</li>
-   *   <li>end of stream has been reached (TT_EOF)</li>
-   *   <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
-   * </ul>
-   *  
-   * @param tkn  the current token
-   * @param c    the current character
-   * @return the filled token
-   * 
-   * @throws IOException on stream access error
-   */
-  private Token simpleTokenLexer(Token tkn, int c) throws IOException {
-    for (;;) {
-      if (isEndOfLine(c)) {
-        // end of record
-        tkn.type = TT_EORECORD;
-        tkn.isReady = true;
-        break;
-      } else if (isEndOfFile(c)) {
-        // end of file
-        tkn.type = TT_EOF;
-        tkn.isReady = true;
-        break;
-      } else if (c == strategy.getDelimiter()) {
-        // end of token
-        tkn.type = TT_TOKEN;
-        tkn.isReady = true;
-        break;
-      } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
-        // interpret unicode escaped chars (like \u0070 -> p)
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else {
-        tkn.content.append((char) c);
-      }
-      
-      c = in.read();
-    }
-
-    if (strategy.getIgnoreTrailingWhitespaces()) {
-      tkn.content.trimTrailingWhitespace();
-    }
-
-    return tkn;
-  }
-  
-  
-  /**
-   * An encapsulated token lexer
-   * 
-   * Encapsulated tokens are surrounded by the given encapsulating-string.
-   * The encapsulator itself might be included in the token using a
-   * doubling syntax (as """", '') or using escaping (as in \"", \').
-   * Whitespaces before and after an encapsulated token are ignored.
-   * 
-   * @param tkn    the current token
-   * @param c      the current character
-   * @return a valid token object
-   * @throws IOException on invalid state
-   */
-  private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
-    // save current line
-    int startLineNumber = getLineNumber();
-    // ignore the given delimiter
-    // assert c == delimiter;
-    for (;;) {
-      c = in.read();
-
-      if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead()=='u') {
-        tkn.content.append((char) unicodeEscapeLexer(c));
-      } else if (c == strategy.getEscape()) {
-        tkn.content.append((char)readEscape(c));
-      } else if (c == strategy.getEncapsulator()) {
-        if (in.lookAhead() == strategy.getEncapsulator()) {
-          // double or escaped encapsulator -> add single encapsulator to token
-          c = in.read();
-          tkn.content.append((char) c);
-        } else {
-          // token finish mark (encapsulator) reached: ignore whitespace till delimiter
-          for (;;) {
-            c = in.read();
-            if (c == strategy.getDelimiter()) {
-              tkn.type = TT_TOKEN;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfFile(c)) {
-              tkn.type = TT_EOF;
-              tkn.isReady = true;
-              return tkn;
-            } else if (isEndOfLine(c)) {
-              // ok eo token reached
-              tkn.type = TT_EORECORD;
-              tkn.isReady = true;
-              return tkn;
-            } else if (!isWhitespace(c)) {
-              // error invalid char between token and next delimiter
-              throw new IOException(
-                      ""(line "" + getLineNumber()
-                              + "") invalid char between encapsulated token end delimiter""
-              );
+    public String[] getLine() throws IOException {
+        String[] ret = EMPTY_STRING_ARRAY;
+        record.clear();
+        while (true) {
+            reusableToken.reset();
+            nextToken(reusableToken);
+            switch (reusableToken.type) {
+                case TT_TOKEN:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EORECORD:
+                    record.add(reusableToken.content.toString());
+                    break;
+                case TT_EOF:
+                    if (reusableToken.isReady) {
+                        record.add(reusableToken.content.toString());
+                    } else {
+                        ret = null;
+                    }
+                    break;
+                case TT_INVALID:
+                default:
+                    // error: throw IOException
+                    throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
+                    // unreachable: break;
             }
-          }
+            if (reusableToken.type != TT_TOKEN) {
+                break;
+            }
         }
-      } else if (isEndOfFile(c)) {
-        // error condition (end of file before end of token)
-        throw new IOException(
-                ""(startline "" + startLineNumber + "")""
-                        + ""eof reached before encapsulated token finished""
-        );
-      } else {
-        // consume character
-        tkn.content.append((char) c);
-      }
-    }
-  }
-  
-  
-  /**
-   * Decodes Unicode escapes.
-   * 
-   * Interpretation of ""\\uXXXX"" escape sequences
-   * where XXXX is a hex-number.
-   * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
-   * @return the decoded character
-   * @throws IOException on wrong unicode escape sequence or read error
-   */
-  protected int unicodeEscapeLexer(int c) throws IOException {
-    int ret = 0;
-    // ignore 'u' (assume c==\ now) and read 4 hex digits
-    c = in.read();
-    code.clear();
-    try {
-      for (int i = 0; i < 4; i++) {
-        c  = in.read();
-        if (isEndOfFile(c) || isEndOfLine(c)) {
-          throw new NumberFormatException(""number too short"");
+        if (!record.isEmpty()) {
+            ret = (String[]) record.toArray(new String[record.size()]);
         }
-        code.append((char) c);
-      }
-      ret = Integer.parseInt(code.toString(), 16);
-    } catch (NumberFormatException e) {
-      throw new IOException(
-        ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '"" 
-        + code.toString() + ""'"" + e.toString());
+        return ret;
     }
-    return ret;
-  }
 
-  private int readEscape(int c) throws IOException {
-    // assume c is the escape char (normally a backslash)
-    c = in.read();
-    int out;
-    switch (c) {
-      case 'r': out='\r'; break;
-      case 'n': out='\n'; break;
-      case 't': out='\t'; break;
-      case 'b': out='\b'; break;
-      case 'f': out='\f'; break;
-      default : out=c;
+    /**
+     * Returns the current line number in the input stream.
+     * <p/>
+     * ATTENTION: in case your csv has multiline-values the returned
+     * number does not correspond to the record-number
+     *
+     * @return current line number
+     */
+    public int getLineNumber() {
+        return in.getLineNumber();
     }
-    return out;
-  }
-  
-  // ======================================================
-  //  strategies
-  // ======================================================
-  
-  /**
-   * Obtain the specified CSV Strategy.  This should not be modified.
-   * 
-   * @return strategy currently being used
-   */
-  public CSVStrategy getStrategy() {
-    return this.strategy;
-  }
-  
-  // ======================================================
-  //  Character class checker
-  // ======================================================
-  
-  /**
-   * @return true if the given char is a whitespace character
-   */
-  private boolean isWhitespace(int c) {
-    return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
-  }
-  
-  /**
-   * Greedy - accepts \n, \r and \r\n 
-   * This checker consumes silently the second control-character...
-   * 
-   * @return true if the given character is a line-terminator
-   */
-  private boolean isEndOfLine(int c) throws IOException {
-    // check if we have \r\n...
-    if (c == '\r') {
-      if (in.lookAhead() == '\n') {
-        // note: does not change c outside of this method !!
+
+    // ======================================================
+    //  the lexer(s)
+    // ======================================================
+
+    /**
+     * Convenience method for <code>nextToken(null)</code>.
+     */
+    protected Token nextToken() throws IOException {
+        return nextToken(new Token());
+    }
+
+    /**
+     * Returns the next token.
+     * <p/>
+     * A token corresponds to a term, a record change or an
+     * end-of-file indicator.
+     *
+     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the
+     *            Token.
+     * @return the next token found
+     * @throws IOException on stream access error
+     */
+    protected Token nextToken(Token tkn) throws IOException {
+        wsBuf.clear(); // reuse
+
+        // get the last read char (required for empty line detection)
+        int lastChar = in.readAgain();
+
+        //  read the next char and set eol
+        /* note: unfortunately isEndOfLine may consumes a character silently.
+        *       this has no effect outside of the method. so a simple workaround
+        *       is to call 'readAgain' on the stream...
+        *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)
+        */
+        int c = in.read();
+        boolean eol = isEndOfLine(c);
+        c = in.readAgain();
+
+        //  empty line detection: eol AND (last char was EOL or beginning)
+        while (strategy.getIgnoreEmptyLines() && eol
+                && (lastChar == '\n'
+                || lastChar == '\r'
+                || lastChar == ExtendedBufferedReader.UNDEFINED)
+                && !isEndOfFile(lastChar)) {
+            // go on char ahead ...
+            lastChar = c;
+            c = in.read();
+            eol = isEndOfLine(c);
+            c = in.readAgain();
+            // reached end of file without any content (empty line at the end)
+            if (isEndOfFile(c)) {
+                tkn.type = TT_EOF;
+                return tkn;
+            }
+        }
+
+        // did we reach eof during the last iteration already ? TT_EOF
+        if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
+            tkn.type = TT_EOF;
+            return tkn;
+        }
+
+        //  important: make sure a new char gets consumed in each iteration
+        while (!tkn.isReady && tkn.type != TT_EOF) {
+            // ignore whitespaces at beginning of a token
+            while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
+                wsBuf.append((char) c);
+                c = in.read();
+                eol = isEndOfLine(c);
+            }
+            // ok, start of token reached: comment, encapsulated, or token
+            if (c == strategy.getCommentStart()) {
+                // ignore everything till end of line and continue (incr linecount)
+                in.readLine();
+                tkn = nextToken(tkn.reset());
+            } else if (c == strategy.getDelimiter()) {
+                // empty token return TT_TOKEN("""")
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+            } else if (eol) {
+                // empty token return TT_EORECORD("""")
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+            } else if (c == strategy.getEncapsulator()) {
+                // consume encapsulated token
+                encapsulatedTokenLexer(tkn, c);
+            } else if (isEndOfFile(c)) {
+                // end of file return TT_EOF()
+                //noop: tkn.content.append("""");
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+            } else {
+                // next token must be a simple token
+                // add removed blanks when not ignoring whitespace chars...
+                if (!strategy.getIgnoreLeadingWhitespaces()) {
+                    tkn.content.append(wsBuf);
+                }
+                simpleTokenLexer(tkn, c);
+            }
+        }
+        return tkn;
+    }
+
+    /**
+     * A simple token lexer
+     * <p/>
+     * Simple token are tokens which are not surrounded by encapsulators.
+     * A simple token might contain escaped delimiters (as \, or \;). The
+     * token is finished when one of the following conditions become true:
+     * <ul>
+     * <li>end of line has been reached (TT_EORECORD)</li>
+     * <li>end of stream has been reached (TT_EOF)</li>
+     * <li>an unescaped delimiter has been reached (TT_TOKEN)</li>
+     * </ul>
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return the filled token
+     * @throws IOException on stream access error
+     */
+    private Token simpleTokenLexer(Token tkn, int c) throws IOException {
+        for (; ;) {
+            if (isEndOfLine(c)) {
+                // end of record
+                tkn.type = TT_EORECORD;
+                tkn.isReady = true;
+                break;
+            } else if (isEndOfFile(c)) {
+                // end of file
+                tkn.type = TT_EOF;
+                tkn.isReady = true;
+                break;
+            } else if (c == strategy.getDelimiter()) {
+                // end of token
+                tkn.type = TT_TOKEN;
+                tkn.isReady = true;
+                break;
+            } else if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                // interpret unicode escaped chars (like \u0070 -> p)
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else {
+                tkn.content.append((char) c);
+            }
+
+            c = in.read();
+        }
+
+        if (strategy.getIgnoreTrailingWhitespaces()) {
+            tkn.content.trimTrailingWhitespace();
+        }
+
+        return tkn;
+    }
+
+
+    /**
+     * An encapsulated token lexer
+     * <p/>
+     * Encapsulated tokens are surrounded by the given encapsulating-string.
+     * The encapsulator itself might be included in the token using a
+     * doubling syntax (as """", '') or using escaping (as in \"", \').
+     * Whitespaces before and after an encapsulated token are ignored.
+     *
+     * @param tkn the current token
+     * @param c   the current character
+     * @return a valid token object
+     * @throws IOException on invalid state
+     */
+    private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {
+        // save current line
+        int startLineNumber = getLineNumber();
+        // ignore the given delimiter
+        // assert c == delimiter;
+        for (; ;) {
+            c = in.read();
+
+            if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
+                tkn.content.append((char) unicodeEscapeLexer(c));
+            } else if (c == strategy.getEscape()) {
+                tkn.content.append((char) readEscape(c));
+            } else if (c == strategy.getEncapsulator()) {
+                if (in.lookAhead() == strategy.getEncapsulator()) {
+                    // double or escaped encapsulator -> add single encapsulator to token
+                    c = in.read();
+                    tkn.content.append((char) c);
+                } else {
+                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter
+                    for (; ;) {
+                        c = in.read();
+                        if (c == strategy.getDelimiter()) {
+                            tkn.type = TT_TOKEN;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfFile(c)) {
+                            tkn.type = TT_EOF;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (isEndOfLine(c)) {
+                            // ok eo token reached
+                            tkn.type = TT_EORECORD;
+                            tkn.isReady = true;
+                            return tkn;
+                        } else if (!isWhitespace(c)) {
+                            // error invalid char between token and next delimiter
+                            throw new IOException(
+                                    ""(line "" + getLineNumber()
+                                            + "") invalid char between encapsulated token end delimiter""
+                            );
+                        }
+                    }
+                }
+            } else if (isEndOfFile(c)) {
+                // error condition (end of file before end of token)
+                throw new IOException(
+                        ""(startline "" + startLineNumber + "")""
+                                + ""eof reached before encapsulated token finished""
+                );
+            } else {
+                // consume character
+                tkn.content.append((char) c);
+            }
+        }
+    }
+
+
+    /**
+     * Decodes Unicode escapes.
+     * <p/>
+     * Interpretation of ""\\uXXXX"" escape sequences
+     * where XXXX is a hex-number.
+     *
+     * @param c current char which is discarded because it's the ""\\"" of ""\\uXXXX""
+     * @return the decoded character
+     * @throws IOException on wrong unicode escape sequence or read error
+     */
+    protected int unicodeEscapeLexer(int c) throws IOException {
+        int ret = 0;
+        // ignore 'u' (assume c==\ now) and read 4 hex digits
         c = in.read();
-      }
+        code.clear();
+        try {
+            for (int i = 0; i < 4; i++) {
+                c = in.read();
+                if (isEndOfFile(c) || isEndOfLine(c)) {
+                    throw new NumberFormatException(""number too short"");
+                }
+                code.append((char) c);
+            }
+            ret = Integer.parseInt(code.toString(), 16);
+        } catch (NumberFormatException e) {
+            throw new IOException(
+                    ""(line "" + getLineNumber() + "") Wrong unicode escape sequence found '""
+                            + code.toString() + ""'"" + e.toString());
+        }
+        return ret;
     }
-    return (c == '\n' || c == '\r');
-  }
-  
-  /**
-   * @return true if the given character indicates end of file
-   */
-  private boolean isEndOfFile(int c) {
-    return c == ExtendedBufferedReader.END_OF_STREAM;
-  }
+
+    private int readEscape(int c) throws IOException {
+        // assume c is the escape char (normally a backslash)
+        c = in.read();
+        int out;
+        switch (c) {
+            case 'r':
+                out = '\r';
+                break;
+            case 'n':
+                out = '\n';
+                break;
+            case 't':
+                out = '\t';
+                break;
+            case 'b':
+                out = '\b';
+                break;
+            case 'f':
+                out = '\f';
+                break;
+            default:
+                out = c;
+        }
+        return out;
+    }
+
+    // ======================================================
+    //  strategies
+    // ======================================================
+
+    /**
+     * Obtain the specified CSV Strategy.  This should not be modified.
+     *
+     * @return strategy currently being used
+     */
+    public CSVStrategy getStrategy() {
+        return this.strategy;
+    }
+
+    // ======================================================
+    //  Character class checker
+    // ======================================================
+
+    /**
+     * @return true if the given char is a whitespace character
+     */
+    private boolean isWhitespace(int c) {
+        return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());
+    }
+
+    /**
+     * Greedy - accepts \n, \r and \r\n
+     * This checker consumes silently the second control-character...
+     *
+     * @return true if the given character is a line-terminator
+     */
+    private boolean isEndOfLine(int c) throws IOException {
+        // check if we have \r\n...
+        if (c == '\r') {
+            if (in.lookAhead() == '\n') {
+                // note: does not change c outside of this method !!
+                c = in.read();
+            }
+        }
+        return (c == '\n' || c == '\r');
+    }
+
+    /**
+     * @return true if the given character indicates end of file
+     */
+    private boolean isEndOfFile(int c) {
+        return c == ExtendedBufferedReader.END_OF_STREAM;
+    }
 }
",,25502
5816,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/writer/CSVConfigGuesser.java,1c642fc7ecea497c92b961614ebba569ac151aa8,1168098040,107,,,,,,,,"        config = null;",,,25502
5817,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/CSVParser.java,1166ca605bcc035654771f1ddc1092d86f2ec1e8,1296549960,234,,,,,,,,"                ret = null;",,,25502
5818,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/java/org/apache/commons/csv/CSVParser.java,1166ca605bcc035654771f1ddc1092d86f2ec1e8,1296549960,272,,,,,,,,"                        ret = null;",,,25502
5819,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,c9aeca5c39033c95c26c1475dcf0fd2ea86672e8,1320835134,234,00d0def6953d414af6ecf36a9584c5453ee39c29,1331135892,206,fc4ccb426eb3934ee1656db9b18c7d797ac6bd1d,1320850445,-1,1320850445/1320835134,"                ret = null;","     }
 
     /**
-     * Parses the CSV according to the given strategy
-     * and returns the next csv-value as string.
-     *
-     * @return next value in the input stream ('null' when end of file)
-     * @throws IOException on parse error or input read-failure
-     */
-    public String nextValue() throws IOException {
-        Token tkn = nextToken();
-        String ret = null;
-        switch (tkn.type) {
-            case TT_TOKEN:
-            case TT_EORECORD:
-                ret = tkn.content.toString();
-                break;
-            case TT_EOF:
-                ret = null;
-                break;
-            case TT_INVALID:
-            default:
-                // error no token available (or error)
-                throw new IOException(
-                        ""(line "" + getLineNumber()
-                                + "") invalid parse sequence"");
-                // unreachable: break;
-        }
-        return ret;
-    }
-
-    /**
      * Parses from the current point in the stream til
      * the end of the current line.
      *
",,25502
5820,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,c9aeca5c39033c95c26c1475dcf0fd2ea86672e8,1320835134,272,d54b339caa945f35b4b2536b1455f314e57808dd,1444852109,295,,,,,"                        ret = null;",,,25502
5821,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/writer/CSVConfigGuesser.java,c9aeca5c39033c95c26c1475dcf0fd2ea86672e8,1320835134,112,,,,,,,,"        config = null;",,,25502
5822,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,045dbbbe4ab84618cee8ba27d00b9283ce0a2715,1320879853,235,f78b5a14ca34f6176890b00308868b664b696148,1375201327,330,,,,,"                current = null;",,,25502
5823,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,ca7bbae40ef89e561f74d1a00776e3a9f697bd37,1331144512,155,6eddd544e56b4c376619cad6b279885962293b6d,1350271552,184,2ec4c994c0458ef893af9bd518849bec21b2dec4,1331200791,-1,1331200791/1331144512,"                        ret = null;","                     if (reusableToken.isReady) {
                         record.add(reusableToken.content.toString());
                     } else {
-                        ret = null;
+                        result = null;
                     }
                     break;
                 case INVALID:
-                default:
                     // error: throw IOException
                     throw new IOException(""(line "" + getLineNumber() + "") invalid parse sequence"");
                     // unreachable: break;
",,25502
5824,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,2ec4c994c0458ef893af9bd518849bec21b2dec4,1331200791,160,,,,,,,,"                        result = null;",,,25502
5825,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,5a0894f9e0ee9f4703b8db3f200ff4a507bf043b,1372043165,232,97d34575a1074197b8a1b5832d3b2cd3e7656d8f,1375285197,251,,,,,"            record.add(input.equalsIgnoreCase(nullString) ? null : input);",,,25502
5826,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,61fdb7a03a22065de4c63525a4b836ba616aa1f1,1375201603,286,d69e911aeabd27ecb5b05939c2e533726b1167ef,1407660822,418,,,,,"                current = null;",,,25502
5827,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,316a51f5208bc95f22124d1579882131a4f441b2,1375322613,280,1e70eaaaf47059ed91ef9ac855990f1d37c03692,1376132710,265,,,,,"            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);",,,25502
5828,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,33cf28990720e1c5a4ba92e4363a0fe1cf80a6c9,1376503633,193,,,,,,,,"            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);",,,25502
5829,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVFormat.java,35d101c2adecd51730f88e43941d85d16034886f,1399483651,314,4471e9d66a6fe249efb758ac7f2140ed5cd349e4,1415714447,366,16b175b01aaa27efd796628755b48e48b6866e4d,1399486330,-1,1399486330/1399483651,"        	this.header = null;","         this.recordSeparator = recordSeparator;
         this.nullString = nullString;
         if (header == null) {
-        	this.header = null;
+            this.header = null;
         } else {
-        	Set<String> dupCheck = new HashSet<String>();
-        	for(String hdr : header) {
-        		if (!dupCheck.add(hdr)) {
-        			throw new IllegalArgumentException(""The header contains a duplicate entry: '"" + hdr + ""' in "" + Arrays.toString(header));
-        		}
-        	}
-            this.header = header.clone();        	
+            Set<String> dupCheck = new HashSet<String>();
+            for(String hdr : header) {
+                if (!dupCheck.add(hdr)) {
+                    throw new IllegalArgumentException(""The header contains a duplicate entry: '"" + hdr + ""' in "" + Arrays.toString(header));
+                }
+            }
+            this.header = header.clone();
         }
         this.skipHeaderRecord = skipHeaderRecord;
     }
",,25502
5830,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVFormat.java,16b175b01aaa27efd796628755b48e48b6866e4d,1399486330,314,,,,,,,,"            this.header = null;",,,25502
5831,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,e28e28e1f27c554850dc0449f5f290e222121c62,1414561480,461,d6278c817a1b0b89222bc58c12bbebf9a07ca82f,1469901775,524,f368f64fa7f9acdcc01084f676e8b9c2b86f946e,1526675090,-1,1526675090/1414561480,"                this.current = null;","      */
     @Override
     public Iterator<CSVRecord> iterator() {
-        return new Iterator<CSVRecord>() {
-            private CSVRecord current;
-
-            private CSVRecord getNextRecord() {
-                try {
-                    return CSVParser.this.nextRecord();
-                } catch (final IOException e) {
-                    throw new IllegalStateException(
-                            e.getClass().getSimpleName() + "" reading next record: "" + e.toString(), e);
-                }
-            }
-
-            @Override
-            public boolean hasNext() {
-                if (CSVParser.this.isClosed()) {
-                    return false;
-                }
-                if (this.current == null) {
-                    this.current = this.getNextRecord();
-                }
-
-                return this.current != null;
-            }
-
-            @Override
-            public CSVRecord next() {
-                if (CSVParser.this.isClosed()) {
-                    throw new NoSuchElementException(""CSVParser has been closed"");
-                }
-                CSVRecord next = this.current;
-                this.current = null;
-
-                if (next == null) {
-                    // hasNext() wasn't called before
-                    next = this.getNextRecord();
-                    if (next == null) {
-                        throw new NoSuchElementException(""No more CSV records available"");
-                    }
-                }
-
-                return next;
-            }
-
-            @Override
-            public void remove() {
-                throw new UnsupportedOperationException();
-            }
-        };
+        return csvRecordIterator;
     }
+    
+    class CSVRecordIterator implements Iterator<CSVRecord> {
+        private CSVRecord current;
+  
+        private CSVRecord getNextRecord() {
+            try {
+                return CSVParser.this.nextRecord();
+            } catch (final IOException e) {
+                throw new IllegalStateException(
+                        e.getClass().getSimpleName() + "" reading next record: "" + e.toString(), e);
+            }
+        }
+  
+        @Override
+        public boolean hasNext() {
+            if (CSVParser.this.isClosed()) {
+                return false;
+            }
+            if (this.current == null) {
+                this.current = this.getNextRecord();
+            }
+  
+            return this.current != null;
+        }
+  
+        @Override
+        public CSVRecord next() {
+            if (CSVParser.this.isClosed()) {
+                throw new NoSuchElementException(""CSVParser has been closed"");
+            }
+            CSVRecord next = this.current;
+            this.current = null;
+  
+            if (next == null) {
+                // hasNext() wasn't called before
+                next = this.getNextRecord();
+                if (next == null) {
+                    throw new NoSuchElementException(""No more CSV records available"");
+                }
+            }
+  
+            return next;
+        }
+  
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    };
 
     /**
      * Parses the next record from the current point in the stream.
",,25502
5832,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/test/java/org/apache/commons/csv/CSVPrinterTest.java,f8b80e83417c3c7eeed1282118f64fa0e85c4787,1453170859,432,51b4bf371f71a219806f6ad69f51d095a94d339d,1453184495,500,,,,,"                fixed[i] = null;",,,25502
5833,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,16b9e2c79122f5a76863854cc4b33939da63710d,1460960211,296,d6278c817a1b0b89222bc58c12bbebf9a07ca82f,1469901775,354,,,,,"        this.record.add(inputClean.equals(nullString) ? null : inputClean);",,,25502
5834,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,16b9e2c79122f5a76863854cc4b33939da63710d,1460960211,467,,,,,,,,"                this.current = null;",,,25502
5835,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,9b37b1eb1f53e107c83e60232ec39d6174591f24,1469902591,382,21f4f584ba1e7ebaef08dc797d9f102a896dd715,1590350921,449,259812ec0af308b2ceec4687ffa52b873425bb5b,1503068539,-1,1503068539/1469902591,"        this.record.add(inputClean.equals(nullString) ? null : inputClean);","             return;
         }
         final String nullString = this.format.getNullString();
-        this.record.add(inputClean.equals(nullString) ? null : inputClean);
+        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);
     }
 
     /**
",,25502
5836,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,9b37b1eb1f53e107c83e60232ec39d6174591f24,1469902591,552,0c216e783cbff346c820cabb83486e4401b2c0a2,1507578182,552,f368f64fa7f9acdcc01084f676e8b9c2b86f946e,1526675090,-1,1526675090/1469902591,"                this.current = null;","      */
     @Override
     public Iterator<CSVRecord> iterator() {
-        return new Iterator<CSVRecord>() {
-            private CSVRecord current;
-
-            private CSVRecord getNextRecord() {
-                try {
-                    return CSVParser.this.nextRecord();
-                } catch (final IOException e) {
-                    throw new IllegalStateException(
-                            e.getClass().getSimpleName() + "" reading next record: "" + e.toString(), e);
-                }
-            }
-
-            @Override
-            public boolean hasNext() {
-                if (CSVParser.this.isClosed()) {
-                    return false;
-                }
-                if (this.current == null) {
-                    this.current = this.getNextRecord();
-                }
-
-                return this.current != null;
-            }
-
-            @Override
-            public CSVRecord next() {
-                if (CSVParser.this.isClosed()) {
-                    throw new NoSuchElementException(""CSVParser has been closed"");
-                }
-                CSVRecord next = this.current;
-                this.current = null;
-
-                if (next == null) {
-                    // hasNext() wasn't called before
-                    next = this.getNextRecord();
-                    if (next == null) {
-                        throw new NoSuchElementException(""No more CSV records available"");
-                    }
-                }
-
-                return next;
-            }
-
-            @Override
-            public void remove() {
-                throw new UnsupportedOperationException();
-            }
-        };
+        return csvRecordIterator;
     }
+    
+    class CSVRecordIterator implements Iterator<CSVRecord> {
+        private CSVRecord current;
+  
+        private CSVRecord getNextRecord() {
+            try {
+                return CSVParser.this.nextRecord();
+            } catch (final IOException e) {
+                throw new IllegalStateException(
+                        e.getClass().getSimpleName() + "" reading next record: "" + e.toString(), e);
+            }
+        }
+  
+        @Override
+        public boolean hasNext() {
+            if (CSVParser.this.isClosed()) {
+                return false;
+            }
+            if (this.current == null) {
+                this.current = this.getNextRecord();
+            }
+  
+            return this.current != null;
+        }
+  
+        @Override
+        public CSVRecord next() {
+            if (CSVParser.this.isClosed()) {
+                throw new NoSuchElementException(""CSVParser has been closed"");
+            }
+            CSVRecord next = this.current;
+            this.current = null;
+  
+            if (next == null) {
+                // hasNext() wasn't called before
+                next = this.getNextRecord();
+                if (next == null) {
+                    throw new NoSuchElementException(""No more CSV records available"");
+                }
+            }
+  
+            return next;
+        }
+  
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    };
 
     /**
      * Parses the next record from the current point in the stream.
",,25502
5837,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,259812ec0af308b2ceec4687ffa52b873425bb5b,1503068539,367,,,,,,,,"        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);",,,25502
5838,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,f368f64fa7f9acdcc01084f676e8b9c2b86f946e,1526675090,558,d8d5de6476ac411593bd34ca89492e74905372ab,1558272766,560,,,,,"            this.current = null;",,,25502
5839,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/main/java/org/apache/commons/csv/CSVParser.java,788f2aaa7aff361416e11fba5df7cfc31060cbb1,1558275987,167,21f4f584ba1e7ebaef08dc797d9f102a896dd715,1590350921,168,,,,,"            this.current = null;",,,25502
5840,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/test/resources/org/apache/commons/csv/CSVParser.java,914f2c41557bdd3dcde8d10d6f128fa3bb307b11,1590667818,168,,,,,,,,"            this.current = null;",,,25502
5841,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76c2323b774725139dea401bac4837d7e706ba5ed286f66e21e1521164a87ca3ae5b60d090db214416b5521ac9a329ed8ae14e398c1a55d4e793f2ee7de3c2f65b5906073fdae5096a25d6774c3f60ac7f2256293789f5e7bb4b772fac9d9abf1ec09da73ed16d027cb732f8b37e575e3540afb8e08cd3ac0680a790f615e045bee86b7956650af9899263ed01d8c593639fdaf9fb39433f2d3626b47d3b158a487b5aaa8434102307df4cb90540703b0deaec393ba2c7165721d14ac65627856acc61e7e93a9713e2e5213d1e420a96aa2f428ccdb7cc2ee4054632be,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/commons-csv/src/test/resources/org/apache/commons/csv/CSVParser.java,914f2c41557bdd3dcde8d10d6f128fa3bb307b11,1590667818,449,,,,,,,,"        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);",,,25502
