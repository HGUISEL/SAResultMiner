Detection ID,Latest Commit ID,PMD Version,Rule Name,File Path,Violation Introducing Commit ID,VIC Date,VIC Line Num.,Latest Detection Commit ID,LDC ID Date,LDC Line Num.,Violation Fixed Commit ID,VFC Date,VFC Line Num.,Fixed Period(day),Original Code,Fixed Code,Really Fixed?,Time
2231,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/jute/compiler/generated/RccTokenManager.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,722,,,,,,,,"   image = null;",,,6461
2232,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/jute/compiler/generated/SimpleCharStream.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,404,,,,,,,,"     buffer = null;",,,6461
2233,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/jute/compiler/generated/SimpleCharStream.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,405,,,,,,,,"     bufline = null;",,,6461
2234,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/jute/compiler/generated/SimpleCharStream.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,406,,,,,,,,"     bufcolumn = null;",,,6461
2235,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ClientCnxn.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,734,a6bc7d54791e73b06083996ab57fdba9340ae1aa,1210283432,762,ffce83512370e970426f7f6b7cff8f519de59bd4,1210633285,-1,1210633285/1194064875,"            sockKey = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.lang.Thread.UncaughtExceptionHandler;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.SocketChannel;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
-import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
-import com.yahoo.zookeeper.AsyncCallback.DataCallback;
-import com.yahoo.zookeeper.AsyncCallback.StatCallback;
-import com.yahoo.zookeeper.AsyncCallback.StringCallback;
-import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
-import com.yahoo.zookeeper.Watcher.Event;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.ZooKeeper.States;
-import com.yahoo.zookeeper.proto.AuthPacket;
-import com.yahoo.zookeeper.proto.ConnectRequest;
-import com.yahoo.zookeeper.proto.ConnectResponse;
-import com.yahoo.zookeeper.proto.CreateResponse;
-import com.yahoo.zookeeper.proto.ExistsResponse;
-import com.yahoo.zookeeper.proto.GetACLResponse;
-import com.yahoo.zookeeper.proto.GetChildrenResponse;
-import com.yahoo.zookeeper.proto.GetDataResponse;
-import com.yahoo.zookeeper.proto.ReplyHeader;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.proto.SetACLResponse;
-import com.yahoo.zookeeper.proto.SetDataResponse;
-import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.ByteBufferInputStream;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooTrace;
-
-/**
- * This class manages the socket i/o for the client. ClientCnxn maintains a list
- * of available servers to connect to and ""transparently"" switches servers it is
- * connected to as needed.
- *
- */
-class ClientCnxn {
-    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
-
-    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
-
-    static class AuthData {
-        AuthData(String scheme, byte data[]) {
-            this.scheme = scheme;
-            this.data = data;
-        }
-
-        String scheme;
-
-        byte data[];
-    }
-
-    private ArrayList<AuthData> authInfo = new ArrayList<AuthData>();
-
-    /**
-     * These are the packets that have been sent and are waiting for a response.
-     */
-    private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
-
-    private LinkedBlockingQueue waitingEvents = new LinkedBlockingQueue();
-
-    /**
-     * These are the packets that need to be sent.
-     */
-    private LinkedList<Packet> outgoingQueue = new LinkedList<Packet>();
-
-    private int nextAddrToTry = 0;
-
-    private int connectTimeout;
-
-    private int readTimeout;
-
-    private final int sessionTimeout;
-
-    private final ZooKeeper zooKeeper;
-
-    private long sessionId;
-
-    private byte sessionPasswd[] = new byte[16];
-
-    final SendThread sendThread;
-
-    final EventThread eventThread;
-
-    final Selector selector = Selector.open();
-
-    public long getSessionId() {
-        return sessionId;
-    }
-
-    public byte[] getSessionPasswd() {
-        return sessionPasswd;
-    }
-
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append(""sessionId: "").append(sessionId).append(""\n"");
-        sb.append(""lastZxid: "").append(lastZxid).append(""\n"");
-        sb.append(""xid: "").append(xid).append(""\n"");
-        sb.append(""nextAddrToTry: "").append(nextAddrToTry).append(""\n"");
-        sb.append(""serverAddrs: "").append(serverAddrs.get(nextAddrToTry))
-                .append(""\n"");
-        return sb.toString();
-    }
-
-    /**
-     * This class allows us to pass the headers and the relevant records around.
-     */
-    static class Packet {
-        RequestHeader header;
-
-        ByteBuffer bb;
-
-        String path;
-
-        ReplyHeader replyHeader;
-
-        Record request;
-
-        Record response;
-
-        boolean finished;
-
-        AsyncCallback cb;
-
-        Object ctx;
-
-        Packet(RequestHeader header, ReplyHeader replyHeader, Record record,
-                Record response, ByteBuffer bb) {
-            this.header = header;
-            this.replyHeader = replyHeader;
-            this.request = record;
-            this.response = response;
-            if (bb != null) {
-                this.bb = bb;
-            } else {
-                try {
-                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                    BinaryOutputArchive boa = BinaryOutputArchive
-                            .getArchive(baos);
-                    boa.writeInt(-1, ""len""); // We'll fill this in later
-                    header.serialize(boa, ""header"");
-                    if (record != null) {
-                        record.serialize(boa, ""request"");
-                    }
-                    baos.close();
-                    this.bb = ByteBuffer.wrap(baos.toByteArray());
-                    this.bb.putInt(this.bb.capacity() - 4);
-                    this.bb.rewind();
-                } catch (IOException e) {
-                    LOG.warn(""Unexpected exception"",e);
-                }
-            }
-        }
-    }
-
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper)
-            throws KeeperException, IOException {
-        this(hosts, sessionTimeout, zooKeeper, 0, new byte[16]);
-    }
-
-    /**
-     * Creates a connection object. The actual network connect doesn't get
-     * established until needed.
-     *
-     * @param hosts
-     *                a comma separated list of hosts that can be connected to.
-     * @param connectTimeout
-     *                the timeout for connections.
-     * @param readTimeout
-     *                the read timeout.
-     * @param zooKeeper
-     *                the zookeeper object that this connection is related to.
-     * @throws KeeperException
-     * @throws IOException
-     */
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
-            long sessionId, byte[] sessionPasswd) throws KeeperException,
-            IOException {
-        this.zooKeeper = zooKeeper;
-        this.sessionId = sessionId;
-        this.sessionPasswd = sessionPasswd;
-        String hostsList[] = hosts.split("","");
-        for (String host : hostsList) {
-            int port = 2181;
-            String parts[] = host.split("":"");
-            if (parts.length > 1) {
-                port = Integer.parseInt(parts[1]);
-                host = parts[0];
-            }
-            InetAddress addrs[] = InetAddress.getAllByName(host);
-            for (InetAddress addr : addrs) {
-                serverAddrs.add(new InetSocketAddress(addr, port));
-            }
-        }
-        this.sessionTimeout = sessionTimeout;
-        connectTimeout = sessionTimeout / hostsList.length;
-        readTimeout = sessionTimeout * 2 / 3;
-        Collections.shuffle(serverAddrs);
-        sendThread = new SendThread();
-        sendThread.start();
-        eventThread = new EventThread();
-        eventThread.start();
-    }
-
-    WatcherEvent eventOfDeath = new WatcherEvent();
-
-    final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
-        public void uncaughtException(Thread t, Throwable e) {
-            LOG.error(""from "" + t.getName(), e);
-        }
-    };
-
-    class EventThread extends Thread {
-        EventThread() {
-            super(""EventThread"");
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
-            setDaemon(true);
-        }
-
-        public void run() {
-            try {
-                while (true) {
-                    Object event = waitingEvents.take();
-                    if (event == eventOfDeath) {
-                        break;
-                    }
-                    if (event instanceof WatcherEvent) {
-                        zooKeeper.watcher.process((WatcherEvent) event);
-                    } else {
-                        Packet p = (Packet) event;
-                        int rc = 0;
-                        String path = p.path;
-                        if (p.replyHeader.getErr() != 0) {
-                            rc = p.replyHeader.getErr();
-                        }
-                        if (p.cb == null) {
-                            LOG.warn(""Somehow a null cb got to EventThread!"");
-                        } else if (p.response instanceof ExistsResponse
-                                || p.response instanceof SetDataResponse
-                                || p.response instanceof SetACLResponse) {
-                            StatCallback cb = (StatCallback) p.cb;
-                            if (rc == 0) {
-                                if (p.response instanceof ExistsResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((ExistsResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetDataResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetDataResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetACLResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetACLResponse) p.response)
-                                                    .getStat());
-                                }
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.response instanceof GetDataResponse) {
-                            DataCallback cb = (DataCallback) p.cb;
-                            GetDataResponse rsp = (GetDataResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx,
-                                        rsp.getData(), rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
-                            }
-                        } else if (p.response instanceof GetACLResponse) {
-                            ACLCallback cb = (ACLCallback) p.cb;
-                            GetACLResponse rsp = (GetACLResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp.getAcl(),
-                                        rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
-                            }
-                        } else if (p.response instanceof GetChildrenResponse) {
-                            ChildrenCallback cb = (ChildrenCallback) p.cb;
-                            GetChildrenResponse rsp = (GetChildrenResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp
-                                        .getChildren());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.response instanceof CreateResponse) {
-                            StringCallback cb = (StringCallback) p.cb;
-                            CreateResponse rsp = (CreateResponse) p.response;
-                            if (rc == 0) {
-                                cb
-                                        .processResult(rc, path, p.ctx, rsp
-                                                .getPath());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.cb instanceof VoidCallback) {
-                            VoidCallback cb = (VoidCallback) p.cb;
-                            cb.processResult(rc, path, p.ctx);
-                        }
-                    }
-                }
-            } catch (InterruptedException e) {
-            }
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    private void finishPacket(Packet p) {
-        p.finished = true;
-        if (p.cb == null) {
-            synchronized (p) {
-                p.notifyAll();
-            }
-        } else {
-            waitingEvents.add(p);
-        }
-    }
-
-    private void conLossPacket(Packet p) {
-        if (p.replyHeader == null) {
-            return;
-        }
-        switch(zooKeeper.state) {
-        case AUTH_FAILED:
-            p.replyHeader.setErr(KeeperException.Code.AuthFailed);
-            break;
-        case CLOSED:
-            p.replyHeader.setErr(KeeperException.Code.SessionExpired);
-            break;
-        default:
-            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
-        }
-        finishPacket(p);
-    }
-
-    long lastZxid;
-
-    /**
-     * This class services the outgoing request queue and generates the heart
-     * beats. It also spawns the ReadThread.
-     */
-    class SendThread extends Thread {
-        SelectionKey sockKey;
-
-        ByteBuffer lenBuffer = ByteBuffer.allocateDirect(4);
-
-        ByteBuffer incomingBuffer = lenBuffer;
-
-        boolean initialized;
-
-        void readLength() throws IOException {
-            int len = incomingBuffer.getInt();
-            if (len < 0 || len >= 4096 * 1024) {
-                throw new IOException(""Packet len"" + len + "" is out of range!"");
-            }
-            incomingBuffer = ByteBuffer.allocate(len);
-        }
-
-        void readConnectResult() throws IOException {
-            ByteBufferInputStream bbis = new ByteBufferInputStream(
-                    incomingBuffer);
-            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
-            ConnectResponse conRsp = new ConnectResponse();
-            conRsp.deserialize(bbia, ""connect"");
-            int sessionTimeout = conRsp.getTimeOut();
-            if (sessionTimeout <= 0) {
-                zooKeeper.state = States.CLOSED;
-                waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
-                        Watcher.Event.KeeperStateExpired, null));
-                throw new IOException(""Session Expired"");
-            }
-            readTimeout = sessionTimeout * 2 / 3;
-            connectTimeout = sessionTimeout / serverAddrs.size();
-            sessionId = conRsp.getSessionId();
-            sessionPasswd = conRsp.getPasswd();
-            waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
-                    Watcher.Event.KeeperStateSyncConnected, null));
-        }
-
-        @SuppressWarnings(""unchecked"")
-        void readResponse() throws IOException {
-            ByteBufferInputStream bbis = new ByteBufferInputStream(
-                    incomingBuffer);
-            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
-            ReplyHeader r = new ReplyHeader();
-
-            r.deserialize(bbia, ""header"");
-            if (r.getXid() == -2) {
-                // -2 is the xid for pings
-                return;
-            }
-            if (r.getXid() == -4) {
-                // -2 is the xid for AuthPacket
-                // TODO: process AuthPacket here
-                return;
-            }
-            if (r.getXid() == -1) {
-                // -1 means notification
-                WatcherEvent event = new WatcherEvent();
-                event.deserialize(bbia, ""response"");
-                // System.out.println(""Got an event: "" + event + "" for "" +
-                // sessionId + "" through"" + _cnxn);
-                waitingEvents.add(event);
-                return;
-            }
-            if (pendingQueue.size() == 0) {
-                throw new IOException(""Nothing in the queue, but got ""
-                        + r.getXid());
-            }
-            Packet p = null;
-            synchronized (pendingQueue) {
-                p = pendingQueue.remove();
-            }
-            /*
-             * Since requests are processed in order, we better get a response
-             * to the first request!
-             */
-            if (p.header.getXid() != r.getXid()) {
-                throw new IOException(""Xid out of order. Got "" + r.getXid()
-                        + "" expected "" + p.header.getXid());
-            }
-            p.replyHeader.setXid(r.getXid());
-            p.replyHeader.setErr(r.getErr());
-            p.replyHeader.setZxid(r.getZxid());
-            lastZxid = r.getZxid();
-            if (p.response != null && r.getErr() == 0) {
-                p.response.deserialize(bbia, ""response"");
-            }
-            p.finished = true;
-            finishPacket(p);
-        }
-
-        /**
-         * @return true if a packet was received
-         * @param k
-         * @throws InterruptedException
-         * @throws IOException
-         */
-        boolean doIO() throws InterruptedException, IOException {
-            boolean packetReceived = false;
-            SocketChannel sock = (SocketChannel) sockKey.channel();
-            if (sock == null) {
-                throw new IOException(""Socket is null!"");
-            }
-            if (sockKey.isReadable()) {
-                int rc = sock.read(incomingBuffer);
-                if (rc < 0) {
-                    throw new IOException(""Read error rc = "" + rc + "" ""
-                            + incomingBuffer);
-                }
-                if (incomingBuffer.remaining() == 0) {
-                    incomingBuffer.flip();
-                    if (incomingBuffer == lenBuffer) {
-                        readLength();
-                    } else if (!initialized) {
-                        readConnectResult();
-                        enableRead();
-                        if (outgoingQueue.size() > 0) {
-                            enableWrite();
-                        }
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                        packetReceived = true;
-                        initialized = true;
-                    } else {
-                        readResponse();
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                        packetReceived = true;
-                    }
-                }
-            }
-            if (sockKey.isWritable()) {
-                synchronized (outgoingQueue) {
-                    if (outgoingQueue.size() > 0) {
-                        int rc = sock.write(outgoingQueue.getFirst().bb);
-                        if (outgoingQueue.getFirst().bb.remaining() == 0) {
-                            Packet p = outgoingQueue.removeFirst();
-                            if (p.header != null
-                                    && p.header.getType() != OpCode.ping
-                                    && p.header.getType() != OpCode.auth) {
-                                pendingQueue.add(p);
-                            }
-                        }
-                    }
-                }
-            }
-            if (outgoingQueue.size() == 0) {
-                disableWrite();
-            } else {
-                enableWrite();
-            }
-            return packetReceived;
-        }
-
-        synchronized private void enableWrite() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_WRITE) == 0) {
-                sockKey.interestOps(i | SelectionKey.OP_WRITE);
-            }
-        }
-
-        synchronized private void disableWrite() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_WRITE) != 0) {
-                sockKey.interestOps(i & (~SelectionKey.OP_WRITE));
-            }
-        }
-
-        synchronized private void enableRead() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_READ) == 0) {
-                sockKey.interestOps(i | SelectionKey.OP_READ);
-            }
-        }
-
-        synchronized private void disableRead() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_READ) != 0) {
-                sockKey.interestOps(i & (~SelectionKey.OP_READ));
-            }
-        }
-
-        SendThread() {
-            super(""SendThread"");
-            zooKeeper.state = States.CONNECTING;
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
-            setDaemon(true);
-        }
-
-        private void primeConnection(SelectionKey k) throws IOException {
-            LOG.info(""Priming connection to ""
-                    + ((SocketChannel) sockKey.channel()));
-            lastConnectIndex = currentConnectIndex;
-            ConnectRequest conReq = new ConnectRequest(0, lastZxid,
-                    sessionTimeout, sessionId, sessionPasswd);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
-            boa.writeInt(-1, ""len"");
-            conReq.serialize(boa, ""connect"");
-            baos.close();
-            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
-            bb.putInt(bb.capacity() - 4);
-            bb.rewind();
-            synchronized (outgoingQueue) {
-                for (AuthData id : authInfo) {
-                    outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
-                            OpCode.auth), null, new AuthPacket(0, id.scheme,
-                            id.data), null, null));
-                }
-                outgoingQueue
-                        .addFirst((new Packet(null, null, null, null, bb)));
-            }
-            synchronized (this) {
-                k.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
-            }
-        }
-
-        private void sendPing() {
-            RequestHeader h = new RequestHeader(-2, OpCode.ping);
-            queuePacket(h, null, null, null, null, null, null);
-        }
-
-        int lastConnectIndex = -1;
-
-        int currentConnectIndex;
-
-        Random r = new Random(System.nanoTime());
-
-        private void startConnect() throws IOException {
-            if (lastConnectIndex == -1) {
-                // We don't want to delay the first try at a connect, so we
-                // start with -1 the first time around
-                lastConnectIndex = 0;
-            } else {
-                try {
-                    Thread.sleep(r.nextInt(1000));
-                } catch (InterruptedException e1) {
-                    LOG.warn(""Unexpected exception"", e1);
-                }
-                if (nextAddrToTry == lastConnectIndex) {
-                    try {
-                        // Try not to spin too fast!
-                        Thread.sleep(1000);
-                    } catch (InterruptedException e) {
-                        LOG.warn(""Unexpected exception"", e);
-                    }
-                }
-            }
-            zooKeeper.state = States.CONNECTING;
-            currentConnectIndex = nextAddrToTry;
-            InetSocketAddress addr = serverAddrs.get(nextAddrToTry);
-            nextAddrToTry++;
-            if (nextAddrToTry == serverAddrs.size()) {
-                nextAddrToTry = 0;
-            }
-            SocketChannel sock;
-            sock = SocketChannel.open();
-            sock.configureBlocking(false);
-            sock.socket().setSoLinger(false, -1);
-            sock.socket().setTcpNoDelay(true);
-            LOG.info(""Attempting connection to server "" + addr);
-            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-            if (sock.connect(addr)) {
-                primeConnection(sockKey);
-            }
-            initialized = false;
-        }
-
-        @Override
-        public void run() {
-            long now = System.currentTimeMillis();
-            long lastHeard = now;
-            long lastSend = now;
-            while (zooKeeper.state.isAlive()) {
-                try {
-                    if (sockKey == null) {
-                        startConnect();
-                        lastSend = now;
-                        lastHeard = now;
-                    }
-                    int idleRecv = (int) (now - lastHeard);
-                    int idleSend = (int) (now - lastSend);
-                    int to = readTimeout - idleRecv;
-                    if (zooKeeper.state != States.CONNECTED) {
-                        to = connectTimeout - idleRecv;
-                    }
-                    if (to <= 0) {
-                        throw new IOException(""TIMED OUT"");
-                    }
-                    if (zooKeeper.state == States.CONNECTED) {
-                        int timeToNextPing = readTimeout/2 - idleSend;
-                        if (timeToNextPing <= 0) {
-                            sendPing();
-                            lastSend = now;
-                            enableWrite();
-                        } else {
-                            if (timeToNextPing < to) {
-                                to = timeToNextPing;
-                            }
-                        }
-                    }
-
-                    selector.select(to);
-                    Set<SelectionKey> selected;
-                    synchronized (this) {
-                        selected = selector.selectedKeys();
-                    }
-                    // Everything below and until we get back to the select is
-                    // non blocking, so time is effectively a constant. That is
-                    // Why we just have to do this once, here
-                    now = System.currentTimeMillis();
-                    for (SelectionKey k : selected) {
-                        SocketChannel sc = ((SocketChannel) k.channel());
-                        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
-                            if (sc.finishConnect()) {
-                                zooKeeper.state = States.CONNECTED;
-                                lastHeard = now;
-                                lastSend = now;
-                                primeConnection(k);
-                                LOG.info(""Server connection successful"");
-                            }
-                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
-                            if (outgoingQueue.size() > 0) {
-                                // We have something to send so it's the same
-                                // as if we do the send now.
-                                lastSend = now;
-                            }
-                            if (doIO()) {
-                                lastHeard = now;
-                            }
-                        }
-                    }
-                    if (zooKeeper.state == States.CONNECTED) {
-                        if (outgoingQueue.size() > 0) {
-                            enableWrite();
-                        } else {
-                            disableWrite();
-                        }
-                    }
-                    selected.clear();
-                } catch (Exception e) {
-                    LOG.warn(""Closing: "", e);
-                    cleanup();
-                    if (zooKeeper.state.isAlive()) {
-                        waitingEvents.add(new WatcherEvent(Event.EventNone,
-                                Event.KeeperStateDisconnected, null));
-                    }
-
-                    now = System.currentTimeMillis();
-                    lastHeard = now;
-                    lastSend = now;
-                }
-            }
-            cleanup();
-            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""SendThread exitedloop."");
-        }
-
-        private void cleanup() {
-            if (sockKey != null) {
-                SocketChannel sock = (SocketChannel) sockKey.channel();
-                sockKey.cancel();
-                try {
-                    sock.socket().shutdownInput();
-                } catch (IOException e2) {
-                }
-                try {
-                    sock.socket().shutdownOutput();
-                } catch (IOException e2) {
-                }
-                try {
-                    sock.socket().close();
-                } catch (IOException e1) {
-                }
-                try {
-                    sock.close();
-                } catch (IOException e1) {
-                }
-            }
-            try {
-                Thread.sleep(100);
-            } catch (InterruptedException e1) {
-                e1.printStackTrace();
-            }
-            sockKey = null;
-            synchronized (pendingQueue) {
-                for (Packet p : pendingQueue) {
-                    conLossPacket(p);
-                }
-                pendingQueue.clear();
-            }
-            synchronized (outgoingQueue) {
-                for (Packet p : outgoingQueue) {
-                    conLossPacket(p);
-                }
-                outgoingQueue.clear();
-            }
-        }
-
-        public void close() {
-            zooKeeper.state = States.CLOSED;
-            synchronized (this) {
-                selector.wakeup();
-            }
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    public void close() throws IOException {
-        long traceMask = ZooTrace.SESSION_TRACE_MASK;
-        if (ZooTrace.isTraceEnabled(LOG, traceMask)) {
-            ZooTrace.logTraceMessage(LOG, traceMask,
-                    ""Close ClientCnxn for session: "" + sessionId + ""!"");
-        }
-        sendThread.close();
-        waitingEvents.add(eventOfDeath);
-    }
-
-    private int xid = 1;
-
-    synchronized private int getXid() {
-        return xid++;
-    }
-
-    public ReplyHeader submitRequest(RequestHeader h, Record request,
-            Record response) throws InterruptedException {
-        ReplyHeader r = new ReplyHeader();
-        Packet packet = queuePacket(h, r, request, response, null, null, null);
-        synchronized (packet) {
-            while (!packet.finished) {
-                packet.wait();
-            }
-        }
-        return r;
-    }
-
-    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
-            Record response, AsyncCallback cb, String path, Object ctx) {
-        Packet packet = null;
-        synchronized (outgoingQueue) {
-            if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
-                h.setXid(getXid());
-            }
-            packet = new Packet(h, r, request, response, null);
-            packet.cb = cb;
-            packet.ctx = ctx;
-            packet.path = path;
-            if (!zooKeeper.state.isAlive()) {
-                conLossPacket(packet);
-            } else {
-                outgoingQueue.add(packet);
-            }
-        }
-        synchronized (sendThread) {
-            selector.wakeup();
-        }
-        return packet;
-    }
-
-    public void addAuthInfo(String scheme, byte auth[]) {
-        authInfo.add(new AuthData(scheme, auth));
-        if (zooKeeper.state == States.CONNECTED) {
-            queuePacket(new RequestHeader(-4, OpCode.auth), null,
-                    new AuthPacket(0, scheme, auth), null, null, null, null);
-        }
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
+import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
+import com.yahoo.zookeeper.AsyncCallback.DataCallback;
+import com.yahoo.zookeeper.AsyncCallback.StatCallback;
+import com.yahoo.zookeeper.AsyncCallback.StringCallback;
+import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
+import com.yahoo.zookeeper.Watcher.Event;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.ZooKeeper.States;
+import com.yahoo.zookeeper.proto.AuthPacket;
+import com.yahoo.zookeeper.proto.ConnectRequest;
+import com.yahoo.zookeeper.proto.ConnectResponse;
+import com.yahoo.zookeeper.proto.CreateResponse;
+import com.yahoo.zookeeper.proto.ExistsResponse;
+import com.yahoo.zookeeper.proto.GetACLResponse;
+import com.yahoo.zookeeper.proto.GetChildrenResponse;
+import com.yahoo.zookeeper.proto.GetDataResponse;
+import com.yahoo.zookeeper.proto.ReplyHeader;
+import com.yahoo.zookeeper.proto.RequestHeader;
+import com.yahoo.zookeeper.proto.SetACLResponse;
+import com.yahoo.zookeeper.proto.SetDataResponse;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.ByteBufferInputStream;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooTrace;
+
+/**
+ * This class manages the socket i/o for the client. ClientCnxn maintains a list
+ * of available servers to connect to and ""transparently"" switches servers it is
+ * connected to as needed.
+ *
+ */
+class ClientCnxn {
+    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
+
+    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
+
+    static class AuthData {
+        AuthData(String scheme, byte data[]) {
+            this.scheme = scheme;
+            this.data = data;
+        }
+
+        String scheme;
+
+        byte data[];
+    }
+
+    private ArrayList<AuthData> authInfo = new ArrayList<AuthData>();
+
+    /**
+     * These are the packets that have been sent and are waiting for a response.
+     */
+    private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
+
+    private LinkedBlockingQueue waitingEvents = new LinkedBlockingQueue();
+
+    /**
+     * These are the packets that need to be sent.
+     */
+    private LinkedList<Packet> outgoingQueue = new LinkedList<Packet>();
+
+    private int nextAddrToTry = 0;
+
+    private int connectTimeout;
+
+    private int readTimeout;
+
+    private final int sessionTimeout;
+
+    private final ZooKeeper zooKeeper;
+
+    private long sessionId;
+
+    private byte sessionPasswd[] = new byte[16];
+
+    final SendThread sendThread;
+
+    final EventThread eventThread;
+
+    final Selector selector = Selector.open();
+
+    public long getSessionId() {
+        return sessionId;
+    }
+
+    public byte[] getSessionPasswd() {
+        return sessionPasswd;
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(""sessionId: "").append(sessionId).append(""\n"");
+        sb.append(""lastZxid: "").append(lastZxid).append(""\n"");
+        sb.append(""xid: "").append(xid).append(""\n"");
+        sb.append(""nextAddrToTry: "").append(nextAddrToTry).append(""\n"");
+        sb.append(""serverAddrs: "").append(serverAddrs.get(nextAddrToTry))
+                .append(""\n"");
+        return sb.toString();
+    }
+
+    /**
+     * This class allows us to pass the headers and the relevant records around.
+     */
+    static class Packet {
+        RequestHeader header;
+
+        ByteBuffer bb;
+
+        String path;
+
+        ReplyHeader replyHeader;
+
+        Record request;
+
+        Record response;
+
+        boolean finished;
+
+        AsyncCallback cb;
+
+        Object ctx;
+
+        Packet(RequestHeader header, ReplyHeader replyHeader, Record record,
+                Record response, ByteBuffer bb) {
+            this.header = header;
+            this.replyHeader = replyHeader;
+            this.request = record;
+            this.response = response;
+            if (bb != null) {
+                this.bb = bb;
+            } else {
+                try {
+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                    BinaryOutputArchive boa = BinaryOutputArchive
+                            .getArchive(baos);
+                    boa.writeInt(-1, ""len""); // We'll fill this in later
+                    header.serialize(boa, ""header"");
+                    if (record != null) {
+                        record.serialize(boa, ""request"");
+                    }
+                    baos.close();
+                    this.bb = ByteBuffer.wrap(baos.toByteArray());
+                    this.bb.putInt(this.bb.capacity() - 4);
+                    this.bb.rewind();
+                } catch (IOException e) {
+                    LOG.warn(""Unexpected exception"",e);
+                }
+            }
+        }
+    }
+
+    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper)
+            throws IOException {
+        this(hosts, sessionTimeout, zooKeeper, 0, new byte[16]);
+    }
+
+    /**
+     * Creates a connection object. The actual network connect doesn't get
+     * established until needed.
+     *
+     * @param hosts
+     *                a comma separated list of hosts that can be connected to.
+     * @param sessionTimeout
+     *                the timeout for connections.
+     * @param zooKeeper
+     *                the zookeeper object that this connection is related to.
+     * @throws KeeperException
+     * @throws IOException
+     */
+    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
+            long sessionId, byte[] sessionPasswd) throws IOException {
+        this.zooKeeper = zooKeeper;
+        this.sessionId = sessionId;
+        this.sessionPasswd = sessionPasswd;
+        String hostsList[] = hosts.split("","");
+        for (String host : hostsList) {
+            int port = 2181;
+            String parts[] = host.split("":"");
+            if (parts.length > 1) {
+                port = Integer.parseInt(parts[1]);
+                host = parts[0];
+            }
+            InetAddress addrs[] = InetAddress.getAllByName(host);
+            for (InetAddress addr : addrs) {
+                serverAddrs.add(new InetSocketAddress(addr, port));
+            }
+        }
+        this.sessionTimeout = sessionTimeout;
+        connectTimeout = sessionTimeout / hostsList.length;
+        readTimeout = sessionTimeout * 2 / 3;
+        Collections.shuffle(serverAddrs);
+        sendThread = new SendThread();
+        sendThread.start();
+        eventThread = new EventThread();
+        eventThread.start();
+    }
+
+    WatcherEvent eventOfDeath = new WatcherEvent();
+
+    final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
+        public void uncaughtException(Thread t, Throwable e) {
+            LOG.error(""from "" + t.getName(), e);
+        }
+    };
+
+    class EventThread extends Thread {
+        EventThread() {
+            super(""EventThread"");
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
+            setDaemon(true);
+        }
+
+        public void run() {
+            try {
+                while (true) {
+                    Object event = waitingEvents.take();
+                    if (event == eventOfDeath) {
+                        break;
+                    }
+                    if (event instanceof WatcherEvent) {
+                        zooKeeper.watcher.process((WatcherEvent) event);
+                    } else {
+                        Packet p = (Packet) event;
+                        int rc = 0;
+                        String path = p.path;
+                        if (p.replyHeader.getErr() != 0) {
+                            rc = p.replyHeader.getErr();
+                        }
+                        if (p.cb == null) {
+                            LOG.warn(""Somehow a null cb got to EventThread!"");
+                        } else if (p.response instanceof ExistsResponse
+                                || p.response instanceof SetDataResponse
+                                || p.response instanceof SetACLResponse) {
+                            StatCallback cb = (StatCallback) p.cb;
+                            if (rc == 0) {
+                                if (p.response instanceof ExistsResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((ExistsResponse) p.response)
+                                                    .getStat());
+                                } else if (p.response instanceof SetDataResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((SetDataResponse) p.response)
+                                                    .getStat());
+                                } else if (p.response instanceof SetACLResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((SetACLResponse) p.response)
+                                                    .getStat());
+                                }
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.response instanceof GetDataResponse) {
+                            DataCallback cb = (DataCallback) p.cb;
+                            GetDataResponse rsp = (GetDataResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx,
+                                        rsp.getData(), rsp.getStat());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null, null);
+                            }
+                        } else if (p.response instanceof GetACLResponse) {
+                            ACLCallback cb = (ACLCallback) p.cb;
+                            GetACLResponse rsp = (GetACLResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx, rsp.getAcl(),
+                                        rsp.getStat());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null, null);
+                            }
+                        } else if (p.response instanceof GetChildrenResponse) {
+                            ChildrenCallback cb = (ChildrenCallback) p.cb;
+                            GetChildrenResponse rsp = (GetChildrenResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx, rsp
+                                        .getChildren());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.response instanceof CreateResponse) {
+                            StringCallback cb = (StringCallback) p.cb;
+                            CreateResponse rsp = (CreateResponse) p.response;
+                            if (rc == 0) {
+                                cb
+                                        .processResult(rc, path, p.ctx, rsp
+                                                .getPath());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.cb instanceof VoidCallback) {
+                            VoidCallback cb = (VoidCallback) p.cb;
+                            cb.processResult(rc, path, p.ctx);
+                        }
+                    }
+                }
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private void finishPacket(Packet p) {
+        p.finished = true;
+        if (p.cb == null) {
+            synchronized (p) {
+                p.notifyAll();
+            }
+        } else {
+            waitingEvents.add(p);
+        }
+    }
+
+    private void conLossPacket(Packet p) {
+        if (p.replyHeader == null) {
+            return;
+        }
+        switch(zooKeeper.state) {
+        case AUTH_FAILED:
+            p.replyHeader.setErr(KeeperException.Code.AuthFailed);
+            break;
+        case CLOSED:
+            p.replyHeader.setErr(KeeperException.Code.SessionExpired);
+            break;
+        default:
+            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
+        }
+        finishPacket(p);
+    }
+
+    long lastZxid;
+
+    /**
+     * This class services the outgoing request queue and generates the heart
+     * beats. It also spawns the ReadThread.
+     */
+    class SendThread extends Thread {
+        SelectionKey sockKey;
+
+        ByteBuffer lenBuffer = ByteBuffer.allocateDirect(4);
+
+        ByteBuffer incomingBuffer = lenBuffer;
+
+        boolean initialized;
+
+        void readLength() throws IOException {
+            int len = incomingBuffer.getInt();
+            if (len < 0 || len >= 4096 * 1024) {
+                throw new IOException(""Packet len"" + len + "" is out of range!"");
+            }
+            incomingBuffer = ByteBuffer.allocate(len);
+        }
+
+        void readConnectResult() throws IOException {
+            ByteBufferInputStream bbis = new ByteBufferInputStream(
+                    incomingBuffer);
+            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
+            ConnectResponse conRsp = new ConnectResponse();
+            conRsp.deserialize(bbia, ""connect"");
+            int sessionTimeout = conRsp.getTimeOut();
+            if (sessionTimeout <= 0) {
+                zooKeeper.state = States.CLOSED;
+                waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+                        Watcher.Event.KeeperStateExpired, null));
+                throw new IOException(""Session Expired"");
+            }
+            readTimeout = sessionTimeout * 2 / 3;
+            connectTimeout = sessionTimeout / serverAddrs.size();
+            sessionId = conRsp.getSessionId();
+            sessionPasswd = conRsp.getPasswd();
+            waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+                    Watcher.Event.KeeperStateSyncConnected, null));
+        }
+
+        @SuppressWarnings(""unchecked"")
+        void readResponse() throws IOException {
+            ByteBufferInputStream bbis = new ByteBufferInputStream(
+                    incomingBuffer);
+            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
+            ReplyHeader r = new ReplyHeader();
+
+            r.deserialize(bbia, ""header"");
+            if (r.getXid() == -2) {
+                // -2 is the xid for pings
+                return;
+            }
+            if (r.getXid() == -4) {
+                // -2 is the xid for AuthPacket
+                // TODO: process AuthPacket here
+                return;
+            }
+            if (r.getXid() == -1) {
+                // -1 means notification
+                WatcherEvent event = new WatcherEvent();
+                event.deserialize(bbia, ""response"");
+                // System.out.println(""Got an event: "" + event + "" for "" +
+                // sessionId + "" through"" + _cnxn);
+                waitingEvents.add(event);
+                return;
+            }
+            if (pendingQueue.size() == 0) {
+                throw new IOException(""Nothing in the queue, but got ""
+                        + r.getXid());
+            }
+            Packet p = null;
+            synchronized (pendingQueue) {
+                p = pendingQueue.remove();
+            }
+            /*
+             * Since requests are processed in order, we better get a response
+             * to the first request!
+             */
+            if (p.header.getXid() != r.getXid()) {
+                throw new IOException(""Xid out of order. Got "" + r.getXid()
+                        + "" expected "" + p.header.getXid());
+            }
+            p.replyHeader.setXid(r.getXid());
+            p.replyHeader.setErr(r.getErr());
+            p.replyHeader.setZxid(r.getZxid());
+            lastZxid = r.getZxid();
+            if (p.response != null && r.getErr() == 0) {
+                p.response.deserialize(bbia, ""response"");
+            }
+            p.finished = true;
+            finishPacket(p);
+        }
+
+        /**
+         * @return true if a packet was received
+         * @throws InterruptedException
+         * @throws IOException
+         */
+        boolean doIO() throws InterruptedException, IOException {
+            boolean packetReceived = false;
+            SocketChannel sock = (SocketChannel) sockKey.channel();
+            if (sock == null) {
+                throw new IOException(""Socket is null!"");
+            }
+            if (sockKey.isReadable()) {
+                int rc = sock.read(incomingBuffer);
+                if (rc < 0) {
+                    throw new IOException(""Read error rc = "" + rc + "" ""
+                            + incomingBuffer);
+                }
+                if (incomingBuffer.remaining() == 0) {
+                    incomingBuffer.flip();
+                    if (incomingBuffer == lenBuffer) {
+                        readLength();
+                    } else if (!initialized) {
+                        readConnectResult();
+                        enableRead();
+                        if (outgoingQueue.size() > 0) {
+                            enableWrite();
+                        }
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                        packetReceived = true;
+                        initialized = true;
+                    } else {
+                        readResponse();
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                        packetReceived = true;
+                    }
+                }
+            }
+            if (sockKey.isWritable()) {
+                synchronized (outgoingQueue) {
+                    if (outgoingQueue.size() > 0) {
+                        int rc = sock.write(outgoingQueue.getFirst().bb);
+                        if (outgoingQueue.getFirst().bb.remaining() == 0) {
+                            Packet p = outgoingQueue.removeFirst();
+                            if (p.header != null
+                                    && p.header.getType() != OpCode.ping
+                                    && p.header.getType() != OpCode.auth) {
+                                pendingQueue.add(p);
+                            }
+                        }
+                    }
+                }
+            }
+            if (outgoingQueue.size() == 0) {
+                disableWrite();
+            } else {
+                enableWrite();
+            }
+            return packetReceived;
+        }
+
+        synchronized private void enableWrite() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_WRITE) == 0) {
+                sockKey.interestOps(i | SelectionKey.OP_WRITE);
+            }
+        }
+
+        synchronized private void disableWrite() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_WRITE) != 0) {
+                sockKey.interestOps(i & (~SelectionKey.OP_WRITE));
+            }
+        }
+
+        synchronized private void enableRead() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_READ) == 0) {
+                sockKey.interestOps(i | SelectionKey.OP_READ);
+            }
+        }
+
+        synchronized private void disableRead() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_READ) != 0) {
+                sockKey.interestOps(i & (~SelectionKey.OP_READ));
+            }
+        }
+
+        SendThread() {
+            super(""SendThread"");
+            zooKeeper.state = States.CONNECTING;
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
+            setDaemon(true);
+        }
+
+        private void primeConnection(SelectionKey k) throws IOException {
+            LOG.info(""Priming connection to ""
+                    + ((SocketChannel) sockKey.channel()));
+            lastConnectIndex = currentConnectIndex;
+            ConnectRequest conReq = new ConnectRequest(0, lastZxid,
+                    sessionTimeout, sessionId, sessionPasswd);
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+            boa.writeInt(-1, ""len"");
+            conReq.serialize(boa, ""connect"");
+            baos.close();
+            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
+            bb.putInt(bb.capacity() - 4);
+            bb.rewind();
+            synchronized (outgoingQueue) {
+                for (AuthData id : authInfo) {
+                    outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
+                            OpCode.auth), null, new AuthPacket(0, id.scheme,
+                            id.data), null, null));
+                }
+                outgoingQueue
+                        .addFirst((new Packet(null, null, null, null, bb)));
+            }
+            synchronized (this) {
+                k.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
+            }
+        }
+
+        private void sendPing() {
+            RequestHeader h = new RequestHeader(-2, OpCode.ping);
+            queuePacket(h, null, null, null, null, null, null);
+        }
+
+        int lastConnectIndex = -1;
+
+        int currentConnectIndex;
+
+        Random r = new Random(System.nanoTime());
+
+        private void startConnect() throws IOException {
+            if (lastConnectIndex == -1) {
+                // We don't want to delay the first try at a connect, so we
+                // start with -1 the first time around
+                lastConnectIndex = 0;
+            } else {
+                try {
+                    Thread.sleep(r.nextInt(1000));
+                } catch (InterruptedException e1) {
+                    LOG.warn(""Unexpected exception"", e1);
+                }
+                if (nextAddrToTry == lastConnectIndex) {
+                    try {
+                        // Try not to spin too fast!
+                        Thread.sleep(1000);
+                    } catch (InterruptedException e) {
+                        LOG.warn(""Unexpected exception"", e);
+                    }
+                }
+            }
+            zooKeeper.state = States.CONNECTING;
+            currentConnectIndex = nextAddrToTry;
+            InetSocketAddress addr = serverAddrs.get(nextAddrToTry);
+            nextAddrToTry++;
+            if (nextAddrToTry == serverAddrs.size()) {
+                nextAddrToTry = 0;
+            }
+            SocketChannel sock;
+            sock = SocketChannel.open();
+            sock.configureBlocking(false);
+            sock.socket().setSoLinger(false, -1);
+            sock.socket().setTcpNoDelay(true);
+            LOG.info(""Attempting connection to server "" + addr);
+            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
+            if (sock.connect(addr)) {
+                primeConnection(sockKey);
+            }
+            initialized = false;
+        }
+
+        @Override
+        public void run() {
+            long now = System.currentTimeMillis();
+            long lastHeard = now;
+            long lastSend = now;
+            while (zooKeeper.state.isAlive()) {
+                try {
+                    if (sockKey == null) {
+                        startConnect();
+                        lastSend = now;
+                        lastHeard = now;
+                    }
+                    int idleRecv = (int) (now - lastHeard);
+                    int idleSend = (int) (now - lastSend);
+                    int to = readTimeout - idleRecv;
+                    if (zooKeeper.state != States.CONNECTED) {
+                        to = connectTimeout - idleRecv;
+                    }
+                    if (to <= 0) {
+                        throw new IOException(""TIMED OUT"");
+                    }
+                    if (zooKeeper.state == States.CONNECTED) {
+                        int timeToNextPing = readTimeout/2 - idleSend;
+                        if (timeToNextPing <= 0) {
+                            sendPing();
+                            lastSend = now;
+                            enableWrite();
+                        } else {
+                            if (timeToNextPing < to) {
+                                to = timeToNextPing;
+                            }
+                        }
+                    }
+
+                    selector.select(to);
+                    Set<SelectionKey> selected;
+                    synchronized (this) {
+                        selected = selector.selectedKeys();
+                    }
+                    // Everything below and until we get back to the select is
+                    // non blocking, so time is effectively a constant. That is
+                    // Why we just have to do this once, here
+                    now = System.currentTimeMillis();
+                    for (SelectionKey k : selected) {
+                        SocketChannel sc = ((SocketChannel) k.channel());
+                        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
+                            if (sc.finishConnect()) {
+                                zooKeeper.state = States.CONNECTED;
+                                lastHeard = now;
+                                lastSend = now;
+                                primeConnection(k);
+                                LOG.info(""Server connection successful"");
+                            }
+                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
+                            if (outgoingQueue.size() > 0) {
+                                // We have something to send so it's the same
+                                // as if we do the send now.
+                                lastSend = now;
+                            }
+                            if (doIO()) {
+                                lastHeard = now;
+                            }
+                        }
+                    }
+                    if (zooKeeper.state == States.CONNECTED) {
+                        if (outgoingQueue.size() > 0) {
+                            enableWrite();
+                        } else {
+                            disableWrite();
+                        }
+                    }
+                    selected.clear();
+                } catch (Exception e) {
+                    LOG.warn(""Closing: "", e);
+                    cleanup();
+                    if (zooKeeper.state.isAlive()) {
+                        waitingEvents.add(new WatcherEvent(Event.EventNone,
+                                Event.KeeperStateDisconnected, null));
+                    }
+
+                    now = System.currentTimeMillis();
+                    lastHeard = now;
+                    lastSend = now;
+                }
+            }
+            cleanup();
+            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""SendThread exitedloop."");
+        }
+
+        private void cleanup() {
+            if (sockKey != null) {
+                SocketChannel sock = (SocketChannel) sockKey.channel();
+                sockKey.cancel();
+                try {
+                    sock.socket().shutdownInput();
+                } catch (IOException e2) {
+                }
+                try {
+                    sock.socket().shutdownOutput();
+                } catch (IOException e2) {
+                }
+                try {
+                    sock.socket().close();
+                } catch (IOException e1) {
+                }
+                try {
+                    sock.close();
+                } catch (IOException e1) {
+                }
+            }
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e1) {
+                e1.printStackTrace();
+            }
+            sockKey = null;
+            synchronized (pendingQueue) {
+                for (Packet p : pendingQueue) {
+                    conLossPacket(p);
+                }
+                pendingQueue.clear();
+            }
+            synchronized (outgoingQueue) {
+                for (Packet p : outgoingQueue) {
+                    conLossPacket(p);
+                }
+                outgoingQueue.clear();
+            }
+        }
+
+        public void close() {
+            zooKeeper.state = States.CLOSED;
+            synchronized (this) {
+                selector.wakeup();
+            }
+        }
+    }
+
+    @SuppressWarnings(""unchecked"")
+    public void close() throws IOException {
+        long traceMask = ZooTrace.SESSION_TRACE_MASK;
+        if (ZooTrace.isTraceEnabled(LOG, traceMask)) {
+            ZooTrace.logTraceMessage(LOG, traceMask,
+                    ""Close ClientCnxn for session: "" + sessionId + ""!"");
+        }
+        sendThread.close();
+        waitingEvents.add(eventOfDeath);
+    }
+
+    private int xid = 1;
+
+    synchronized private int getXid() {
+        return xid++;
+    }
+
+    public ReplyHeader submitRequest(RequestHeader h, Record request,
+            Record response) throws InterruptedException {
+        ReplyHeader r = new ReplyHeader();
+        Packet packet = queuePacket(h, r, request, response, null, null, null);
+        synchronized (packet) {
+            while (!packet.finished) {
+                packet.wait();
+            }
+        }
+        return r;
+    }
+
+    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
+            Record response, AsyncCallback cb, String path, Object ctx) {
+        Packet packet = null;
+        synchronized (outgoingQueue) {
+            if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
+                h.setXid(getXid());
+            }
+            packet = new Packet(h, r, request, response, null);
+            packet.cb = cb;
+            packet.ctx = ctx;
+            packet.path = path;
+            if (!zooKeeper.state.isAlive()) {
+                conLossPacket(packet);
+            } else {
+                outgoingQueue.add(packet);
+            }
+        }
+        synchronized (sendThread) {
+            selector.wakeup();
+        }
+        return packet;
+    }
+
+    public void addAuthInfo(String scheme, byte auth[]) {
+        authInfo.add(new AuthData(scheme, auth));
+        if (zooKeeper.state == States.CONNECTED) {
+            queuePacket(new RequestHeader(-4, OpCode.auth), null,
+                    new AuthPacket(0, scheme, auth), null, null, null, null);
+        }
+    }
+}
",,6461
2236,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/DataTree.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,202,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,220,,,,,"            node.parent = null;",,,6461
2237,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/DataTree.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,509,418a0392faf93494847798aea255d6503586a410,1206576385,516,,,,,"        root = null;",,,6461
2238,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/NIOServerCnxn.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,696,a6bc7d54791e73b06083996ab57fdba9340ae1aa,1210283432,695,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,-1,1210382051/1194064875,"        sock = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.CancelledKeyException;
-import java.nio.channels.Channel;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.ServerSocketChannel;
-import java.nio.channels.SocketChannel;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Set;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.KeeperException;
-import com.yahoo.zookeeper.Version;
-import com.yahoo.zookeeper.Watcher;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.data.Id;
-import com.yahoo.zookeeper.proto.AuthPacket;
-import com.yahoo.zookeeper.proto.ConnectRequest;
-import com.yahoo.zookeeper.proto.ConnectResponse;
-import com.yahoo.zookeeper.proto.ReplyHeader;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.auth.AuthenticationProvider;
-import com.yahoo.zookeeper.server.auth.ProviderRegistry;
-
-/**
- * This class handles communication with clients using NIO. There is one per
- * client, but only one thread doing the communication.
- */
-public class NIOServerCnxn implements Watcher, ServerCnxn {
-    private static final Logger LOG = Logger.getLogger(NIOServerCnxn.class);
-
-    static public class Factory extends Thread {
-        ZooKeeperServer zks;
-
-        ServerSocketChannel ss;
-
-        Selector selector = Selector.open();
-
-        /**
-         * We use this buffer to do efficient socket I/O. Since there is a single
-         * sender thread per NIOServerCnxn instance, we can use a member variable to
-         * only allocate it once.
-        */
-        ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);
-
-        HashSet<NIOServerCnxn> cnxns = new HashSet<NIOServerCnxn>();
-
-        int outstandingLimit = 1;
-
-        public Factory(int port) throws IOException {
-            super(""NIOServerCxn.Factory"");
-            setDaemon(true);
-            this.ss = ServerSocketChannel.open();
-            ss.socket().bind(new InetSocketAddress(port));
-            ss.configureBlocking(false);
-            ss.register(selector, SelectionKey.OP_ACCEPT);
-            start();
-        }
-
-        public void startup(ZooKeeperServer zks) throws IOException,
-                InterruptedException {
-            zks.startup();
-            setZooKeeperServer(zks);
-        }
-
-        public void setZooKeeperServer(ZooKeeperServer zks) {
-            this.zks = zks;
-            if (zks != null) {
-                this.outstandingLimit = zks.getGlobalOutstandingLimit();
-                zks.setServerCnxnFactory(this);
-            } else {
-                this.outstandingLimit = 1;
-            }
-        }
-
-        public InetSocketAddress getLocalAddress(){
-            return (InetSocketAddress)ss.socket().getLocalSocketAddress();
-        }
-
-        private void addCnxn(NIOServerCnxn cnxn) {
-            synchronized (cnxns) {
-                cnxns.add(cnxn);
-            }
-        }
-
-        protected NIOServerCnxn createConnection(SocketChannel sock,
-                SelectionKey sk) throws IOException {
-            return new NIOServerCnxn(zks, sock, sk, this);
-        }
-
-        public void run() {
-            while (!ss.socket().isClosed()) {
-                try {
-                    selector.select(1000);
-                    Set<SelectionKey> selected;
-                    synchronized (this) {
-                        selected = selector.selectedKeys();
-                    }
-                    ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(
-                            selected);
-                    Collections.shuffle(selectedList);
-                    for (SelectionKey k : selectedList) {
-                        if ((k.readyOps() & SelectionKey.OP_ACCEPT) != 0) {
-                            SocketChannel sc = ((ServerSocketChannel) k
-                                    .channel()).accept();
-                            sc.configureBlocking(false);
-                            SelectionKey sk = sc.register(selector,
-                                    SelectionKey.OP_READ);
-                            NIOServerCnxn cnxn = createConnection(sc, sk);
-                            sk.attach(cnxn);
-                            addCnxn(cnxn);
-                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
-                            NIOServerCnxn c = (NIOServerCnxn) k.attachment();
-                            c.doIO(k);
-                        }
-                    }
-                    selected.clear();
-                } catch (Exception e) {
-                    LOG.error(""FIXMSG"",e);
-                }
-            }
-            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""NIOServerCnxn factory exitedloop."");
-            clear();
-            LOG.error(""=====> Goodbye cruel world <======"");
-            // System.exit(0);
-        }
-
-        /**
-         * clear all the connections in the selector
-         *
-         */
-        synchronized public void clear() {
-            selector.wakeup();
-            synchronized (cnxns) {
-                // got to clear all the connections that we have in the selector
-                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
-                        .hasNext();) {
-                    NIOServerCnxn cnxn = it.next();
-                    it.remove();
-                    try {
-                        cnxn.close();
-                    } catch (Exception e) {
-                        // Do nothing.
-                    }
-                }
-            }
-
-        }
-
-        public void shutdown() {
-            try {
-                ss.close();
-                clear();
-                this.interrupt();
-                this.join();
-            } catch (InterruptedException e) {
-            } catch (Exception e) {
-                LOG.error(""FIXMSG"",e);
-            }
-            if (zks != null) {
-                zks.shutdown();
-            }
-        }
-
-        synchronized void closeSession(long sessionId) {
-            selector.wakeup();
-            synchronized (cnxns) {
-                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
-                        .hasNext();) {
-                    NIOServerCnxn cnxn = it.next();
-                    if (cnxn.sessionId == sessionId) {
-                        it.remove();
-                        try {
-                            cnxn.close();
-                        } catch (Exception e) {
-                        }
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * The buffer will cause the connection to be close when we do a send.
-     */
-    static final ByteBuffer closeConn = ByteBuffer.allocate(0);
-
-    Factory factory;
-
-    ZooKeeperServer zk;
-
-    private SocketChannel sock;
-
-    private SelectionKey sk;
-
-    boolean initialized;
-
-    ByteBuffer lenBuffer = ByteBuffer.allocate(4);
-
-    ByteBuffer incomingBuffer = lenBuffer;
-
-    LinkedBlockingQueue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();
-
-    int sessionTimeout;
-
-    ArrayList<Id> authInfo = new ArrayList<Id>();
-
-    LinkedList<Request> outstanding = new LinkedList<Request>();
-
-    void sendBuffer(ByteBuffer bb) {
-        synchronized (factory) {
-            try {
-                sk.selector().wakeup();
-                // ZooLog.logTraceMessage(LOG,
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
-                // ""Add a buffer to outgoingBuffers"");
-                // ZooLog.logTraceMessage(LOG,
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
-                //""sk "" + sk + "" is valid: "" +
-                // sk.isValid(), );
-                outgoingBuffers.add(bb);
-                if (sk.isValid()) {
-                    sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
-                }
-            } catch (RuntimeException e) {
-                LOG.error(""FIXMSG"",e);
-                throw e;
-            }
-        }
-    }
-
-    void doIO(SelectionKey k) throws InterruptedException {
-        try {
-            if (sock == null) {
-                return;
-            }
-            if (k.isReadable()) {
-                int rc = sock.read(incomingBuffer);
-                if (rc < 0) {
-                    throw new IOException(""Read error"");
-                }
-                if (incomingBuffer.remaining() == 0) {
-                    incomingBuffer.flip();
-                    if (incomingBuffer == lenBuffer) {
-                        readLength(k);
-                    } else if (!initialized) {
-                        stats.packetsReceived++;
-                        ServerStats.getInstance().incrementPacketsReceived();
-                        readConnectRequest();
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                    } else {
-                        stats.packetsReceived++;
-                        ServerStats.getInstance().incrementPacketsReceived();
-                        readRequest();
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                    }
-                }
-            }
-            if (k.isWritable()) {
-                // ZooLog.logTraceMessage(LOG,
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK
-                // ""outgoingBuffers.size() = "" +
-                // outgoingBuffers.size());
-                if (outgoingBuffers.size() > 0) {
-                    // ZooLog.logTraceMessage(LOG,
-                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
-                    // ""sk "" + k + "" is valid: "" +
-                    // k.isValid());
-
-                    /*
-                     * This is going to reset the buffer position to 0 and the
-                     * limit to the size of the buffer, so that we can fill it
-                     * with data from the non-direct buffers that we need to
-                     * send.
-                     */
-                    ByteBuffer directBuffer = factory.directBuffer;
-                    directBuffer.clear();
-
-                    for (ByteBuffer b : outgoingBuffers) {
-                        if (directBuffer.remaining() < b.remaining()) {
-                            /*
-                             * When we call put later, if the directBuffer is to
-                             * small to hold everything, nothing will be copied,
-                             * so we've got to slice the buffer if it's too big.
-                             */
-                            b = (ByteBuffer) b.slice().limit(
-                                    directBuffer.remaining());
-                        }
-                        /*
-                         * put() is going to modify the positions of both
-                         * buffers, put we don't want to change the position of
-                         * the source buffers (we'll do that after the send, if
-                         * needed), so we save and reset the position after the
-                         * copy
-                         */
-                        int p = b.position();
-                        directBuffer.put(b);
-                        b.position(p);
-                        if (directBuffer.remaining() == 0) {
-                            break;
-                        }
-                    }
-                    /*
-                     * Do the flip: limit becomes position, position gets set to
-                     * 0. This sets us up for the write.
-                     */
-                    directBuffer.flip();
-
-                    int sent = sock.write(directBuffer);
-                    ByteBuffer bb;
-
-                    // Remove the buffers that we have sent
-                    while (outgoingBuffers.size() > 0) {
-                        bb = outgoingBuffers.peek();
-                        if (bb == closeConn) {
-                            throw new IOException(""closing"");
-                        }
-                        int left = bb.remaining() - sent;
-                        if (left > 0) {
-                            /*
-                             * We only partially sent this buffer, so we update
-                             * the position and exit the loop.
-                             */
-                            bb.position(bb.position() + sent);
-                            break;
-                        }
-                        stats.packetsSent++;
-                        /* We've sent the whole buffer, so drop the buffer */
-                        sent -= bb.remaining();
-                        ServerStats.getInstance().incrementPacketsSent();
-                        outgoingBuffers.remove();
-                    }
-                    // ZooLog.logTraceMessage(LOG,
-                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, ""after send,
-                    // outgoingBuffers.size() = "" + outgoingBuffers.size());
-                }
-                synchronized (this) {
-                    if (outgoingBuffers.size() == 0) {
-                        if (!initialized
-                                && (sk.interestOps() & SelectionKey.OP_READ) == 0) {
-                            throw new IOException(""Responded to info probe"");
-                        }
-                        sk.interestOps(sk.interestOps()
-                                & (~SelectionKey.OP_WRITE));
-                    } else {
-                        sk.interestOps(sk.interestOps()
-                                        | SelectionKey.OP_WRITE);
-                    }
-                }
-            }
-        } catch (CancelledKeyException e) {
-            close();
-        } catch (IOException e) {
-            // LOG.error(""FIXMSG"",e);
-            close();
-        }
-    }
-
-    private void readRequest() throws IOException {
-        // We have the request, now process and setup for next
-        InputStream bais = new ByteBufferInputStream(incomingBuffer);
-        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);
-        RequestHeader h = new RequestHeader();
-        h.deserialize(bia, ""header"");
-        // Through the magic of byte buffers, txn will not be
-        // pointing
-        // to the start of the txn
-        incomingBuffer = incomingBuffer.slice();
-        if (h.getType() == OpCode.auth) {
-            AuthPacket authPacket = new AuthPacket();
-            ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);
-            String scheme = authPacket.getScheme();
-            AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);
-            if (ap == null
-                    || ap.handleAuthentication(this, authPacket.getAuth()) != KeeperException.Code.Ok) {
-                if (ap == null)
-                    LOG.error(""No authentication provider for scheme: ""
-                            + scheme);
-                else
-                    LOG.error(""Authentication failed for scheme: ""
-                            + scheme);
-                // send a response...
-                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
-                        KeeperException.Code.AuthFailed);
-                sendResponse(rh, null, null);
-                // ... and close connection
-                sendBuffer(NIOServerCnxn.closeConn);
-                disableRecv();
-            } else {
-                LOG.error(""Authentication succeeded for scheme: ""
-                        + scheme);
-                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
-                        KeeperException.Code.Ok);
-                sendResponse(rh, null, null);
-            }
-            return;
-        } else {
-            zk.submitRequest(this, sessionId, h.getType(), h.getXid(),
-                    incomingBuffer, authInfo);
-        }
-        if (h.getXid() >= 0) {
-            synchronized (this) {
-                outstandingRequests++;
-                // check throttling
-                if (zk.getInProcess() > factory.outstandingLimit) {
-                    disableRecv();
-                    // following lines should not be needed since we are already
-                    // reading
-                    // } else {
-                    // enableRecv();
-                }
-            }
-        }
-    }
-
-    public void disableRecv() {
-        sk.interestOps(sk.interestOps() & (~SelectionKey.OP_READ));
-    }
-
-    public void enableRecv() {
-        if (sk.isValid()) {
-            int interest = sk.interestOps();
-            if ((interest & SelectionKey.OP_READ) == 0) {
-                sk.interestOps(interest | SelectionKey.OP_READ);
-            }
-        }
-    }
-
-    private void readConnectRequest() throws IOException, InterruptedException {
-        BinaryInputArchive bia = BinaryInputArchive
-                .getArchive(new ByteBufferInputStream(incomingBuffer));
-        ConnectRequest connReq = new ConnectRequest();
-        connReq.deserialize(bia, ""connect"");
-        LOG.warn(""Connected to "" + sock.socket().getRemoteSocketAddress()
-                + "" lastZxid "" + connReq.getLastZxidSeen());
-        if (zk == null) {
-            throw new IOException(""ZooKeeperServer not running"");
-        }
-        if (connReq.getLastZxidSeen() > zk.dataTree.lastProcessedZxid) {
-            LOG.error(""Client has seen ""
-                    + Long.toHexString(connReq.getLastZxidSeen())
-                    + "" our last zxid is ""
-                    + Long.toHexString(zk.dataTree.lastProcessedZxid));
-            throw new IOException(""We are out of date"");
-        }
-        sessionTimeout = connReq.getTimeOut();
-        byte passwd[] = connReq.getPasswd();
-        if (sessionTimeout < zk.tickTime * 2) {
-            sessionTimeout = zk.tickTime * 2;
-        }
-        if (sessionTimeout > zk.tickTime * 20) {
-            sessionTimeout = zk.tickTime * 20;
-        }
-        // We don't want to receive any packets until we are sure that the
-        // session is setup
-        disableRecv();
-        if (connReq.getSessionId() != 0) {
-            setSessionId(connReq.getSessionId());
-            zk.reopenSession(this, sessionId, passwd, sessionTimeout);
-            LOG.warn(""Renewing session "" + Long.toHexString(sessionId));
-        } else {
-            zk.createSession(this, passwd, sessionTimeout);
-            LOG.warn(""Creating new session ""
-                    + Long.toHexString(sessionId));
-        }
-        initialized = true;
-    }
-
-    private void readLength(SelectionKey k) throws IOException {
-        // Read the length, now get the buffer
-        int len = lenBuffer.getInt();
-        if (!initialized) {
-            // We take advantage of the limited size of the length to look
-            // for cmds. They are all 4-bytes which fits inside of an int
-            if (len == ruokCmd) {
-                sendBuffer(imok.duplicate());
-                sendBuffer(NIOServerCnxn.closeConn);
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == killCmd) {
-                System.exit(0);
-            } else if (len == getTraceMaskCmd) {
-                long traceMask = ZooTrace.getTextTraceLevel();
-                ByteBuffer resp = ByteBuffer.allocate(8);
-                resp.putLong(traceMask);
-                resp.flip();
-                sendBuffer(resp);
-                sendBuffer(NIOServerCnxn.closeConn);
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == setTraceMaskCmd) {
-                incomingBuffer = ByteBuffer.allocate(8);
-
-                int rc = sock.read(incomingBuffer);
-                if (rc < 0) {
-                    throw new IOException(""Read error"");
-                }
-                System.out.println(""rc="" + rc);
-                incomingBuffer.flip();
-                long traceMask = incomingBuffer.getLong();
-                ZooTrace.setTextTraceLevel(traceMask);
-                ByteBuffer resp = ByteBuffer.allocate(8);
-                resp.putLong(traceMask);
-                resp.flip();
-                sendBuffer(resp);
-                sendBuffer(NIOServerCnxn.closeConn);
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == dumpCmd) {
-                if (zk == null) {
-                    sendBuffer(ByteBuffer.wrap(""ZooKeeper not active \n""
-                            .getBytes()));
-                } else {
-                    StringBuffer sb = new StringBuffer();
-                    sb.append(""SessionTracker dump: \n"");
-                    sb.append(zk.sessionTracker.toString()).append(""\n"");
-                    sb.append(""ephemeral nodes dump:\n"");
-                    sb.append(zk.dataTree.dumpEphemerals()).append(""\n"");
-                    sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
-                }
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == reqsCmd) {
-                StringBuffer sb = new StringBuffer();
-                sb.append(""Requests:\n"");
-                synchronized (outstanding) {
-                    for (Request r : outstanding) {
-                        sb.append(r.toString());
-                        sb.append('\n');
-                    }
-                }
-                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == statCmd) {
-                StringBuffer sb = new StringBuffer();
-                if(zk!=null){
-                    sb.append(""Zookeeper version: "").append(Version.getFullVersion())
-                        .append(""\n"");
-                    sb.append(""Clients:\n"");
-                    synchronized(factory.cnxns){
-                        for(NIOServerCnxn c : factory.cnxns){
-                            sb.append(c.getStats().toString());
-                        }
-                    }
-                    sb.append(""\n"");
-                    sb.append(ServerStats.getInstance().toString());
-                    sb.append(""Node count: "").append(zk.dataTree.getNodeCount()).
-                        append(""\n"");
-                }else
-                    sb.append(""ZooKeeperServer not running\n"");
-
-                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            }
-        }
-        if (len < 0 || len > BinaryInputArchive.maxBuffer) {
-            throw new IOException(""Len error "" + len);
-        }
-        if (zk == null) {
-            throw new IOException(""ZooKeeperServer not running"");
-        }
-        incomingBuffer = ByteBuffer.allocate(len);
-    }
-
-    /**
-     * The number of requests that have been submitted but not yet responded to.
-     */
-    int outstandingRequests;
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see com.yahoo.zookeeper.server.ServerCnxnIface#getSessionTimeout()
-     */
-    public int getSessionTimeout() {
-        return sessionTimeout;
-    }
-
-    /**
-     * This is the id that uniquely identifies the session of a client. Once
-     * this session is no longer active, the ephemeral nodes will go away.
-     */
-    long sessionId;
-
-    static long nextSessionId = 1;
-
-    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock,
-            SelectionKey sk, Factory factory) throws IOException {
-        this.zk = zk;
-        this.sock = sock;
-        this.sk = sk;
-        this.factory = factory;
-        sock.socket().setTcpNoDelay(true);
-        sock.socket().setSoLinger(true, 2);
-        InetAddress addr = ((InetSocketAddress) sock.socket()
-                .getRemoteSocketAddress()).getAddress();
-        authInfo.add(new Id(""ip"", addr.getHostAddress()));
-        authInfo.add(new Id(""host"", addr.getCanonicalHostName()));
-        sk.interestOps(SelectionKey.OP_READ);
-    }
-
-    public String toString() {
-        return ""NIOServerCnxn object with sock = "" + sock + "" and sk = "" + sk;
-    }
-
-    boolean closed;
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see com.yahoo.zookeeper.server.ServerCnxnIface#close()
-     */
-    public void close() {
-        if (closed) {
-            return;
-        }
-        closed = true;
-        synchronized (factory.cnxns) {
-            factory.cnxns.remove(this);
-        }
-        if (zk != null) {
-            zk.removeCnxn(this);
-        }
-
-        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
-                                 ""close  NIOServerCnxn: "" + sock);
-        try {
-            /*
-             * The following sequence of code is stupid! You would think that
-             * only sock.close() is needed, but alas, it doesn't work that way.
-             * If you just do sock.close() there are cases where the socket
-             * doesn't actually close...
-             */
-            sock.socket().shutdownOutput();
-        } catch (IOException e) {
-            // This is a relatively common exception that we can't avoid
-        }
-        try {
-            sock.socket().shutdownInput();
-        } catch (IOException e) {
-        }
-        try {
-            sock.socket().close();
-        } catch (IOException e) {
-            LOG.error(""FIXMSG"",e);
-        }
-        try {
-            sock.close();
-            // XXX The next line doesn't seem to be needed, but some posts
-            // to forums suggest that it is needed. Keep in mind if errors in
-            // this section arise.
-            // factory.selector.wakeup();
-        } catch (IOException e) {
-            LOG.error(""FIXMSG"",e);
-        }
-        sock = null;
-        if (sk != null) {
-            try {
-                // need to cancel this selection key from the selector
-                sk.cancel();
-            } catch (Exception e) {
-            }
-        }
-    }
-
-    private final static byte fourBytes[] = new byte[4];
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see com.yahoo.zookeeper.server.ServerCnxnIface#sendResponse(com.yahoo.zookeeper.proto.ReplyHeader,
-     *      com.yahoo.jute.Record, java.lang.String)
-     */
-    synchronized public void sendResponse(ReplyHeader h, Record r, String tag) {
-        if (closed) {
-            return;
-        }
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        // Make space for length
-        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
-        try {
-            baos.write(fourBytes);
-            bos.writeRecord(h, ""header"");
-            if (r != null) {
-                bos.writeRecord(r, tag);
-            }
-            baos.close();
-        } catch (IOException e) {
-            LOG.error(""Error serializing response"");
-        }
-        byte b[] = baos.toByteArray();
-        ByteBuffer bb = ByteBuffer.wrap(b);
-        bb.putInt(b.length - 4).rewind();
-        sendBuffer(bb);
-        if (h.getXid() > 0) {
-            synchronized (this.factory) {
-                outstandingRequests--;
-                // check throttling
-                if (zk.getInProcess() < factory.outstandingLimit
-                        || outstandingRequests < 1) {
-                    sk.selector().wakeup();
-                    enableRecv();
-                }
-            }
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see com.yahoo.zookeeper.server.ServerCnxnIface#process(com.yahoo.zookeeper.proto.WatcherEvent)
-     */
-    synchronized public void process(WatcherEvent event) {
-        ReplyHeader h = new ReplyHeader(-1, -1L, 0);
-        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,
-                                 ""Deliver event "" + event + "" to ""
-                                 + this.sessionId + "" through "" + this);
-        sendResponse(h, event, ""notification"");
-    }
-
-    public void finishSessionInit(boolean valid) {
-        try {
-            ConnectResponse rsp = new ConnectResponse(0, valid ? sessionTimeout
-                    : 0, valid ? sessionId : 0, // send 0 if session is no
-                    // longer valid
-                    valid ? zk.generatePasswd(sessionId) : new byte[16]);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
-            bos.writeInt(-1, ""len"");
-            rsp.serialize(bos, ""connect"");
-            baos.close();
-            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
-            bb.putInt(bb.remaining() - 4).rewind();
-            sendBuffer(bb);
-            LOG.warn(""Finished init of "" + Long.toHexString(sessionId)
-                    + "": "" + valid);
-            if (!valid) {
-                sendBuffer(closeConn);
-            }
-            // Now that the session is ready we can start receiving packets
-            synchronized (this.factory) {
-                sk.selector().wakeup();
-                enableRecv();
-            }
-        } catch (Exception e) {
-            LOG.error(""FIXMSG"",e);
-            close();
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see com.yahoo.zookeeper.server.ServerCnxnIface#getSessionId()
-     */
-    public long getSessionId() {
-        return sessionId;
-    }
-
-    public void setSessionId(long sessionId) {
-        this.sessionId = sessionId;
-    }
-
-    public ArrayList<Id> getAuthInfo() {
-        return authInfo;
-    }
-
-    public InetSocketAddress getRemoteAddress() {
-        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
-    }
-
-    private class CnxnStats implements ServerCnxn.Stats{
-        long packetsReceived;
-        long packetsSent;
-
-        /**
-         * The number of requests that have been submitted but not yet responded to.
-         */
-        public long getOutstandingRequests() {
-            return outstandingRequests;
-        }
-        public long getPacketsReceived() {
-            return packetsReceived;
-        }
-        public long getPacketsSent() {
-            return packetsSent;
-        }
-        public String toString(){
-            StringBuilder sb=new StringBuilder();
-            Channel channel = sk.channel();
-            if (channel instanceof SocketChannel) {
-                sb.append("" "").append(((SocketChannel)channel).socket()
-                                .getRemoteSocketAddress())
-                  .append(""["").append(Integer.toHexString(sk.interestOps()))
-                  .append(""](queued="").append(getOutstandingRequests())
-                  .append("",recved="").append(getPacketsReceived())
-                  .append("",sent="").append(getPacketsSent()).append("")\n"");
-            }
-            return sb.toString();
-        }
-    }
-
-    private CnxnStats stats=new CnxnStats();
-    public Stats getStats() {
-        return stats;
-    }
-
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.CancelledKeyException;
+import java.nio.channels.Channel;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Set;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Version;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.data.Id;
+import com.yahoo.zookeeper.proto.AuthPacket;
+import com.yahoo.zookeeper.proto.ConnectRequest;
+import com.yahoo.zookeeper.proto.ConnectResponse;
+import com.yahoo.zookeeper.proto.ReplyHeader;
+import com.yahoo.zookeeper.proto.RequestHeader;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.auth.AuthenticationProvider;
+import com.yahoo.zookeeper.server.auth.ProviderRegistry;
+
+/**
+ * This class handles communication with clients using NIO. There is one per
+ * client, but only one thread doing the communication.
+ */
+public class NIOServerCnxn implements Watcher, ServerCnxn {
+    private static final Logger LOG = Logger.getLogger(NIOServerCnxn.class);
+
+    static public class Factory extends Thread {
+        ZooKeeperServer zks;
+
+        ServerSocketChannel ss;
+
+        Selector selector = Selector.open();
+
+        /**
+         * We use this buffer to do efficient socket I/O. Since there is a single
+         * sender thread per NIOServerCnxn instance, we can use a member variable to
+         * only allocate it once.
+        */
+        ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);
+
+        HashSet<NIOServerCnxn> cnxns = new HashSet<NIOServerCnxn>();
+
+        int outstandingLimit = 1;
+
+        public Factory(int port) throws IOException {
+            super(""NIOServerCxn.Factory"");
+            setDaemon(true);
+            this.ss = ServerSocketChannel.open();
+            ss.socket().bind(new InetSocketAddress(port));
+            ss.configureBlocking(false);
+            ss.register(selector, SelectionKey.OP_ACCEPT);
+            start();
+        }
+
+        public void startup(ZooKeeperServer zks) throws IOException,
+                InterruptedException {
+            zks.startup();
+            setZooKeeperServer(zks);
+        }
+
+        public void setZooKeeperServer(ZooKeeperServer zks) {
+            this.zks = zks;
+            if (zks != null) {
+                this.outstandingLimit = zks.getGlobalOutstandingLimit();
+                zks.setServerCnxnFactory(this);
+            } else {
+                this.outstandingLimit = 1;
+            }
+        }
+
+        public InetSocketAddress getLocalAddress(){
+            return (InetSocketAddress)ss.socket().getLocalSocketAddress();
+        }
+
+        private void addCnxn(NIOServerCnxn cnxn) {
+            synchronized (cnxns) {
+                cnxns.add(cnxn);
+            }
+        }
+
+        protected NIOServerCnxn createConnection(SocketChannel sock,
+                SelectionKey sk) throws IOException {
+            return new NIOServerCnxn(zks, sock, sk, this);
+        }
+
+        public void run() {
+            while (!ss.socket().isClosed()) {
+                try {
+                    selector.select(1000);
+                    Set<SelectionKey> selected;
+                    synchronized (this) {
+                        selected = selector.selectedKeys();
+                    }
+                    ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(
+                            selected);
+                    Collections.shuffle(selectedList);
+                    for (SelectionKey k : selectedList) {
+                        if ((k.readyOps() & SelectionKey.OP_ACCEPT) != 0) {
+                            SocketChannel sc = ((ServerSocketChannel) k
+                                    .channel()).accept();
+                            sc.configureBlocking(false);
+                            SelectionKey sk = sc.register(selector,
+                                    SelectionKey.OP_READ);
+                            NIOServerCnxn cnxn = createConnection(sc, sk);
+                            sk.attach(cnxn);
+                            addCnxn(cnxn);
+                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
+                            NIOServerCnxn c = (NIOServerCnxn) k.attachment();
+                            c.doIO(k);
+                        }
+                    }
+                    selected.clear();
+                } catch (Exception e) {
+                    LOG.error(""FIXMSG"",e);
+                }
+            }
+            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""NIOServerCnxn factory exitedloop."");
+            clear();
+            LOG.error(""=====> Goodbye cruel world <======"");
+            // System.exit(0);
+        }
+
+        /**
+         * clear all the connections in the selector
+         *
+         */
+        synchronized public void clear() {
+            selector.wakeup();
+            synchronized (cnxns) {
+                // got to clear all the connections that we have in the selector
+                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
+                        .hasNext();) {
+                    NIOServerCnxn cnxn = it.next();
+                    it.remove();
+                    try {
+                        cnxn.close();
+                    } catch (Exception e) {
+                        // Do nothing.
+                    }
+                }
+            }
+
+        }
+
+        public void shutdown() {
+            try {
+                ss.close();
+                clear();
+                this.interrupt();
+                this.join();
+            } catch (InterruptedException e) {
+                LOG.warn(""Interrupted"",e);
+            } catch (Exception e) {
+                LOG.error(""Unexpected exception"", e);
+            }
+            if (zks != null) {
+                zks.shutdown();
+            }
+        }
+
+        synchronized void closeSession(long sessionId) {
+            selector.wakeup();
+            synchronized (cnxns) {
+                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
+                        .hasNext();) {
+                    NIOServerCnxn cnxn = it.next();
+                    if (cnxn.sessionId == sessionId) {
+                        it.remove();
+                        try {
+                            cnxn.close();
+                        } catch (Exception e) {
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * The buffer will cause the connection to be close when we do a send.
+     */
+    static final ByteBuffer closeConn = ByteBuffer.allocate(0);
+
+    Factory factory;
+
+    ZooKeeperServer zk;
+
+    private SocketChannel sock;
+
+    private SelectionKey sk;
+
+    boolean initialized;
+
+    ByteBuffer lenBuffer = ByteBuffer.allocate(4);
+
+    ByteBuffer incomingBuffer = lenBuffer;
+
+    LinkedBlockingQueue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();
+
+    int sessionTimeout;
+
+    ArrayList<Id> authInfo = new ArrayList<Id>();
+
+    LinkedList<Request> outstanding = new LinkedList<Request>();
+
+    void sendBuffer(ByteBuffer bb) {
+        synchronized (factory) {
+            try {
+                sk.selector().wakeup();
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                // ""Add a buffer to outgoingBuffers"");
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                //""sk "" + sk + "" is valid: "" +
+                // sk.isValid(), );
+                outgoingBuffers.add(bb);
+                if (sk.isValid()) {
+                    sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
+                }
+            } catch (RuntimeException e) {
+                LOG.error(""FIXMSG"",e);
+                throw e;
+            }
+        }
+    }
+
+    void doIO(SelectionKey k) throws InterruptedException {
+        try {
+            if (sock == null) {
+                return;
+            }
+            if (k.isReadable()) {
+                int rc = sock.read(incomingBuffer);
+                if (rc < 0) {
+                    throw new IOException(""Read error"");
+                }
+                if (incomingBuffer.remaining() == 0) {
+                    incomingBuffer.flip();
+                    if (incomingBuffer == lenBuffer) {
+                        readLength(k);
+                    } else if (!initialized) {
+                        stats.packetsReceived++;
+                        ServerStats.getInstance().incrementPacketsReceived();
+                        readConnectRequest();
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                    } else {
+                        stats.packetsReceived++;
+                        ServerStats.getInstance().incrementPacketsReceived();
+                        readRequest();
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                    }
+                }
+            }
+            if (k.isWritable()) {
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK
+                // ""outgoingBuffers.size() = "" +
+                // outgoingBuffers.size());
+                if (outgoingBuffers.size() > 0) {
+                    // ZooLog.logTraceMessage(LOG,
+                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                    // ""sk "" + k + "" is valid: "" +
+                    // k.isValid());
+
+                    /*
+                     * This is going to reset the buffer position to 0 and the
+                     * limit to the size of the buffer, so that we can fill it
+                     * with data from the non-direct buffers that we need to
+                     * send.
+                     */
+                    ByteBuffer directBuffer = factory.directBuffer;
+                    directBuffer.clear();
+
+                    for (ByteBuffer b : outgoingBuffers) {
+                        if (directBuffer.remaining() < b.remaining()) {
+                            /*
+                             * When we call put later, if the directBuffer is to
+                             * small to hold everything, nothing will be copied,
+                             * so we've got to slice the buffer if it's too big.
+                             */
+                            b = (ByteBuffer) b.slice().limit(
+                                    directBuffer.remaining());
+                        }
+                        /*
+                         * put() is going to modify the positions of both
+                         * buffers, put we don't want to change the position of
+                         * the source buffers (we'll do that after the send, if
+                         * needed), so we save and reset the position after the
+                         * copy
+                         */
+                        int p = b.position();
+                        directBuffer.put(b);
+                        b.position(p);
+                        if (directBuffer.remaining() == 0) {
+                            break;
+                        }
+                    }
+                    /*
+                     * Do the flip: limit becomes position, position gets set to
+                     * 0. This sets us up for the write.
+                     */
+                    directBuffer.flip();
+
+                    int sent = sock.write(directBuffer);
+                    ByteBuffer bb;
+
+                    // Remove the buffers that we have sent
+                    while (outgoingBuffers.size() > 0) {
+                        bb = outgoingBuffers.peek();
+                        if (bb == closeConn) {
+                            throw new IOException(""closing"");
+                        }
+                        int left = bb.remaining() - sent;
+                        if (left > 0) {
+                            /*
+                             * We only partially sent this buffer, so we update
+                             * the position and exit the loop.
+                             */
+                            bb.position(bb.position() + sent);
+                            break;
+                        }
+                        stats.packetsSent++;
+                        /* We've sent the whole buffer, so drop the buffer */
+                        sent -= bb.remaining();
+                        ServerStats.getInstance().incrementPacketsSent();
+                        outgoingBuffers.remove();
+                    }
+                    // ZooLog.logTraceMessage(LOG,
+                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, ""after send,
+                    // outgoingBuffers.size() = "" + outgoingBuffers.size());
+                }
+                synchronized (this) {
+                    if (outgoingBuffers.size() == 0) {
+                        if (!initialized
+                                && (sk.interestOps() & SelectionKey.OP_READ) == 0) {
+                            throw new IOException(""Responded to info probe"");
+                        }
+                        sk.interestOps(sk.interestOps()
+                                & (~SelectionKey.OP_WRITE));
+                    } else {
+                        sk.interestOps(sk.interestOps()
+                                        | SelectionKey.OP_WRITE);
+                    }
+                }
+            }
+        } catch (CancelledKeyException e) {
+            close();
+        } catch (IOException e) {
+            // LOG.error(""FIXMSG"",e);
+            close();
+        }
+    }
+
+    private void readRequest() throws IOException {
+        // We have the request, now process and setup for next
+        InputStream bais = new ByteBufferInputStream(incomingBuffer);
+        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);
+        RequestHeader h = new RequestHeader();
+        h.deserialize(bia, ""header"");
+        // Through the magic of byte buffers, txn will not be
+        // pointing
+        // to the start of the txn
+        incomingBuffer = incomingBuffer.slice();
+        if (h.getType() == OpCode.auth) {
+            AuthPacket authPacket = new AuthPacket();
+            ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);
+            String scheme = authPacket.getScheme();
+            AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);
+            if (ap == null
+                    || ap.handleAuthentication(this, authPacket.getAuth()) != KeeperException.Code.Ok) {
+                if (ap == null)
+                    LOG.error(""No authentication provider for scheme: ""
+                            + scheme);
+                else
+                    LOG.error(""Authentication failed for scheme: ""
+                            + scheme);
+                // send a response...
+                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
+                        KeeperException.Code.AuthFailed);
+                sendResponse(rh, null, null);
+                // ... and close connection
+                sendBuffer(NIOServerCnxn.closeConn);
+                disableRecv();
+            } else {
+                LOG.error(""Authentication succeeded for scheme: ""
+                        + scheme);
+                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
+                        KeeperException.Code.Ok);
+                sendResponse(rh, null, null);
+            }
+            return;
+        } else {
+            zk.submitRequest(this, sessionId, h.getType(), h.getXid(),
+                    incomingBuffer, authInfo);
+        }
+        if (h.getXid() >= 0) {
+            synchronized (this) {
+                outstandingRequests++;
+                // check throttling
+                if (zk.getInProcess() > factory.outstandingLimit) {
+                    disableRecv();
+                    // following lines should not be needed since we are already
+                    // reading
+                    // } else {
+                    // enableRecv();
+                }
+            }
+        }
+    }
+
+    public void disableRecv() {
+        sk.interestOps(sk.interestOps() & (~SelectionKey.OP_READ));
+    }
+
+    public void enableRecv() {
+        if (sk.isValid()) {
+            int interest = sk.interestOps();
+            if ((interest & SelectionKey.OP_READ) == 0) {
+                sk.interestOps(interest | SelectionKey.OP_READ);
+            }
+        }
+    }
+
+    private void readConnectRequest() throws IOException, InterruptedException {
+        BinaryInputArchive bia = BinaryInputArchive
+                .getArchive(new ByteBufferInputStream(incomingBuffer));
+        ConnectRequest connReq = new ConnectRequest();
+        connReq.deserialize(bia, ""connect"");
+        LOG.warn(""Connected to "" + sock.socket().getRemoteSocketAddress()
+                + "" lastZxid "" + connReq.getLastZxidSeen());
+        if (zk == null) {
+            throw new IOException(""ZooKeeperServer not running"");
+        }
+        if (connReq.getLastZxidSeen() > zk.dataTree.lastProcessedZxid) {
+            LOG.error(""Client has seen ""
+                    + Long.toHexString(connReq.getLastZxidSeen())
+                    + "" our last zxid is ""
+                    + Long.toHexString(zk.dataTree.lastProcessedZxid));
+            throw new IOException(""We are out of date"");
+        }
+        sessionTimeout = connReq.getTimeOut();
+        byte passwd[] = connReq.getPasswd();
+        if (sessionTimeout < zk.tickTime * 2) {
+            sessionTimeout = zk.tickTime * 2;
+        }
+        if (sessionTimeout > zk.tickTime * 20) {
+            sessionTimeout = zk.tickTime * 20;
+        }
+        // We don't want to receive any packets until we are sure that the
+        // session is setup
+        disableRecv();
+        if (connReq.getSessionId() != 0) {
+            setSessionId(connReq.getSessionId());
+            zk.reopenSession(this, sessionId, passwd, sessionTimeout);
+            LOG.warn(""Renewing session "" + Long.toHexString(sessionId));
+        } else {
+            zk.createSession(this, passwd, sessionTimeout);
+            LOG.warn(""Creating new session ""
+                    + Long.toHexString(sessionId));
+        }
+        initialized = true;
+    }
+
+    private void readLength(SelectionKey k) throws IOException {
+        // Read the length, now get the buffer
+        int len = lenBuffer.getInt();
+        if (!initialized) {
+            // We take advantage of the limited size of the length to look
+            // for cmds. They are all 4-bytes which fits inside of an int
+            if (len == ruokCmd) {
+                sendBuffer(imok.duplicate());
+                sendBuffer(NIOServerCnxn.closeConn);
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == killCmd) {
+                System.exit(0);
+            } else if (len == getTraceMaskCmd) {
+                long traceMask = ZooTrace.getTextTraceLevel();
+                ByteBuffer resp = ByteBuffer.allocate(8);
+                resp.putLong(traceMask);
+                resp.flip();
+                sendBuffer(resp);
+                sendBuffer(NIOServerCnxn.closeConn);
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == setTraceMaskCmd) {
+                incomingBuffer = ByteBuffer.allocate(8);
+
+                int rc = sock.read(incomingBuffer);
+                if (rc < 0) {
+                    throw new IOException(""Read error"");
+                }
+                System.out.println(""rc="" + rc);
+                incomingBuffer.flip();
+                long traceMask = incomingBuffer.getLong();
+                ZooTrace.setTextTraceLevel(traceMask);
+                ByteBuffer resp = ByteBuffer.allocate(8);
+                resp.putLong(traceMask);
+                resp.flip();
+                sendBuffer(resp);
+                sendBuffer(NIOServerCnxn.closeConn);
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == dumpCmd) {
+                if (zk == null) {
+                    sendBuffer(ByteBuffer.wrap(""ZooKeeper not active \n""
+                            .getBytes()));
+                } else {
+                    StringBuffer sb = new StringBuffer();
+                    sb.append(""SessionTracker dump: \n"");
+                    sb.append(zk.sessionTracker.toString()).append(""\n"");
+                    sb.append(""ephemeral nodes dump:\n"");
+                    sb.append(zk.dataTree.dumpEphemerals()).append(""\n"");
+                    sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
+                }
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == reqsCmd) {
+                StringBuffer sb = new StringBuffer();
+                sb.append(""Requests:\n"");
+                synchronized (outstanding) {
+                    for (Request r : outstanding) {
+                        sb.append(r.toString());
+                        sb.append('\n');
+                    }
+                }
+                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == statCmd) {
+                StringBuffer sb = new StringBuffer();
+                if(zk!=null){
+                    sb.append(""Zookeeper version: "").append(Version.getFullVersion())
+                        .append(""\n"");
+                    sb.append(""Clients:\n"");
+                    synchronized(factory.cnxns){
+                        for(NIOServerCnxn c : factory.cnxns){
+                            sb.append(c.getStats().toString());
+                        }
+                    }
+                    sb.append(""\n"");
+                    sb.append(ServerStats.getInstance().toString());
+                    sb.append(""Node count: "").append(zk.dataTree.getNodeCount()).
+                        append(""\n"");
+                }else
+                    sb.append(""ZooKeeperServer not running\n"");
+
+                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            }
+        }
+        if (len < 0 || len > BinaryInputArchive.maxBuffer) {
+            throw new IOException(""Len error "" + len);
+        }
+        if (zk == null) {
+            throw new IOException(""ZooKeeperServer not running"");
+        }
+        incomingBuffer = ByteBuffer.allocate(len);
+    }
+
+    /**
+     * The number of requests that have been submitted but not yet responded to.
+     */
+    int outstandingRequests;
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see com.yahoo.zookeeper.server.ServerCnxnIface#getSessionTimeout()
+     */
+    public int getSessionTimeout() {
+        return sessionTimeout;
+    }
+
+    /**
+     * This is the id that uniquely identifies the session of a client. Once
+     * this session is no longer active, the ephemeral nodes will go away.
+     */
+    long sessionId;
+
+    static long nextSessionId = 1;
+
+    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock,
+            SelectionKey sk, Factory factory) throws IOException {
+        this.zk = zk;
+        this.sock = sock;
+        this.sk = sk;
+        this.factory = factory;
+        sock.socket().setTcpNoDelay(true);
+        sock.socket().setSoLinger(true, 2);
+        InetAddress addr = ((InetSocketAddress) sock.socket()
+                .getRemoteSocketAddress()).getAddress();
+        authInfo.add(new Id(""ip"", addr.getHostAddress()));
+        authInfo.add(new Id(""host"", addr.getCanonicalHostName()));
+        sk.interestOps(SelectionKey.OP_READ);
+    }
+
+    public String toString() {
+        return ""NIOServerCnxn object with sock = "" + sock + "" and sk = "" + sk;
+    }
+
+    boolean closed;
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see com.yahoo.zookeeper.server.ServerCnxnIface#close()
+     */
+    public void close() {
+        if (closed) {
+            return;
+        }
+        closed = true;
+        synchronized (factory.cnxns) {
+            factory.cnxns.remove(this);
+        }
+        if (zk != null) {
+            zk.removeCnxn(this);
+        }
+
+        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
+                                 ""close  NIOServerCnxn: "" + sock);
+        try {
+            /*
+             * The following sequence of code is stupid! You would think that
+             * only sock.close() is needed, but alas, it doesn't work that way.
+             * If you just do sock.close() there are cases where the socket
+             * doesn't actually close...
+             */
+            sock.socket().shutdownOutput();
+        } catch (IOException e) {
+            // This is a relatively common exception that we can't avoid
+        }
+        try {
+            sock.socket().shutdownInput();
+        } catch (IOException e) {
+        }
+        try {
+            sock.socket().close();
+        } catch (IOException e) {
+            LOG.error(""FIXMSG"",e);
+        }
+        try {
+            sock.close();
+            // XXX The next line doesn't seem to be needed, but some posts
+            // to forums suggest that it is needed. Keep in mind if errors in
+            // this section arise.
+            // factory.selector.wakeup();
+        } catch (IOException e) {
+            LOG.error(""FIXMSG"",e);
+        }
+        sock = null;
+        if (sk != null) {
+            try {
+                // need to cancel this selection key from the selector
+                sk.cancel();
+            } catch (Exception e) {
+            }
+        }
+    }
+
+    private final static byte fourBytes[] = new byte[4];
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see com.yahoo.zookeeper.server.ServerCnxnIface#sendResponse(com.yahoo.zookeeper.proto.ReplyHeader,
+     *      com.yahoo.jute.Record, java.lang.String)
+     */
+    synchronized public void sendResponse(ReplyHeader h, Record r, String tag) {
+        if (closed) {
+            return;
+        }
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        // Make space for length
+        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
+        try {
+            baos.write(fourBytes);
+            bos.writeRecord(h, ""header"");
+            if (r != null) {
+                bos.writeRecord(r, tag);
+            }
+            baos.close();
+        } catch (IOException e) {
+            LOG.error(""Error serializing response"");
+        }
+        byte b[] = baos.toByteArray();
+        ByteBuffer bb = ByteBuffer.wrap(b);
+        bb.putInt(b.length - 4).rewind();
+        sendBuffer(bb);
+        if (h.getXid() > 0) {
+            synchronized (this.factory) {
+                outstandingRequests--;
+                // check throttling
+                if (zk.getInProcess() < factory.outstandingLimit
+                        || outstandingRequests < 1) {
+                    sk.selector().wakeup();
+                    enableRecv();
+                }
+            }
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see com.yahoo.zookeeper.server.ServerCnxnIface#process(com.yahoo.zookeeper.proto.WatcherEvent)
+     */
+    synchronized public void process(WatcherEvent event) {
+        ReplyHeader h = new ReplyHeader(-1, -1L, 0);
+        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,
+                                 ""Deliver event "" + event + "" to ""
+                                 + this.sessionId + "" through "" + this);
+        sendResponse(h, event, ""notification"");
+    }
+
+    public void finishSessionInit(boolean valid) {
+        try {
+            ConnectResponse rsp = new ConnectResponse(0, valid ? sessionTimeout
+                    : 0, valid ? sessionId : 0, // send 0 if session is no
+                    // longer valid
+                    valid ? zk.generatePasswd(sessionId) : new byte[16]);
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
+            bos.writeInt(-1, ""len"");
+            rsp.serialize(bos, ""connect"");
+            baos.close();
+            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
+            bb.putInt(bb.remaining() - 4).rewind();
+            sendBuffer(bb);
+            LOG.warn(""Finished init of "" + Long.toHexString(sessionId)
+                    + "": "" + valid);
+            if (!valid) {
+                sendBuffer(closeConn);
+            }
+            // Now that the session is ready we can start receiving packets
+            synchronized (this.factory) {
+                sk.selector().wakeup();
+                enableRecv();
+            }
+        } catch (Exception e) {
+            LOG.error(""FIXMSG"",e);
+            close();
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see com.yahoo.zookeeper.server.ServerCnxnIface#getSessionId()
+     */
+    public long getSessionId() {
+        return sessionId;
+    }
+
+    public void setSessionId(long sessionId) {
+        this.sessionId = sessionId;
+    }
+
+    public ArrayList<Id> getAuthInfo() {
+        return authInfo;
+    }
+
+    public InetSocketAddress getRemoteAddress() {
+        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
+    }
+
+    private class CnxnStats implements ServerCnxn.Stats{
+        long packetsReceived;
+        long packetsSent;
+
+        /**
+         * The number of requests that have been submitted but not yet responded to.
+         */
+        public long getOutstandingRequests() {
+            return outstandingRequests;
+        }
+        public long getPacketsReceived() {
+            return packetsReceived;
+        }
+        public long getPacketsSent() {
+            return packetsSent;
+        }
+        public String toString(){
+            StringBuilder sb=new StringBuilder();
+            Channel channel = sk.channel();
+            if (channel instanceof SocketChannel) {
+                sb.append("" "").append(((SocketChannel)channel).socket()
+                                .getRemoteSocketAddress())
+                  .append(""["").append(Integer.toHexString(sk.interestOps()))
+                  .append(""](queued="").append(getOutstandingRequests())
+                  .append("",recved="").append(getPacketsReceived())
+                  .append("",sent="").append(getPacketsSent()).append("")\n"");
+            }
+            return sb.toString();
+        }
+    }
+
+    private CnxnStats stats=new CnxnStats();
+    public Stats getStats() {
+        return stats;
+    }
+
+}
",,6461
2239,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/SyncRequestProcessor.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,171,a6bc7d54791e73b06083996ab57fdba9340ae1aa,1210283432,192,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,-1,1210382051/1194064875,"                                logStream = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.server.util.Profiler;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This RequestProcessor logs requests to disk. It batches the requests to do
- * the io efficiently. The request is not passed to the next RequestProcessor
- * until its log has been synced to disk.
- */
-public class SyncRequestProcessor extends Thread implements RequestProcessor {
-    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
-
-    static final int PADDING_TIMEOUT=1000;
-    ZooKeeperServer zks;
-
-    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
-
-    static boolean forceSync;
-    static {
-        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
-                ""no"");
-    }
-
-    static long preAllocSize = 65536 * 1024;
-    static {
-        String size = System.getProperty(""zookeeper.preAllocSize"");
-        if (size != null) {
-            try {
-                preAllocSize = Long.parseLong(size) * 1024;
-            } catch (NumberFormatException e) {
-                LOG.warn(size + "" is not a valid value for preAllocSize"");
-            }
-        }
-    }
-
-    /**
-     * The number of log entries to log before starting a snapshot
-     */
-    static public int snapCount = ZooKeeperServer.getSnapCount();
-
-    Thread snapInProcess;
-
-    RequestProcessor nextProcessor;
-
-    boolean timeToDie = false;
-
-    public SyncRequestProcessor(ZooKeeperServer zks,
-            RequestProcessor nextProcessor) {
-        super(""SyncThread"");
-        this.zks = zks;
-        this.nextProcessor = nextProcessor;
-        start();
-    }
-
-    /**
-     * Transactions that have been written and are waiting to be flushed to
-     * disk. Basically this is the list of SyncItems whose callbacks will be
-     * invoked after flush returns successfully.
-     */
-    LinkedList<Request> toFlush = new LinkedList<Request>();
-
-    FileOutputStream logStream;
-
-    BinaryOutputArchive logArchive;
-
-    Random r = new Random(System.nanoTime());
-
-    int logCount = 0;
-
-    Request requestOfDeath = Request.requestOfDeath;
-
-    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
-
-    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
-
-    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
-        long position = fc.position();
-        // We pad the file in 1M chunks to avoid syncing to
-        // write the new filesize.
-        if (position + 4096 >= fileSize) {
-            fileSize = fileSize + preAllocSize;
-            fill.position(0);
-            fc.write(fill, fileSize);
-        }
-        return fileSize;
-    }
-
-    public void run() {
-        try {
-            long fileSize = 0;
-            long lastZxidSeen = -1;
-            FileChannel fc = null;
-            while (true) {
-                Request si = null;
-                if (toFlush.isEmpty()) {
-                    si = queuedRequests.take();
-                } else {
-                    si = queuedRequests.poll();
-                    if (si == null) {
-                        flush(toFlush);
-                        continue;
-                    }
-                }
-                if (si == requestOfDeath) {
-                    break;
-                }
-                if (si != null) {
-                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
-                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
-                    // Long.toHexString(si.zxid));
-                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
-                            'S', si, """");
-                    TxnHeader hdr = si.hdr;
-                    if (hdr != null) {
-                        if (hdr.getZxid() <= lastZxidSeen) {
-                            LOG.error(""Current zxid "" + hdr.getZxid()
-                                    + "" is <= "" + lastZxidSeen + "" for ""
-                                    + hdr.getType());
-                        }
-                        Record txn = si.txn;
-                        if (logStream == null) {
-                            fileSize = 0;
-                            logStream = new FileOutputStream(new File(
-                                    zks.dataLogDir, ZooKeeperServer
-                                            .getLogName(hdr.getZxid())));
-                            synchronized (streamsToFlush) {
-                                streamsToFlush.add(logStream);
-                            }
-                            fc = logStream.getChannel();
-                            logArchive = BinaryOutputArchive
-                                    .getArchive(logStream);
-                        }
-                        final long fsize=fileSize;
-                        final FileChannel ffc=fc;
-                        fileSize = Profiler.profile(
-                            new Profiler.Operation<Long>() {
-                                public Long execute() throws Exception {
-                                    return SyncRequestProcessor.this
-                                            .padLogFile(ffc, fsize);
-                                }
-                            }, PADDING_TIMEOUT,
-                            ""Logfile padding exceeded time threshold""
-                        );
-                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                        BinaryOutputArchive boa = BinaryOutputArchive
-                                .getArchive(baos);
-                        hdr.serialize(boa, ""hdr"");
-                        if (txn != null) {
-                            txn.serialize(boa, ""txn"");
-                        }
-                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
-                        logArchive.writeByte((byte) 0x42, ""EOR"");
-                        logCount++;
-                        if (logCount > snapCount / 2
-                                && r.nextInt(snapCount / 2) == 0) {
-                            // We just want one snapshot going at a time
-                            if (snapInProcess != null
-                                    && snapInProcess.isAlive()) {
-                                LOG.warn(""Too busy to snap, skipping"");
-                            } else {
-                                logStream = null;
-                                logArchive = null;
-                                snapInProcess = new Thread() {
-                                    public void run() {
-                                        try {
-                                            zks.snapshot();
-                                        } catch (Exception e) {
-                                            LOG.error(""FIXMSG"",e);
-                                        }
-                                    }
-                                };
-                                snapInProcess.start();
-                            }
-                            logCount = 0;
-                        }
-                    }
-                    toFlush.add(si);
-                    if (toFlush.size() > 1000) {
-                        flush(toFlush);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            LOG.error(""Severe error, exiting"",e);
-            System.exit(11);
-        }
-        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""SyncRequestProcessor exiyed!"");
-    }
-
-    private void flush(LinkedList<Request> toFlush) throws IOException {
-        if (toFlush.size() == 0) {
-            return;
-        }
-
-        LinkedList<FileOutputStream> streamsToFlushNow;
-        synchronized (streamsToFlush) {
-            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
-                    .clone();
-        }
-        for (FileOutputStream fos : streamsToFlushNow) {
-            fos.flush();
-            if (forceSync) {
-                ((FileChannel) fos.getChannel()).force(false);
-            }
-        }
-        while (streamsToFlushNow.size() > 1) {
-            FileOutputStream fos = streamsToFlushNow.removeFirst();
-            fos.close();
-            synchronized (streamsToFlush) {
-                streamsToFlush.remove(fos);
-            }
-        }
-        while (toFlush.size() > 0) {
-            Request i = toFlush.remove();
-            nextProcessor.processRequest(i);
-        }
-    }
-
-    public void shutdown() {
-        timeToDie = true;
-        queuedRequests.add(requestOfDeath);
-        nextProcessor.shutdown();
-    }
-
-    public void processRequest(Request request) {
-        // request.addRQRec("">sync"");
-        queuedRequests.add(request);
-    }
-
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.server.util.Profiler;
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This RequestProcessor logs requests to disk. It batches the requests to do
+ * the io efficiently. The request is not passed to the next RequestProcessor
+ * until its log has been synced to disk.
+ */
+public class SyncRequestProcessor extends Thread implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
+
+    static final int PADDING_TIMEOUT=1000;
+    ZooKeeperServer zks;
+
+    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
+
+    static boolean forceSync;
+    static {
+        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
+                ""no"");
+    }
+
+    static long preAllocSize = 65536 * 1024;
+    static {
+        String size = System.getProperty(""zookeeper.preAllocSize"");
+        if (size != null) {
+            try {
+                preAllocSize = Long.parseLong(size) * 1024;
+            } catch (NumberFormatException e) {
+                LOG.warn(size + "" is not a valid value for preAllocSize"");
+            }
+        }
+    }
+
+    /**
+     * The number of log entries to log before starting a snapshot
+     */
+    static public int snapCount = ZooKeeperServer.getSnapCount();
+
+    Thread snapInProcess;
+
+    RequestProcessor nextProcessor;
+
+    boolean timeToDie = false;
+
+    public SyncRequestProcessor(ZooKeeperServer zks,
+            RequestProcessor nextProcessor) {
+        super(""SyncThread"");
+        this.zks = zks;
+        this.nextProcessor = nextProcessor;
+        start();
+    }
+
+    /**
+     * Transactions that have been written and are waiting to be flushed to
+     * disk. Basically this is the list of SyncItems whose callbacks will be
+     * invoked after flush returns successfully.
+     */
+    LinkedList<Request> toFlush = new LinkedList<Request>();
+
+    FileOutputStream logStream;
+
+    BinaryOutputArchive logArchive;
+
+    Random r = new Random(System.nanoTime());
+
+    int logCount = 0;
+
+    Request requestOfDeath = Request.requestOfDeath;
+
+    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
+
+    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
+
+    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
+        long position = fc.position();
+        // We pad the file in 1M chunks to avoid syncing to
+        // write the new filesize.
+        if (position + 4096 >= fileSize) {
+            fileSize = fileSize + preAllocSize;
+            fill.position(0);
+            fc.write(fill, fileSize);
+        }
+        return fileSize;
+    }
+
+    public void run() {
+        try {
+            long fileSize = 0;
+            long lastZxidSeen = -1;
+            FileChannel fc = null;
+            while (true) {
+                Request si = null;
+                if (toFlush.isEmpty()) {
+                    si = queuedRequests.take();
+                } else {
+                    si = queuedRequests.poll();
+                    if (si == null) {
+                        flush(toFlush);
+                        continue;
+                    }
+                }
+                if (si == requestOfDeath) {
+                    break;
+                }
+                if (si != null) {
+                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
+                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
+                    // Long.toHexString(si.zxid));
+                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
+                            'S', si, """");
+                    TxnHeader hdr = si.hdr;
+                    if (hdr != null) {
+                        if (hdr.getZxid() <= lastZxidSeen) {
+                            LOG.warn(""Current zxid "" + hdr.getZxid()
+                                    + "" is <= "" + lastZxidSeen + "" for ""
+                                    + hdr.getType());
+                        }
+                        Record txn = si.txn;
+                        if (logStream == null) {
+                            fileSize = 0;
+                            logStream = new FileOutputStream(new File(
+                                    zks.dataLogDir, ZooKeeperServer
+                                            .getLogName(hdr.getZxid())));
+                            synchronized (streamsToFlush) {
+                                streamsToFlush.add(logStream);
+                            }
+                            fc = logStream.getChannel();
+                            logArchive = BinaryOutputArchive
+                                    .getArchive(logStream);
+                        }
+                        final long fsize=fileSize;
+                        final FileChannel ffc=fc;
+                        fileSize = Profiler.profile(
+                            new Profiler.Operation<Long>() {
+                                public Long execute() throws Exception {
+                                    return SyncRequestProcessor.this
+                                            .padLogFile(ffc, fsize);
+                                }
+                            }, PADDING_TIMEOUT,
+                            ""Logfile padding exceeded time threshold""
+                        );
+                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                        BinaryOutputArchive boa = BinaryOutputArchive
+                                .getArchive(baos);
+                        hdr.serialize(boa, ""hdr"");
+                        if (txn != null) {
+                            txn.serialize(boa, ""txn"");
+                        }
+                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
+                        logArchive.writeByte((byte) 0x42, ""EOR"");
+                        logCount++;
+                        if (logCount > snapCount / 2
+                                && r.nextInt(snapCount / 2) == 0) {
+                            // We just want one snapshot going at a time
+                            if (snapInProcess != null
+                                    && snapInProcess.isAlive()) {
+                                LOG.warn(""Too busy to snap, skipping"");
+                            } else {
+                                logStream = null;
+                                logArchive = null;
+                                snapInProcess = new Thread() {
+                                    public void run() {
+                                        try {
+                                            zks.snapshot();
+                                        } catch (Exception e) {
+                                            LOG.warn(""Unexpected exception"",e);
+                                        }
+                                    }
+                                };
+                                snapInProcess.start();
+                            }
+                            logCount = 0;
+                        }
+                    }
+                    toFlush.add(si);
+                    if (toFlush.size() > 1000) {
+                        flush(toFlush);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            LOG.error(""Severe error, exiting"",e);
+            System.exit(11);
+        }
+        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""SyncRequestProcessor exiyed!"");
+    }
+
+    private void flush(LinkedList<Request> toFlush) throws IOException {
+        if (toFlush.size() == 0) {
+            return;
+        }
+
+        LinkedList<FileOutputStream> streamsToFlushNow;
+        synchronized (streamsToFlush) {
+            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
+                    .clone();
+        }
+        for (FileOutputStream fos : streamsToFlushNow) {
+            fos.flush();
+            if (forceSync) {
+                ((FileChannel) fos.getChannel()).force(false);
+            }
+        }
+        while (streamsToFlushNow.size() > 1) {
+            FileOutputStream fos = streamsToFlushNow.removeFirst();
+            fos.close();
+            synchronized (streamsToFlush) {
+                streamsToFlush.remove(fos);
+            }
+        }
+        while (toFlush.size() > 0) {
+            Request i = toFlush.remove();
+            nextProcessor.processRequest(i);
+        }
+    }
+
+    public void shutdown() {
+        timeToDie = true;
+        queuedRequests.add(requestOfDeath);
+        nextProcessor.shutdown();
+    }
+
+    public void processRequest(Request request) {
+        // request.addRQRec("">sync"");
+        queuedRequests.add(request);
+    }
+
+}
",,6461
2240,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/SyncRequestProcessor.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,172,a6bc7d54791e73b06083996ab57fdba9340ae1aa,1210283432,193,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,-1,1210382051/1194064875,"                                logArchive = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.server.util.Profiler;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This RequestProcessor logs requests to disk. It batches the requests to do
- * the io efficiently. The request is not passed to the next RequestProcessor
- * until its log has been synced to disk.
- */
-public class SyncRequestProcessor extends Thread implements RequestProcessor {
-    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
-
-    static final int PADDING_TIMEOUT=1000;
-    ZooKeeperServer zks;
-
-    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
-
-    static boolean forceSync;
-    static {
-        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
-                ""no"");
-    }
-
-    static long preAllocSize = 65536 * 1024;
-    static {
-        String size = System.getProperty(""zookeeper.preAllocSize"");
-        if (size != null) {
-            try {
-                preAllocSize = Long.parseLong(size) * 1024;
-            } catch (NumberFormatException e) {
-                LOG.warn(size + "" is not a valid value for preAllocSize"");
-            }
-        }
-    }
-
-    /**
-     * The number of log entries to log before starting a snapshot
-     */
-    static public int snapCount = ZooKeeperServer.getSnapCount();
-
-    Thread snapInProcess;
-
-    RequestProcessor nextProcessor;
-
-    boolean timeToDie = false;
-
-    public SyncRequestProcessor(ZooKeeperServer zks,
-            RequestProcessor nextProcessor) {
-        super(""SyncThread"");
-        this.zks = zks;
-        this.nextProcessor = nextProcessor;
-        start();
-    }
-
-    /**
-     * Transactions that have been written and are waiting to be flushed to
-     * disk. Basically this is the list of SyncItems whose callbacks will be
-     * invoked after flush returns successfully.
-     */
-    LinkedList<Request> toFlush = new LinkedList<Request>();
-
-    FileOutputStream logStream;
-
-    BinaryOutputArchive logArchive;
-
-    Random r = new Random(System.nanoTime());
-
-    int logCount = 0;
-
-    Request requestOfDeath = Request.requestOfDeath;
-
-    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
-
-    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
-
-    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
-        long position = fc.position();
-        // We pad the file in 1M chunks to avoid syncing to
-        // write the new filesize.
-        if (position + 4096 >= fileSize) {
-            fileSize = fileSize + preAllocSize;
-            fill.position(0);
-            fc.write(fill, fileSize);
-        }
-        return fileSize;
-    }
-
-    public void run() {
-        try {
-            long fileSize = 0;
-            long lastZxidSeen = -1;
-            FileChannel fc = null;
-            while (true) {
-                Request si = null;
-                if (toFlush.isEmpty()) {
-                    si = queuedRequests.take();
-                } else {
-                    si = queuedRequests.poll();
-                    if (si == null) {
-                        flush(toFlush);
-                        continue;
-                    }
-                }
-                if (si == requestOfDeath) {
-                    break;
-                }
-                if (si != null) {
-                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
-                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
-                    // Long.toHexString(si.zxid));
-                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
-                            'S', si, """");
-                    TxnHeader hdr = si.hdr;
-                    if (hdr != null) {
-                        if (hdr.getZxid() <= lastZxidSeen) {
-                            LOG.error(""Current zxid "" + hdr.getZxid()
-                                    + "" is <= "" + lastZxidSeen + "" for ""
-                                    + hdr.getType());
-                        }
-                        Record txn = si.txn;
-                        if (logStream == null) {
-                            fileSize = 0;
-                            logStream = new FileOutputStream(new File(
-                                    zks.dataLogDir, ZooKeeperServer
-                                            .getLogName(hdr.getZxid())));
-                            synchronized (streamsToFlush) {
-                                streamsToFlush.add(logStream);
-                            }
-                            fc = logStream.getChannel();
-                            logArchive = BinaryOutputArchive
-                                    .getArchive(logStream);
-                        }
-                        final long fsize=fileSize;
-                        final FileChannel ffc=fc;
-                        fileSize = Profiler.profile(
-                            new Profiler.Operation<Long>() {
-                                public Long execute() throws Exception {
-                                    return SyncRequestProcessor.this
-                                            .padLogFile(ffc, fsize);
-                                }
-                            }, PADDING_TIMEOUT,
-                            ""Logfile padding exceeded time threshold""
-                        );
-                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                        BinaryOutputArchive boa = BinaryOutputArchive
-                                .getArchive(baos);
-                        hdr.serialize(boa, ""hdr"");
-                        if (txn != null) {
-                            txn.serialize(boa, ""txn"");
-                        }
-                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
-                        logArchive.writeByte((byte) 0x42, ""EOR"");
-                        logCount++;
-                        if (logCount > snapCount / 2
-                                && r.nextInt(snapCount / 2) == 0) {
-                            // We just want one snapshot going at a time
-                            if (snapInProcess != null
-                                    && snapInProcess.isAlive()) {
-                                LOG.warn(""Too busy to snap, skipping"");
-                            } else {
-                                logStream = null;
-                                logArchive = null;
-                                snapInProcess = new Thread() {
-                                    public void run() {
-                                        try {
-                                            zks.snapshot();
-                                        } catch (Exception e) {
-                                            LOG.error(""FIXMSG"",e);
-                                        }
-                                    }
-                                };
-                                snapInProcess.start();
-                            }
-                            logCount = 0;
-                        }
-                    }
-                    toFlush.add(si);
-                    if (toFlush.size() > 1000) {
-                        flush(toFlush);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            LOG.error(""Severe error, exiting"",e);
-            System.exit(11);
-        }
-        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""SyncRequestProcessor exiyed!"");
-    }
-
-    private void flush(LinkedList<Request> toFlush) throws IOException {
-        if (toFlush.size() == 0) {
-            return;
-        }
-
-        LinkedList<FileOutputStream> streamsToFlushNow;
-        synchronized (streamsToFlush) {
-            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
-                    .clone();
-        }
-        for (FileOutputStream fos : streamsToFlushNow) {
-            fos.flush();
-            if (forceSync) {
-                ((FileChannel) fos.getChannel()).force(false);
-            }
-        }
-        while (streamsToFlushNow.size() > 1) {
-            FileOutputStream fos = streamsToFlushNow.removeFirst();
-            fos.close();
-            synchronized (streamsToFlush) {
-                streamsToFlush.remove(fos);
-            }
-        }
-        while (toFlush.size() > 0) {
-            Request i = toFlush.remove();
-            nextProcessor.processRequest(i);
-        }
-    }
-
-    public void shutdown() {
-        timeToDie = true;
-        queuedRequests.add(requestOfDeath);
-        nextProcessor.shutdown();
-    }
-
-    public void processRequest(Request request) {
-        // request.addRQRec("">sync"");
-        queuedRequests.add(request);
-    }
-
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.server.util.Profiler;
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This RequestProcessor logs requests to disk. It batches the requests to do
+ * the io efficiently. The request is not passed to the next RequestProcessor
+ * until its log has been synced to disk.
+ */
+public class SyncRequestProcessor extends Thread implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
+
+    static final int PADDING_TIMEOUT=1000;
+    ZooKeeperServer zks;
+
+    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
+
+    static boolean forceSync;
+    static {
+        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
+                ""no"");
+    }
+
+    static long preAllocSize = 65536 * 1024;
+    static {
+        String size = System.getProperty(""zookeeper.preAllocSize"");
+        if (size != null) {
+            try {
+                preAllocSize = Long.parseLong(size) * 1024;
+            } catch (NumberFormatException e) {
+                LOG.warn(size + "" is not a valid value for preAllocSize"");
+            }
+        }
+    }
+
+    /**
+     * The number of log entries to log before starting a snapshot
+     */
+    static public int snapCount = ZooKeeperServer.getSnapCount();
+
+    Thread snapInProcess;
+
+    RequestProcessor nextProcessor;
+
+    boolean timeToDie = false;
+
+    public SyncRequestProcessor(ZooKeeperServer zks,
+            RequestProcessor nextProcessor) {
+        super(""SyncThread"");
+        this.zks = zks;
+        this.nextProcessor = nextProcessor;
+        start();
+    }
+
+    /**
+     * Transactions that have been written and are waiting to be flushed to
+     * disk. Basically this is the list of SyncItems whose callbacks will be
+     * invoked after flush returns successfully.
+     */
+    LinkedList<Request> toFlush = new LinkedList<Request>();
+
+    FileOutputStream logStream;
+
+    BinaryOutputArchive logArchive;
+
+    Random r = new Random(System.nanoTime());
+
+    int logCount = 0;
+
+    Request requestOfDeath = Request.requestOfDeath;
+
+    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
+
+    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
+
+    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
+        long position = fc.position();
+        // We pad the file in 1M chunks to avoid syncing to
+        // write the new filesize.
+        if (position + 4096 >= fileSize) {
+            fileSize = fileSize + preAllocSize;
+            fill.position(0);
+            fc.write(fill, fileSize);
+        }
+        return fileSize;
+    }
+
+    public void run() {
+        try {
+            long fileSize = 0;
+            long lastZxidSeen = -1;
+            FileChannel fc = null;
+            while (true) {
+                Request si = null;
+                if (toFlush.isEmpty()) {
+                    si = queuedRequests.take();
+                } else {
+                    si = queuedRequests.poll();
+                    if (si == null) {
+                        flush(toFlush);
+                        continue;
+                    }
+                }
+                if (si == requestOfDeath) {
+                    break;
+                }
+                if (si != null) {
+                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
+                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
+                    // Long.toHexString(si.zxid));
+                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
+                            'S', si, """");
+                    TxnHeader hdr = si.hdr;
+                    if (hdr != null) {
+                        if (hdr.getZxid() <= lastZxidSeen) {
+                            LOG.warn(""Current zxid "" + hdr.getZxid()
+                                    + "" is <= "" + lastZxidSeen + "" for ""
+                                    + hdr.getType());
+                        }
+                        Record txn = si.txn;
+                        if (logStream == null) {
+                            fileSize = 0;
+                            logStream = new FileOutputStream(new File(
+                                    zks.dataLogDir, ZooKeeperServer
+                                            .getLogName(hdr.getZxid())));
+                            synchronized (streamsToFlush) {
+                                streamsToFlush.add(logStream);
+                            }
+                            fc = logStream.getChannel();
+                            logArchive = BinaryOutputArchive
+                                    .getArchive(logStream);
+                        }
+                        final long fsize=fileSize;
+                        final FileChannel ffc=fc;
+                        fileSize = Profiler.profile(
+                            new Profiler.Operation<Long>() {
+                                public Long execute() throws Exception {
+                                    return SyncRequestProcessor.this
+                                            .padLogFile(ffc, fsize);
+                                }
+                            }, PADDING_TIMEOUT,
+                            ""Logfile padding exceeded time threshold""
+                        );
+                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                        BinaryOutputArchive boa = BinaryOutputArchive
+                                .getArchive(baos);
+                        hdr.serialize(boa, ""hdr"");
+                        if (txn != null) {
+                            txn.serialize(boa, ""txn"");
+                        }
+                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
+                        logArchive.writeByte((byte) 0x42, ""EOR"");
+                        logCount++;
+                        if (logCount > snapCount / 2
+                                && r.nextInt(snapCount / 2) == 0) {
+                            // We just want one snapshot going at a time
+                            if (snapInProcess != null
+                                    && snapInProcess.isAlive()) {
+                                LOG.warn(""Too busy to snap, skipping"");
+                            } else {
+                                logStream = null;
+                                logArchive = null;
+                                snapInProcess = new Thread() {
+                                    public void run() {
+                                        try {
+                                            zks.snapshot();
+                                        } catch (Exception e) {
+                                            LOG.warn(""Unexpected exception"",e);
+                                        }
+                                    }
+                                };
+                                snapInProcess.start();
+                            }
+                            logCount = 0;
+                        }
+                    }
+                    toFlush.add(si);
+                    if (toFlush.size() > 1000) {
+                        flush(toFlush);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            LOG.error(""Severe error, exiting"",e);
+            System.exit(11);
+        }
+        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""SyncRequestProcessor exiyed!"");
+    }
+
+    private void flush(LinkedList<Request> toFlush) throws IOException {
+        if (toFlush.size() == 0) {
+            return;
+        }
+
+        LinkedList<FileOutputStream> streamsToFlushNow;
+        synchronized (streamsToFlush) {
+            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
+                    .clone();
+        }
+        for (FileOutputStream fos : streamsToFlushNow) {
+            fos.flush();
+            if (forceSync) {
+                ((FileChannel) fos.getChannel()).force(false);
+            }
+        }
+        while (streamsToFlushNow.size() > 1) {
+            FileOutputStream fos = streamsToFlushNow.removeFirst();
+            fos.close();
+            synchronized (streamsToFlush) {
+                streamsToFlush.remove(fos);
+            }
+        }
+        while (toFlush.size() > 0) {
+            Request i = toFlush.remove();
+            nextProcessor.processRequest(i);
+        }
+    }
+
+    public void shutdown() {
+        timeToDie = true;
+        queuedRequests.add(requestOfDeath);
+        nextProcessor.shutdown();
+    }
+
+    public void processRequest(Request request) {
+        // request.addRQRec("">sync"");
+        queuedRequests.add(request);
+    }
+
+}
",,6461
2241,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/ZooLog.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,225,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,226,,,,,"                textTos = null;",,,6461
2242,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/CommitProcessor.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,89,a6bc7d54791e73b06083996ab57fdba9340ae1aa,1210283432,98,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,-1,1210382051/1194064875,"                            nextPending = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.server.Request;
-import com.yahoo.zookeeper.server.RequestProcessor;
-import com.yahoo.zookeeper.server.ZooTrace;
-
-/**
- * This RequestProcessor matches the incoming committed requests with the
- * locally submitted requests. The trick is that locally submitted requests that
- * change the state of the system will come back as incoming committed requests,
- * so we need to match them up.
- */
-public class CommitProcessor extends Thread implements RequestProcessor {
-    private static final Logger LOG = Logger.getLogger(CommitProcessor.class);
-
-    /**
-     * Requests that we are holding until the commit comes in.
-     */
-    LinkedList<Request> queuedRequests = new LinkedList<Request>();
-
-    /**
-     * Requests that have been committed.
-     */
-    LinkedList<Request> committedRequests = new LinkedList<Request>();
-
-    /*
-     * Pending sync requests
-     */
-    LinkedList<Request> pendingSyncs = new LinkedList<Request>();
-
-    RequestProcessor nextProcessor;
-
-    public CommitProcessor(RequestProcessor nextProcessor) {
-        this.nextProcessor = nextProcessor;
-        start();
-    }
-
-    boolean finished = false;
-
-    public void run() {
-        try {
-            Request nextPending = null;
-            ArrayList<Request> toProcess = new ArrayList<Request>();
-            while (!finished) {
-                int len = toProcess.size();
-                for (int i = 0; i < len; i++) {
-                    nextProcessor.processRequest(toProcess.get(i));
-                }
-                toProcess.clear();
-                synchronized (this) {
-                    if ((queuedRequests.size() == 0 || nextPending != null)
-                            && committedRequests.size() == 0) {
-                        wait();
-                        continue;
-                    }
-                    // First check and see if the commit came in for the pending
-                    // request
-                    if ((queuedRequests.size() == 0 || nextPending != null)
-                            && committedRequests.size() > 0) {
-                        Request r = committedRequests.remove();
-                        /*
-                         * We match with nextPending so that we can move to the
-                         * next request when it is committed. We also want to
-                         * use nextPending because it has the cnxn member set
-                         * properly.
-                         */
-                        if (nextPending != null
-                                && nextPending.sessionId == r.sessionId
-                                && nextPending.cxid == r.cxid) {
-                            // we want to send our version of the request.
-                            // the pointer to the connection in the request
-                            nextPending.hdr = r.hdr;
-                            nextPending.txn = r.txn;
-                            nextPending.zxid = r.zxid;
-                            toProcess.add(nextPending);
-                            nextPending = null;
-                        } else {
-                            // this request came from someone else so just
-                            // send the commit packet
-                            toProcess.add(r);
-                        }
-                    }
-                }
-
-                // We haven't matched the pending requests, so go back to
-                // waiting
-                if (nextPending != null) {
-                    continue;
-                }
-
-                synchronized (this) {
-                    // Process the next requests in the queuedRequests
-                    while (nextPending == null && queuedRequests.size() > 0) {
-                        Request request = queuedRequests.remove();
-                        switch (request.type) {
-                        case OpCode.create:
-                        case OpCode.delete:
-                        case OpCode.setData:
-                        case OpCode.setACL:
-                        case OpCode.createSession:
-                        case OpCode.closeSession:
-                            nextPending = request;
-                            break;
-                        case OpCode.sync:
-                            nextPending = request;
-                            pendingSyncs.add(request);
-                            break;
-                        default:
-                            toProcess.add(request);
-                        }
-                    }
-                }
-            }
-        } catch (Exception e) {
-            LOG.error(""FIXMSG"",e);
-        }
-        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                 ""CommitProcessor exited loop!"");
-    }
-
-    synchronized public void commit(Request request) {
-        if (!finished) {
-            if (request == null) {
-                LOG.error(""FIXMSG"",new Exception(""committing a null! ""));
-                return;
-            }
-            committedRequests.add(request);
-            notifyAll();
-        }
-    }
-
-    synchronized public void processRequest(Request request) {
-        // request.addRQRec("">commit"");
-        // LOG.warn(""Zoo processReq>>> cxid = "" + request.cxid + "" type =
-        // "" + request.type + "" id = "" + request.sessionId + "" cnxn "" +
-        // request.cnxn);
-        if (!finished) {
-            queuedRequests.add(request);
-            notifyAll();
-        }
-    }
-
-    public void shutdown() {
-        finished = true;
-        queuedRequests.clear();
-        synchronized (this) {
-            notifyAll();
-        }
-        nextProcessor.shutdown();
-    }
-
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.server.Request;
+import com.yahoo.zookeeper.server.RequestProcessor;
+import com.yahoo.zookeeper.server.ZooTrace;
+
+/**
+ * This RequestProcessor matches the incoming committed requests with the
+ * locally submitted requests. The trick is that locally submitted requests that
+ * change the state of the system will come back as incoming committed requests,
+ * so we need to match them up.
+ */
+public class CommitProcessor extends Thread implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(CommitProcessor.class);
+
+    /**
+     * Requests that we are holding until the commit comes in.
+     */
+    LinkedList<Request> queuedRequests = new LinkedList<Request>();
+
+    /**
+     * Requests that have been committed.
+     */
+    LinkedList<Request> committedRequests = new LinkedList<Request>();
+
+    /*
+     * Pending sync requests
+     */
+    LinkedList<Request> pendingSyncs = new LinkedList<Request>();
+
+    RequestProcessor nextProcessor;
+
+    public CommitProcessor(RequestProcessor nextProcessor) {
+        this.nextProcessor = nextProcessor;
+        start();
+    }
+
+    boolean finished = false;
+
+    public void run() {
+        try {
+            Request nextPending = null;
+            ArrayList<Request> toProcess = new ArrayList<Request>();
+            while (!finished) {
+                int len = toProcess.size();
+                for (int i = 0; i < len; i++) {
+                    nextProcessor.processRequest(toProcess.get(i));
+                }
+                toProcess.clear();
+                synchronized (this) {
+                    if ((queuedRequests.size() == 0 || nextPending != null)
+                            && committedRequests.size() == 0) {
+                        wait();
+                        continue;
+                    }
+                    // First check and see if the commit came in for the pending
+                    // request
+                    if ((queuedRequests.size() == 0 || nextPending != null)
+                            && committedRequests.size() > 0) {
+                        Request r = committedRequests.remove();
+                        /*
+                         * We match with nextPending so that we can move to the
+                         * next request when it is committed. We also want to
+                         * use nextPending because it has the cnxn member set
+                         * properly.
+                         */
+                        if (nextPending != null
+                                && nextPending.sessionId == r.sessionId
+                                && nextPending.cxid == r.cxid) {
+                            // we want to send our version of the request.
+                            // the pointer to the connection in the request
+                            nextPending.hdr = r.hdr;
+                            nextPending.txn = r.txn;
+                            nextPending.zxid = r.zxid;
+                            toProcess.add(nextPending);
+                            nextPending = null;
+                        } else {
+                            // this request came from someone else so just
+                            // send the commit packet
+                            toProcess.add(r);
+                        }
+                    }
+                }
+
+                // We haven't matched the pending requests, so go back to
+                // waiting
+                if (nextPending != null) {
+                    continue;
+                }
+
+                synchronized (this) {
+                    // Process the next requests in the queuedRequests
+                    while (nextPending == null && queuedRequests.size() > 0) {
+                        Request request = queuedRequests.remove();
+                        switch (request.type) {
+                        case OpCode.create:
+                        case OpCode.delete:
+                        case OpCode.setData:
+                        case OpCode.setACL:
+                        case OpCode.createSession:
+                        case OpCode.closeSession:
+                            nextPending = request;
+                            break;
+                        case OpCode.sync:
+                            nextPending = request;
+                            pendingSyncs.add(request);
+                            break;
+                        default:
+                            toProcess.add(request);
+                        }
+                    }
+                }
+            }
+        } catch (Exception e) {
+            LOG.error(""FIXMSG"",e);
+        }
+        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                 ""CommitProcessor exited loop!"");
+    }
+
+    synchronized public void commit(Request request) {
+        if (!finished) {
+            if (request == null) {
+                LOG.warn(""Committed a null!"",
+                         new Exception(""committing a null! ""));
+                return;
+            }
+            committedRequests.add(request);
+            notifyAll();
+        }
+    }
+
+    synchronized public void processRequest(Request request) {
+        // request.addRQRec("">commit"");
+        // LOG.info(""Zoo processReq>>> cxid = "" + request.cxid + "" type =
+        // "" + request.type + "" id = "" + request.sessionId + "" cnxn "" +
+        // request.cnxn);
+        if (!finished) {
+            queuedRequests.add(request);
+            notifyAll();
+        }
+    }
+
+    public void shutdown() {
+        finished = true;
+        queuedRequests.clear();
+        synchronized (this) {
+            notifyAll();
+        }
+        nextProcessor.shutdown();
+    }
+
+}
",,6461
2243,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumPeer.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,297,d56cc9b9acb453945257a8e3b0cf8d88e5a36d35,1204726342,327,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,-1,1207349605/1194064875,"                    follower = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-
-import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.*;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetSocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.InputArchive;
-import com.yahoo.zookeeper.server.NIOServerCnxn;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooLog;
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+
+import static com.yahoo.zookeeper.server.ServerConfig.getClientPort;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataDir;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataLogDir;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionAlg;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionPort;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getInitLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServerId;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServers;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getSyncLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getTickTime;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.InputArchive;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.Vote;
 import com.yahoo.zookeeper.server.quorum.FastLeaderElection;
 import com.yahoo.zookeeper.server.quorum.QuorumCnxManager;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This class manages the quorum protocol. There are three states this server
- * can be in:
- * <ol>
- * <li>Leader election - each server will elect a leader (proposing itself as a
- * leader initially).</li>
- * <li>Follower - the server will synchronize with the leader and replicate any
- * transactions.</li>
- * <li>Leader - the server will process requests and forward them to followers.
- * A majority of followers must log the request before it can be accepted.
- * </ol>
- * 
- * This class will setup a datagram socket that will always respond with its
- * view of the current leader. The response will take the form of:
- * 
- * <pre>
- * int xid;
- * 
- * long myid;
- * 
- * long leader_id;
- * 
- * long leader_zxid;
- * </pre>
- * 
- * The request for the current leader will consist solely of an xid: int xid;
- * 
- * <h2>Configuration file</h2>
- * 
- * When the main() method of this class is used to start the program, the file
- * ""zoo.cfg"" in the current directory will be used to obtain configuration
- * information. zoo.cfg is a Properties file, so keys and values are separated
- * by equals (=) and the key/value pairs are separated by new lines. The
- * following keys are used in the configuration file:
- * <ol>
- * <li>dataDir - The directory where the zookeeper data is stored.</li>
- * <li>clientPort - The port used to communicate with clients.</li>
- * <li>tickTime - The duration of a tick in milliseconds. This is the basic
- * unit of time in zookeeper.</li>
- * <li>initLimit - The maximum number of ticks that a follower will wait to
- * initially synchronize with a leader.</li>
- * <li>syncLimit - The maximum number of ticks that a follower will wait for a
- * message (including heartbeats) from the leader.</li>
- * <li>server.<i>id</i> - This is the host:port that the server with the
- * given id will use for the quorum protocol.</li>
- * </ol>
- * In addition to the zoo.cfg file. There is a file in the data directory called
- * ""myid"" that contains the server id as an ASCII decimal value.
- */
-public class QuorumPeer extends Thread {
-	/**
-	 * Create an instance of a quorum peer 
-	 */
-	public interface Factory{
-		public QuorumPeer create() throws IOException;
-	}
-    public static class QuorumServer {
-        public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-        }
-
-        public InetSocketAddress addr;
-
-        public long id;
-    }
-
-    public enum ServerState {
-        LOOKING, FOLLOWING, LEADING;
-    }
-    /**
-     * The servers that make up the cluster
-     */
-    ArrayList<QuorumServer> quorumPeers;
-    public int getQuorumSize(){
-    	return quorumPeers.size();
-    }
-    /**
-     * My id
-     */
-    private long myid;
-
-
-    /**
-     * get the id of this quorum peer.
-     */
-    public long getId() {
-    	return myid;
-    }
-
-    /**
-     * This is who I think the leader currently is.
-     */
-    volatile Vote currentVote;
-
-    boolean running = true;
-
-    /**
-     * The number of milliseconds of each tick
-     */
-    int tickTime;
-
-    /**
-     * The number of ticks that the initial synchronization phase can take
-     */
-    int initLimit;
-
-    /**
-     * The number of ticks that can pass between sending a request and getting
-     * an acknowledgement
-     */
-    int syncLimit;
-
-    /**
-     * The current tick
-     */
-    int tick;
-
-    /**
-     * This class simply responds to requests for the current leader of this
-     * node.
-     * <p>
-     * The request contains just an xid generated by the requestor.
-     * <p>
-     * The response has the xid, the id of this server, the id of the leader,
-     * and the zxid of the leader.
-     * 
-     * @author breed
-     * 
-     */
-    class ResponderThread extends Thread {
-        ResponderThread() {
-            super(""ResponderThread"");
-        }
-
-        public void run() {
-            try {
-                byte b[] = new byte[36];
-                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
-                DatagramPacket packet = new DatagramPacket(b, b.length);
-                while (true) {
-                    udpSocket.receive(packet);
-                    if (packet.getLength() != 4) {
-                        ZooLog.logError(""Got more than just an xid! Len = ""
-                                + packet.getLength());
-                    } else {
-                        responseBuffer.clear();
-                        responseBuffer.getInt(); // Skip the xid
-                        responseBuffer.putLong(myid);
-                        switch (state) {
-                        case LOOKING:
-                            responseBuffer.putLong(currentVote.id);
-                            responseBuffer.putLong(currentVote.zxid);
-                            break;
-                        case LEADING:
-                            responseBuffer.putLong(myid);
-                            try {
-                                responseBuffer.putLong(leader.lastProposed);
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                            break;
-                        case FOLLOWING:
-                            responseBuffer.putLong(currentVote.id);
-                            try {
-                                responseBuffer.putLong(follower.getZxid());
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                        }
-                        packet.setData(b);
-                        udpSocket.send(packet);
-                    }
-                    packet.setLength(b.length);
-                }
-            } catch (Exception e) {
-                ZooLog.logException(e);
-            } finally {
-                ZooLog.logError(""QuorumPeer responder thread exited"");
-            }
-        }
-    }
-
-    public ServerState state = ServerState.LOOKING;
-
-    DatagramSocket udpSocket;
-
-    InetSocketAddress myQuorumAddr;
-
-    /**
-     * the directory where the snapshot is stored.
-     */
-    private File dataDir;
-
-    /**
-     * the directory where the logs are stored.
-     */
-    private File dataLogDir;
-
-    int clientPort;
-
-    int electionAlg;
-    
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This class manages the quorum protocol. There are three states this server
+ * can be in:
+ * <ol>
+ * <li>Leader election - each server will elect a leader (proposing itself as a
+ * leader initially).</li>
+ * <li>Follower - the server will synchronize with the leader and replicate any
+ * transactions.</li>
+ * <li>Leader - the server will process requests and forward them to followers.
+ * A majority of followers must log the request before it can be accepted.
+ * </ol>
+ * 
+ * This class will setup a datagram socket that will always respond with its
+ * view of the current leader. The response will take the form of:
+ * 
+ * <pre>
+ * int xid;
+ * 
+ * long myid;
+ * 
+ * long leader_id;
+ * 
+ * long leader_zxid;
+ * </pre>
+ * 
+ * The request for the current leader will consist solely of an xid: int xid;
+ * 
+ * <h2>Configuration file</h2>
+ * 
+ * When the main() method of this class is used to start the program, the file
+ * ""zoo.cfg"" in the current directory will be used to obtain configuration
+ * information. zoo.cfg is a Properties file, so keys and values are separated
+ * by equals (=) and the key/value pairs are separated by new lines. The
+ * following keys are used in the configuration file:
+ * <ol>
+ * <li>dataDir - The directory where the zookeeper data is stored.</li>
+ * <li>clientPort - The port used to communicate with clients.</li>
+ * <li>tickTime - The duration of a tick in milliseconds. This is the basic
+ * unit of time in zookeeper.</li>
+ * <li>initLimit - The maximum number of ticks that a follower will wait to
+ * initially synchronize with a leader.</li>
+ * <li>syncLimit - The maximum number of ticks that a follower will wait for a
+ * message (including heartbeats) from the leader.</li>
+ * <li>server.<i>id</i> - This is the host:port that the server with the
+ * given id will use for the quorum protocol.</li>
+ * </ol>
+ * In addition to the zoo.cfg file. There is a file in the data directory called
+ * ""myid"" that contains the server id as an ASCII decimal value.
+ */
+public class QuorumPeer extends Thread implements QuorumStats.Provider {
+    /**
+     * Create an instance of a quorum peer 
+     */
+    public interface Factory{
+        public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) throws IOException;
+        public NIOServerCnxn.Factory createConnectionFactory() throws IOException;
+    }
+    
+    public static class QuorumServer {
+        public QuorumServer(long id, InetSocketAddress addr) {
+            this.id = id;
+            this.addr = addr;
+        }
+
+        public InetSocketAddress addr;
+
+        public long id;
+    }
+
+    public enum ServerState {
+        LOOKING, FOLLOWING, LEADING;
+    }
+    /**
+     * The servers that make up the cluster
+     */
+    ArrayList<QuorumServer> quorumPeers;
+    public int getQuorumSize(){
+        return quorumPeers.size();
+    }
+    /**
+     * My id
+     */
+    private long myid;
+
+
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getId() {
+        return myid;
+    }
+
+    /**
+     * This is who I think the leader currently is.
+     */
+    volatile Vote currentVote;
+
+    volatile boolean running = true;
+
+    /**
+     * The number of milliseconds of each tick
+     */
+    int tickTime;
+
+    /**
+     * The number of ticks that the initial synchronization phase can take
+     */
+    int initLimit;
+
+    /**
+     * The number of ticks that can pass between sending a request and getting
+     * an acknowledgement
+     */
+    int syncLimit;
+
+    /**
+     * The current tick
+     */
+    int tick;
+
+    /**
+     * This class simply responds to requests for the current leader of this
+     * node.
+     * <p>
+     * The request contains just an xid generated by the requestor.
+     * <p>
+     * The response has the xid, the id of this server, the id of the leader,
+     * and the zxid of the leader.
+     * 
+     * @author breed
+     * 
+     */
+    class ResponderThread extends Thread {
+        ResponderThread() {
+            super(""ResponderThread"");
+        }
+
+        public void run() {
+            try {
+                byte b[] = new byte[36];
+                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
+                DatagramPacket packet = new DatagramPacket(b, b.length);
+                while (true) {
+                    udpSocket.receive(packet);
+                    if (packet.getLength() != 4) {
+                        ZooLog.logError(""Got more than just an xid! Len = ""
+                                + packet.getLength());
+                    } else {
+                        responseBuffer.clear();
+                        responseBuffer.getInt(); // Skip the xid
+                        responseBuffer.putLong(myid);
+                        switch (state) {
+                        case LOOKING:
+                            responseBuffer.putLong(currentVote.id);
+                            responseBuffer.putLong(currentVote.zxid);
+                            break;
+                        case LEADING:
+                            responseBuffer.putLong(myid);
+                            try {
+                                responseBuffer.putLong(leader.lastProposed);
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                            break;
+                        case FOLLOWING:
+                            responseBuffer.putLong(currentVote.id);
+                            try {
+                                responseBuffer.putLong(follower.getZxid());
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                        }
+                        packet.setData(b);
+                        udpSocket.send(packet);
+                    }
+                    packet.setLength(b.length);
+                }
+            } catch (Exception e) {
+                ZooLog.logException(e);
+            } finally {
+                ZooLog.logError(""QuorumPeer responder thread exited"");
+            }
+        }
+    }
+
+    private ServerState state = ServerState.LOOKING;
+    
+    public void setPeerState(ServerState newState){
+        state=newState;
+    }
+    
+    public ServerState getPeerState(){
+        return state;
+    }
+    
+    DatagramSocket udpSocket;
+
+    private InetSocketAddress myQuorumAddr;
+    
+    public InetSocketAddress getQuorumAddress(){
+        return myQuorumAddr;
+    }
+
+    /**
+     * the directory where the snapshot is stored.
+     */
+    private File dataDir;
+
+    /**
+     * the directory where the logs are stored.
+     */
+    private File dataLogDir;
+
+    Election electionAlg;
+
     int electionPort;
 
-    NIOServerCnxn.Factory cnxnFactory;
-
-    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
-            File dataLogDir, int clientPort, int electionAlg, int electionPort,
-            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
-        super(""QuorumPeer"");
-        this.clientPort = clientPort;
-        this.cnxnFactory = new NIOServerCnxn.Factory(clientPort, this);
-        this.quorumPeers = quorumPeers;
-        this.dataDir = dataDir;
-        this.electionAlg = electionAlg;
+    NIOServerCnxn.Factory cnxnFactory;
+
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionAlg, int electionPort,long myid, int tickTime, 
+            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        super(""QuorumPeer"");
+        this.cnxnFactory = cnxnFactory;
+        this.quorumPeers = quorumPeers;
+        this.dataDir = dataDir;
         this.electionPort = electionPort;
-        this.dataLogDir = dataLogDir;
-        this.myid = myid;
-        this.tickTime = tickTime;
-        this.initLimit = initLimit;
-        this.syncLimit = syncLimit;
-        currentVote = new Vote(myid, getLastLoggedZxid());
-        for (QuorumServer p : quorumPeers) {
-            if (p.id == myid) {
-                myQuorumAddr = p.addr;
-                break;
-            }
-        }
-        if (myQuorumAddr == null) {
-            throw new SocketException(""My id "" + myid + "" not in the peer list"");
-        }
-        if (electionAlg == 0) {
-            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-            new ResponderThread().start();
-        }
-    }
-
-    public QuorumPeer() throws IOException {
-    	// use quorum peer config to instantiate the class 
-		this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
-				getClientPort(), getElectionAlg(), getElectionPort(),
-				getServerId(), getTickTime(), getInitLimit(), getSyncLimit());
-	}
-    public Follower follower;
-
-    public Leader leader;
-
-    protected Follower makeFollower() throws IOException {
-		return new Follower(this, new FollowerZooKeeperServer(dataDir,
-				dataLogDir, this));
-	}
-
-	protected Leader makeLeader() throws IOException {
-		return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
-				this));
-	}
-    
-    public void run() {
-
-        /*
-         * Main loop
-         */
-        Election le = null;
-        switch(electionAlg){
-        case 1:
-            le = new AuthFastLeaderElection(this, this.electionPort);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, this.electionPort, true);                break;
-        case 3:
-            le =
-                new FastLeaderElection(this,
-                        new QuorumCnxManager(this.electionPort));
-        }
-
-        while (running) {
-            switch (state) {
-            case LOOKING:
-                try {
-                    ZooLog.logWarn(""LOOKING"");
-                    long init, end, diff;
-                    switch (electionAlg) {
-                    // Legacy algorithm
-                    case 0:
-                       init = System.currentTimeMillis();
-                        currentVote = new LeaderElection(this).lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff + "" "" + currentVote.id);
-                        break;
-                    // All other algorithms
-                    default:
-                        init = System.currentTimeMillis();
-                        if(le != null) currentVote = le.lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff);
-                        break;
-                    } 
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                    state = ServerState.LOOKING;
-                }
-                break;            
-            case FOLLOWING:
-                try {
-                    ZooLog.logWarn(""FOLLOWING"");
-                    follower = makeFollower();
-                    follower.followLeader();
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    follower.shutdown();
-                    follower = null;
-                    state = ServerState.LOOKING;
-                }
-                break;
-            case LEADING:
-                ZooLog.logWarn(""LEADING"");
-                try {
-                    leader = makeLeader();
-                    leader.lead();
-                    leader = null;
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    if (leader != null) {
-                        leader.shutdown(""Forcing shutdown"");
-                    }
-                    state = ServerState.LOOKING;
-                }
-                break;
-            }
-        }
-        ZooLog.logError(""QuorumPeer main thread exited"");
-    }
-
-    public void shutdown() {
-        running = false;
-        if (leader != null) {
-            leader.shutdown(""quorum Peer shutdown"");
-        }
-        if (follower != null) {
-            follower.shutdown();
-        }
-        cnxnFactory.shutdown();
-        udpSocket.close();
-    }
-
-    long getLastLoggedZxid() {
-        File[] list = dataLogDir.listFiles();
-        if (list == null) {
-            return 0;
-        }
-        long maxLog = -1;
-        long maxSnapShot = 0;
-        for (File f : list) {
-            String name = f.getName();
-            if (name.startsWith(""log."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
-                if (zxid > maxLog) {
-                    maxLog = zxid;
-                }
-            } else if (name.startsWith(""snapshot."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
-                        ""snapshot"");
-                if (zxid > maxLog) {
-                    maxSnapShot = zxid;
-                }
-            }
-        }
-        if (maxSnapShot > maxLog) {
-            return maxSnapShot;
-        }
-        long zxid = maxLog;
-        FileInputStream logStream = null;
-        try {
-            logStream = new FileInputStream(new File(dataLogDir, ""log.""
-                    + Long.toHexString(maxLog)));
-            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
-            while (true) {
-                byte[] bytes = ia.readBuffer(""txnEntry"");
-                if (bytes.length == 0) {
-                    // Since we preallocate, we define EOF to be an
-                    // empty transaction
-                    break;
-                }
-                int B = ia.readByte(""EOR"");
-                if (B != 'B') {
-                    break;
-                }
-                InputArchive bia = BinaryInputArchive
-                        .getArchive(new ByteArrayInputStream(bytes));
-                TxnHeader hdr = new TxnHeader();
-                hdr.deserialize(bia, ""hdr"");
-                zxid = hdr.getZxid();
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(e.toString());
-        } finally {
-            try {
-                if (logStream != null) {
-                    logStream.close();
-                }
-            } catch (IOException e) {
-                ZooLog.logException(e);
-            }
-        }
-        return zxid;
-    }
-
-    public static void runPeer(QuorumPeer.Factory qpFactory) {
-		try {
-			QuorumPeer self = qpFactory.create();
-			self.start();
-			self.join();
-		} catch (Exception e) {
-			ZooLog.logException(e);
-		}
-		System.exit(2);
-	}
-    
-    public static void main(String args[]) {
-		if (args.length == 2) {
-			ZooKeeperServer.main(args);
-			return;
-		}
-		QuorumPeerConfig.parse(args);
-		if (!QuorumPeerConfig.isStandalone()) {
-			runPeer(new QuorumPeer.Factory() {
-				public QuorumPeer create() throws IOException {
-					return new QuorumPeer();
-				}
-			});
-		}else{
-			// there is only server in the quorum -- run as standalone
-			ZooKeeperServer.main(args);
-		}
-	}
-}
+        this.dataLogDir = dataLogDir;
+        this.myid = myid;
+        this.tickTime = tickTime;
+        this.initLimit = initLimit;
+        this.syncLimit = syncLimit;
+        currentVote = new Vote(myid, getLastLoggedZxid());
+        for (QuorumServer p : quorumPeers) {
+            if (p.id == myid) {
+                myQuorumAddr = p.addr;
+                break;
+            }
+        }
+        if (myQuorumAddr == null) {
+            throw new SocketException(""My id "" + myid + "" not in the peer list"");
+        }
+        if (electionAlg == 0) {
+            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
+            new ResponderThread().start();
+        }
+        this.electionAlg = createElectionAlgorithm(electionAlg);
+        QuorumStats.getInstance().setStatsProvider(this);
+    }
+
+    /**
+     * This constructor is only used by the existing unit test code.
+     */
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int clientPort, int electionAlg, int electionPort,
+            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
+        this(quorumPeers,dataDir,dataLogDir,electionAlg,electionPort,myid,tickTime,
+                initLimit,syncLimit,new NIOServerCnxn.Factory(clientPort));
+    }
+    /**
+     *  The constructor uses the quorum peer config to instantiate the class
+     */
+    public QuorumPeer(NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
+                getElectionAlg(), getElectionPort(),getServerId(),getTickTime(), 
+                getInitLimit(), getSyncLimit(),cnxnFactory);
+    }
+    
+    public Follower follower;
+    public Leader leader;
+
+    protected Follower makeFollower(File dataDir,File dataLogDir) throws IOException {
+        return new Follower(this, new FollowerZooKeeperServer(dataDir,
+                dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+
+    protected Leader makeLeader(File dataDir,File dataLogDir) throws IOException {
+        return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
+                this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+    
+    private Election createElectionAlgorithm(int electionAlgorithm){
+        Election le=null;
+        //TODO: use a factory rather than a switch
+        switch (electionAlgorithm) {
+        case 0:
+            // will create a new instance for each run of the protocol
+            break;
+        case 1:
+            le = new AuthFastLeaderElection(this, this.electionPort);
+            break;
+        case 2:
+            le = new AuthFastLeaderElection(this, this.electionPort, true); 
+            break;
+        case 3:
+            le = new FastLeaderElection(this,
+                        new QuorumCnxManager(this.electionPort));
+        default:
+            assert false;
+        }
+        return le;       
+    }
+    
+    protected Election makeLEStrategy(){
+        if(electionAlg==null)
+            return new LeaderElection(this);
+        return electionAlg;
+    }
+    
+    synchronized protected void setLeader(Leader newLeader){
+        leader=newLeader;
+    }
+
+    synchronized protected void setFollower(Follower newFollower){
+        follower=newFollower;
+    }
+    
+    synchronized public ZooKeeperServer getActiveServer(){
+        if(leader!=null)
+            return leader.zk;
+        else if(follower!=null)
+            return follower.zk;
+        return null;
+    }
+    
+    public void run() {
+        /*
+         * Main loop
+         */
+        while (running) {
+            switch (state) {
+            case LOOKING:
+                try {
+                    ZooLog.logWarn(""LOOKING"");
+                    currentVote = makeLEStrategy().lookForLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case FOLLOWING:
+                try {
+                    ZooLog.logWarn(""FOLLOWING"");
+                    setFollower(makeFollower(dataDir,dataLogDir));
+                    follower.followLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    follower.shutdown();
+                    setFollower(null);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case LEADING:
+                ZooLog.logWarn(""LEADING"");
+                try {
+                    setLeader(makeLeader(dataDir,dataLogDir));
+                    leader.lead();
+                    setLeader(null);
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    if (leader != null) {
+                        leader.shutdown(""Forcing shutdown"");
+                        setLeader(null);
+                    }
+                    state = ServerState.LOOKING;
+                }
+                break;
+            }
+        }
+        ZooLog.logError(""QuorumPeer main thread exited"");
+    }
+
+    public void shutdown() {
+        running = false;
+        if (leader != null) {
+            leader.shutdown(""quorum Peer shutdown"");
+        }
+        if (follower != null) {
+            follower.shutdown();
+        }
+        cnxnFactory.shutdown();
+        udpSocket.close();
+    }
+
+    long getLastLoggedZxid() {
+        File[] list = dataLogDir.listFiles();
+        if (list == null) {
+            return 0;
+        }
+        long maxLog = -1;
+        long maxSnapShot = 0;
+        for (File f : list) {
+            String name = f.getName();
+            if (name.startsWith(""log."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
+                if (zxid > maxLog) {
+                    maxLog = zxid;
+                }
+            } else if (name.startsWith(""snapshot."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
+                        ""snapshot"");
+                if (zxid > maxLog) {
+                    maxSnapShot = zxid;
+                }
+            }
+        }
+        if (maxSnapShot > maxLog) {
+            return maxSnapShot;
+        }
+        long zxid = maxLog;
+        FileInputStream logStream = null;
+        try {
+            logStream = new FileInputStream(new File(dataLogDir, ""log.""
+                    + Long.toHexString(maxLog)));
+            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
+            while (true) {
+                byte[] bytes = ia.readBuffer(""txnEntry"");
+                if (bytes.length == 0) {
+                    // Since we preallocate, we define EOF to be an
+                    // empty transaction
+                    break;
+                }
+                int B = ia.readByte(""EOR"");
+                if (B != 'B') {
+                    break;
+                }
+                InputArchive bia = BinaryInputArchive
+                        .getArchive(new ByteArrayInputStream(bytes));
+                TxnHeader hdr = new TxnHeader();
+                hdr.deserialize(bia, ""hdr"");
+                zxid = hdr.getZxid();
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(e.toString());
+        } finally {
+            try {
+                if (logStream != null) {
+                    logStream.close();
+                }
+            } catch (IOException e) {
+                ZooLog.logException(e);
+            }
+        }
+        return zxid;
+    }
+
+    public static void runPeer(QuorumPeer.Factory qpFactory) {
+        try {
+            QuorumStats.registerAsConcrete();
+            QuorumPeer self = qpFactory.create(qpFactory.createConnectionFactory());
+            self.start();
+            self.join();
+        } catch (Exception e) {
+            ZooLog.logException(e);
+        }
+        System.exit(2);
+    }
+    
+    public String[] getQuorumPeers() {
+        List<String> l = new ArrayList<String>();
+        synchronized (this) {
+            if (leader != null) {
+                synchronized (leader.followers) {
+                    for (FollowerHandler fh : leader.followers) {
+                        if (fh.s == null)
+                            continue;
+                        String s = fh.s.getRemoteSocketAddress().toString();
+                        if (leader.isFollowerSynced(fh))
+                            s += ""*"";
+                        l.add(s);
+                    }
+                }
+            } else if (follower != null) {
+                l.add(follower.sock.getRemoteSocketAddress().toString());
+            }
+        }
+        return l.toArray(new String[0]);
+    }
+
+    public String getServerState() {
+        switch (state) {
+        case LOOKING:
+            return QuorumStats.Provider.LOOKING_STATE;
+        case LEADING:
+            return QuorumStats.Provider.LEADING_STATE;
+        case FOLLOWING:
+            return QuorumStats.Provider.FOLLOWING_STATE;
+        }
+        return QuorumStats.Provider.UNKNOWN_STATE;
+    }
+
+    public static void main(String args[]) {
+        if (args.length == 2) {
+            ZooKeeperServer.main(args);
+            return;
+        }
+        QuorumPeerConfig.parse(args);
+        if (!QuorumPeerConfig.isStandalone()) {
+            runPeer(new QuorumPeer.Factory() {
+                public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) 
+                        throws IOException {
+                    return new QuorumPeer(cnxnFactory);
+                }
+                public NIOServerCnxn.Factory createConnectionFactory()
+                        throws IOException {
+                    return new NIOServerCnxn.Factory(getClientPort());
+                }
+            });
+        }else{
+            // there is only server in the quorum -- run as standalone
+            ZooKeeperServer.main(args);
+        }
+    }
+}
",,6461
2244,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumPeer.java,047d9258a4730791b85cc81b0e1435465a32acbf,1194064875,306,d56cc9b9acb453945257a8e3b0cf8d88e5a36d35,1204726342,336,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,-1,1207349605/1194064875,"                    leader = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-
-import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.*;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetSocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.InputArchive;
-import com.yahoo.zookeeper.server.NIOServerCnxn;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooLog;
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+
+import static com.yahoo.zookeeper.server.ServerConfig.getClientPort;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataDir;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataLogDir;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionAlg;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionPort;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getInitLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServerId;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServers;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getSyncLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getTickTime;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.InputArchive;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.Vote;
 import com.yahoo.zookeeper.server.quorum.FastLeaderElection;
 import com.yahoo.zookeeper.server.quorum.QuorumCnxManager;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This class manages the quorum protocol. There are three states this server
- * can be in:
- * <ol>
- * <li>Leader election - each server will elect a leader (proposing itself as a
- * leader initially).</li>
- * <li>Follower - the server will synchronize with the leader and replicate any
- * transactions.</li>
- * <li>Leader - the server will process requests and forward them to followers.
- * A majority of followers must log the request before it can be accepted.
- * </ol>
- * 
- * This class will setup a datagram socket that will always respond with its
- * view of the current leader. The response will take the form of:
- * 
- * <pre>
- * int xid;
- * 
- * long myid;
- * 
- * long leader_id;
- * 
- * long leader_zxid;
- * </pre>
- * 
- * The request for the current leader will consist solely of an xid: int xid;
- * 
- * <h2>Configuration file</h2>
- * 
- * When the main() method of this class is used to start the program, the file
- * ""zoo.cfg"" in the current directory will be used to obtain configuration
- * information. zoo.cfg is a Properties file, so keys and values are separated
- * by equals (=) and the key/value pairs are separated by new lines. The
- * following keys are used in the configuration file:
- * <ol>
- * <li>dataDir - The directory where the zookeeper data is stored.</li>
- * <li>clientPort - The port used to communicate with clients.</li>
- * <li>tickTime - The duration of a tick in milliseconds. This is the basic
- * unit of time in zookeeper.</li>
- * <li>initLimit - The maximum number of ticks that a follower will wait to
- * initially synchronize with a leader.</li>
- * <li>syncLimit - The maximum number of ticks that a follower will wait for a
- * message (including heartbeats) from the leader.</li>
- * <li>server.<i>id</i> - This is the host:port that the server with the
- * given id will use for the quorum protocol.</li>
- * </ol>
- * In addition to the zoo.cfg file. There is a file in the data directory called
- * ""myid"" that contains the server id as an ASCII decimal value.
- */
-public class QuorumPeer extends Thread {
-	/**
-	 * Create an instance of a quorum peer 
-	 */
-	public interface Factory{
-		public QuorumPeer create() throws IOException;
-	}
-    public static class QuorumServer {
-        public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-        }
-
-        public InetSocketAddress addr;
-
-        public long id;
-    }
-
-    public enum ServerState {
-        LOOKING, FOLLOWING, LEADING;
-    }
-    /**
-     * The servers that make up the cluster
-     */
-    ArrayList<QuorumServer> quorumPeers;
-    public int getQuorumSize(){
-    	return quorumPeers.size();
-    }
-    /**
-     * My id
-     */
-    private long myid;
-
-
-    /**
-     * get the id of this quorum peer.
-     */
-    public long getId() {
-    	return myid;
-    }
-
-    /**
-     * This is who I think the leader currently is.
-     */
-    volatile Vote currentVote;
-
-    boolean running = true;
-
-    /**
-     * The number of milliseconds of each tick
-     */
-    int tickTime;
-
-    /**
-     * The number of ticks that the initial synchronization phase can take
-     */
-    int initLimit;
-
-    /**
-     * The number of ticks that can pass between sending a request and getting
-     * an acknowledgement
-     */
-    int syncLimit;
-
-    /**
-     * The current tick
-     */
-    int tick;
-
-    /**
-     * This class simply responds to requests for the current leader of this
-     * node.
-     * <p>
-     * The request contains just an xid generated by the requestor.
-     * <p>
-     * The response has the xid, the id of this server, the id of the leader,
-     * and the zxid of the leader.
-     * 
-     * @author breed
-     * 
-     */
-    class ResponderThread extends Thread {
-        ResponderThread() {
-            super(""ResponderThread"");
-        }
-
-        public void run() {
-            try {
-                byte b[] = new byte[36];
-                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
-                DatagramPacket packet = new DatagramPacket(b, b.length);
-                while (true) {
-                    udpSocket.receive(packet);
-                    if (packet.getLength() != 4) {
-                        ZooLog.logError(""Got more than just an xid! Len = ""
-                                + packet.getLength());
-                    } else {
-                        responseBuffer.clear();
-                        responseBuffer.getInt(); // Skip the xid
-                        responseBuffer.putLong(myid);
-                        switch (state) {
-                        case LOOKING:
-                            responseBuffer.putLong(currentVote.id);
-                            responseBuffer.putLong(currentVote.zxid);
-                            break;
-                        case LEADING:
-                            responseBuffer.putLong(myid);
-                            try {
-                                responseBuffer.putLong(leader.lastProposed);
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                            break;
-                        case FOLLOWING:
-                            responseBuffer.putLong(currentVote.id);
-                            try {
-                                responseBuffer.putLong(follower.getZxid());
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                        }
-                        packet.setData(b);
-                        udpSocket.send(packet);
-                    }
-                    packet.setLength(b.length);
-                }
-            } catch (Exception e) {
-                ZooLog.logException(e);
-            } finally {
-                ZooLog.logError(""QuorumPeer responder thread exited"");
-            }
-        }
-    }
-
-    public ServerState state = ServerState.LOOKING;
-
-    DatagramSocket udpSocket;
-
-    InetSocketAddress myQuorumAddr;
-
-    /**
-     * the directory where the snapshot is stored.
-     */
-    private File dataDir;
-
-    /**
-     * the directory where the logs are stored.
-     */
-    private File dataLogDir;
-
-    int clientPort;
-
-    int electionAlg;
-    
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This class manages the quorum protocol. There are three states this server
+ * can be in:
+ * <ol>
+ * <li>Leader election - each server will elect a leader (proposing itself as a
+ * leader initially).</li>
+ * <li>Follower - the server will synchronize with the leader and replicate any
+ * transactions.</li>
+ * <li>Leader - the server will process requests and forward them to followers.
+ * A majority of followers must log the request before it can be accepted.
+ * </ol>
+ * 
+ * This class will setup a datagram socket that will always respond with its
+ * view of the current leader. The response will take the form of:
+ * 
+ * <pre>
+ * int xid;
+ * 
+ * long myid;
+ * 
+ * long leader_id;
+ * 
+ * long leader_zxid;
+ * </pre>
+ * 
+ * The request for the current leader will consist solely of an xid: int xid;
+ * 
+ * <h2>Configuration file</h2>
+ * 
+ * When the main() method of this class is used to start the program, the file
+ * ""zoo.cfg"" in the current directory will be used to obtain configuration
+ * information. zoo.cfg is a Properties file, so keys and values are separated
+ * by equals (=) and the key/value pairs are separated by new lines. The
+ * following keys are used in the configuration file:
+ * <ol>
+ * <li>dataDir - The directory where the zookeeper data is stored.</li>
+ * <li>clientPort - The port used to communicate with clients.</li>
+ * <li>tickTime - The duration of a tick in milliseconds. This is the basic
+ * unit of time in zookeeper.</li>
+ * <li>initLimit - The maximum number of ticks that a follower will wait to
+ * initially synchronize with a leader.</li>
+ * <li>syncLimit - The maximum number of ticks that a follower will wait for a
+ * message (including heartbeats) from the leader.</li>
+ * <li>server.<i>id</i> - This is the host:port that the server with the
+ * given id will use for the quorum protocol.</li>
+ * </ol>
+ * In addition to the zoo.cfg file. There is a file in the data directory called
+ * ""myid"" that contains the server id as an ASCII decimal value.
+ */
+public class QuorumPeer extends Thread implements QuorumStats.Provider {
+    /**
+     * Create an instance of a quorum peer 
+     */
+    public interface Factory{
+        public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) throws IOException;
+        public NIOServerCnxn.Factory createConnectionFactory() throws IOException;
+    }
+    
+    public static class QuorumServer {
+        public QuorumServer(long id, InetSocketAddress addr) {
+            this.id = id;
+            this.addr = addr;
+        }
+
+        public InetSocketAddress addr;
+
+        public long id;
+    }
+
+    public enum ServerState {
+        LOOKING, FOLLOWING, LEADING;
+    }
+    /**
+     * The servers that make up the cluster
+     */
+    ArrayList<QuorumServer> quorumPeers;
+    public int getQuorumSize(){
+        return quorumPeers.size();
+    }
+    /**
+     * My id
+     */
+    private long myid;
+
+
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getId() {
+        return myid;
+    }
+
+    /**
+     * This is who I think the leader currently is.
+     */
+    volatile Vote currentVote;
+
+    volatile boolean running = true;
+
+    /**
+     * The number of milliseconds of each tick
+     */
+    int tickTime;
+
+    /**
+     * The number of ticks that the initial synchronization phase can take
+     */
+    int initLimit;
+
+    /**
+     * The number of ticks that can pass between sending a request and getting
+     * an acknowledgement
+     */
+    int syncLimit;
+
+    /**
+     * The current tick
+     */
+    int tick;
+
+    /**
+     * This class simply responds to requests for the current leader of this
+     * node.
+     * <p>
+     * The request contains just an xid generated by the requestor.
+     * <p>
+     * The response has the xid, the id of this server, the id of the leader,
+     * and the zxid of the leader.
+     * 
+     * @author breed
+     * 
+     */
+    class ResponderThread extends Thread {
+        ResponderThread() {
+            super(""ResponderThread"");
+        }
+
+        public void run() {
+            try {
+                byte b[] = new byte[36];
+                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
+                DatagramPacket packet = new DatagramPacket(b, b.length);
+                while (true) {
+                    udpSocket.receive(packet);
+                    if (packet.getLength() != 4) {
+                        ZooLog.logError(""Got more than just an xid! Len = ""
+                                + packet.getLength());
+                    } else {
+                        responseBuffer.clear();
+                        responseBuffer.getInt(); // Skip the xid
+                        responseBuffer.putLong(myid);
+                        switch (state) {
+                        case LOOKING:
+                            responseBuffer.putLong(currentVote.id);
+                            responseBuffer.putLong(currentVote.zxid);
+                            break;
+                        case LEADING:
+                            responseBuffer.putLong(myid);
+                            try {
+                                responseBuffer.putLong(leader.lastProposed);
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                            break;
+                        case FOLLOWING:
+                            responseBuffer.putLong(currentVote.id);
+                            try {
+                                responseBuffer.putLong(follower.getZxid());
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                        }
+                        packet.setData(b);
+                        udpSocket.send(packet);
+                    }
+                    packet.setLength(b.length);
+                }
+            } catch (Exception e) {
+                ZooLog.logException(e);
+            } finally {
+                ZooLog.logError(""QuorumPeer responder thread exited"");
+            }
+        }
+    }
+
+    private ServerState state = ServerState.LOOKING;
+    
+    public void setPeerState(ServerState newState){
+        state=newState;
+    }
+    
+    public ServerState getPeerState(){
+        return state;
+    }
+    
+    DatagramSocket udpSocket;
+
+    private InetSocketAddress myQuorumAddr;
+    
+    public InetSocketAddress getQuorumAddress(){
+        return myQuorumAddr;
+    }
+
+    /**
+     * the directory where the snapshot is stored.
+     */
+    private File dataDir;
+
+    /**
+     * the directory where the logs are stored.
+     */
+    private File dataLogDir;
+
+    Election electionAlg;
+
     int electionPort;
 
-    NIOServerCnxn.Factory cnxnFactory;
-
-    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
-            File dataLogDir, int clientPort, int electionAlg, int electionPort,
-            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
-        super(""QuorumPeer"");
-        this.clientPort = clientPort;
-        this.cnxnFactory = new NIOServerCnxn.Factory(clientPort, this);
-        this.quorumPeers = quorumPeers;
-        this.dataDir = dataDir;
-        this.electionAlg = electionAlg;
+    NIOServerCnxn.Factory cnxnFactory;
+
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionAlg, int electionPort,long myid, int tickTime, 
+            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        super(""QuorumPeer"");
+        this.cnxnFactory = cnxnFactory;
+        this.quorumPeers = quorumPeers;
+        this.dataDir = dataDir;
         this.electionPort = electionPort;
-        this.dataLogDir = dataLogDir;
-        this.myid = myid;
-        this.tickTime = tickTime;
-        this.initLimit = initLimit;
-        this.syncLimit = syncLimit;
-        currentVote = new Vote(myid, getLastLoggedZxid());
-        for (QuorumServer p : quorumPeers) {
-            if (p.id == myid) {
-                myQuorumAddr = p.addr;
-                break;
-            }
-        }
-        if (myQuorumAddr == null) {
-            throw new SocketException(""My id "" + myid + "" not in the peer list"");
-        }
-        if (electionAlg == 0) {
-            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-            new ResponderThread().start();
-        }
-    }
-
-    public QuorumPeer() throws IOException {
-    	// use quorum peer config to instantiate the class 
-		this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
-				getClientPort(), getElectionAlg(), getElectionPort(),
-				getServerId(), getTickTime(), getInitLimit(), getSyncLimit());
-	}
-    public Follower follower;
-
-    public Leader leader;
-
-    protected Follower makeFollower() throws IOException {
-		return new Follower(this, new FollowerZooKeeperServer(dataDir,
-				dataLogDir, this));
-	}
-
-	protected Leader makeLeader() throws IOException {
-		return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
-				this));
-	}
-    
-    public void run() {
-
-        /*
-         * Main loop
-         */
-        Election le = null;
-        switch(electionAlg){
-        case 1:
-            le = new AuthFastLeaderElection(this, this.electionPort);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, this.electionPort, true);                break;
-        case 3:
-            le =
-                new FastLeaderElection(this,
-                        new QuorumCnxManager(this.electionPort));
-        }
-
-        while (running) {
-            switch (state) {
-            case LOOKING:
-                try {
-                    ZooLog.logWarn(""LOOKING"");
-                    long init, end, diff;
-                    switch (electionAlg) {
-                    // Legacy algorithm
-                    case 0:
-                       init = System.currentTimeMillis();
-                        currentVote = new LeaderElection(this).lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff + "" "" + currentVote.id);
-                        break;
-                    // All other algorithms
-                    default:
-                        init = System.currentTimeMillis();
-                        if(le != null) currentVote = le.lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff);
-                        break;
-                    } 
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                    state = ServerState.LOOKING;
-                }
-                break;            
-            case FOLLOWING:
-                try {
-                    ZooLog.logWarn(""FOLLOWING"");
-                    follower = makeFollower();
-                    follower.followLeader();
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    follower.shutdown();
-                    follower = null;
-                    state = ServerState.LOOKING;
-                }
-                break;
-            case LEADING:
-                ZooLog.logWarn(""LEADING"");
-                try {
-                    leader = makeLeader();
-                    leader.lead();
-                    leader = null;
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    if (leader != null) {
-                        leader.shutdown(""Forcing shutdown"");
-                    }
-                    state = ServerState.LOOKING;
-                }
-                break;
-            }
-        }
-        ZooLog.logError(""QuorumPeer main thread exited"");
-    }
-
-    public void shutdown() {
-        running = false;
-        if (leader != null) {
-            leader.shutdown(""quorum Peer shutdown"");
-        }
-        if (follower != null) {
-            follower.shutdown();
-        }
-        cnxnFactory.shutdown();
-        udpSocket.close();
-    }
-
-    long getLastLoggedZxid() {
-        File[] list = dataLogDir.listFiles();
-        if (list == null) {
-            return 0;
-        }
-        long maxLog = -1;
-        long maxSnapShot = 0;
-        for (File f : list) {
-            String name = f.getName();
-            if (name.startsWith(""log."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
-                if (zxid > maxLog) {
-                    maxLog = zxid;
-                }
-            } else if (name.startsWith(""snapshot."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
-                        ""snapshot"");
-                if (zxid > maxLog) {
-                    maxSnapShot = zxid;
-                }
-            }
-        }
-        if (maxSnapShot > maxLog) {
-            return maxSnapShot;
-        }
-        long zxid = maxLog;
-        FileInputStream logStream = null;
-        try {
-            logStream = new FileInputStream(new File(dataLogDir, ""log.""
-                    + Long.toHexString(maxLog)));
-            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
-            while (true) {
-                byte[] bytes = ia.readBuffer(""txnEntry"");
-                if (bytes.length == 0) {
-                    // Since we preallocate, we define EOF to be an
-                    // empty transaction
-                    break;
-                }
-                int B = ia.readByte(""EOR"");
-                if (B != 'B') {
-                    break;
-                }
-                InputArchive bia = BinaryInputArchive
-                        .getArchive(new ByteArrayInputStream(bytes));
-                TxnHeader hdr = new TxnHeader();
-                hdr.deserialize(bia, ""hdr"");
-                zxid = hdr.getZxid();
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(e.toString());
-        } finally {
-            try {
-                if (logStream != null) {
-                    logStream.close();
-                }
-            } catch (IOException e) {
-                ZooLog.logException(e);
-            }
-        }
-        return zxid;
-    }
-
-    public static void runPeer(QuorumPeer.Factory qpFactory) {
-		try {
-			QuorumPeer self = qpFactory.create();
-			self.start();
-			self.join();
-		} catch (Exception e) {
-			ZooLog.logException(e);
-		}
-		System.exit(2);
-	}
-    
-    public static void main(String args[]) {
-		if (args.length == 2) {
-			ZooKeeperServer.main(args);
-			return;
-		}
-		QuorumPeerConfig.parse(args);
-		if (!QuorumPeerConfig.isStandalone()) {
-			runPeer(new QuorumPeer.Factory() {
-				public QuorumPeer create() throws IOException {
-					return new QuorumPeer();
-				}
-			});
-		}else{
-			// there is only server in the quorum -- run as standalone
-			ZooKeeperServer.main(args);
-		}
-	}
-}
+        this.dataLogDir = dataLogDir;
+        this.myid = myid;
+        this.tickTime = tickTime;
+        this.initLimit = initLimit;
+        this.syncLimit = syncLimit;
+        currentVote = new Vote(myid, getLastLoggedZxid());
+        for (QuorumServer p : quorumPeers) {
+            if (p.id == myid) {
+                myQuorumAddr = p.addr;
+                break;
+            }
+        }
+        if (myQuorumAddr == null) {
+            throw new SocketException(""My id "" + myid + "" not in the peer list"");
+        }
+        if (electionAlg == 0) {
+            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
+            new ResponderThread().start();
+        }
+        this.electionAlg = createElectionAlgorithm(electionAlg);
+        QuorumStats.getInstance().setStatsProvider(this);
+    }
+
+    /**
+     * This constructor is only used by the existing unit test code.
+     */
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int clientPort, int electionAlg, int electionPort,
+            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
+        this(quorumPeers,dataDir,dataLogDir,electionAlg,electionPort,myid,tickTime,
+                initLimit,syncLimit,new NIOServerCnxn.Factory(clientPort));
+    }
+    /**
+     *  The constructor uses the quorum peer config to instantiate the class
+     */
+    public QuorumPeer(NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
+                getElectionAlg(), getElectionPort(),getServerId(),getTickTime(), 
+                getInitLimit(), getSyncLimit(),cnxnFactory);
+    }
+    
+    public Follower follower;
+    public Leader leader;
+
+    protected Follower makeFollower(File dataDir,File dataLogDir) throws IOException {
+        return new Follower(this, new FollowerZooKeeperServer(dataDir,
+                dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+
+    protected Leader makeLeader(File dataDir,File dataLogDir) throws IOException {
+        return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
+                this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+    
+    private Election createElectionAlgorithm(int electionAlgorithm){
+        Election le=null;
+        //TODO: use a factory rather than a switch
+        switch (electionAlgorithm) {
+        case 0:
+            // will create a new instance for each run of the protocol
+            break;
+        case 1:
+            le = new AuthFastLeaderElection(this, this.electionPort);
+            break;
+        case 2:
+            le = new AuthFastLeaderElection(this, this.electionPort, true); 
+            break;
+        case 3:
+            le = new FastLeaderElection(this,
+                        new QuorumCnxManager(this.electionPort));
+        default:
+            assert false;
+        }
+        return le;       
+    }
+    
+    protected Election makeLEStrategy(){
+        if(electionAlg==null)
+            return new LeaderElection(this);
+        return electionAlg;
+    }
+    
+    synchronized protected void setLeader(Leader newLeader){
+        leader=newLeader;
+    }
+
+    synchronized protected void setFollower(Follower newFollower){
+        follower=newFollower;
+    }
+    
+    synchronized public ZooKeeperServer getActiveServer(){
+        if(leader!=null)
+            return leader.zk;
+        else if(follower!=null)
+            return follower.zk;
+        return null;
+    }
+    
+    public void run() {
+        /*
+         * Main loop
+         */
+        while (running) {
+            switch (state) {
+            case LOOKING:
+                try {
+                    ZooLog.logWarn(""LOOKING"");
+                    currentVote = makeLEStrategy().lookForLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case FOLLOWING:
+                try {
+                    ZooLog.logWarn(""FOLLOWING"");
+                    setFollower(makeFollower(dataDir,dataLogDir));
+                    follower.followLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    follower.shutdown();
+                    setFollower(null);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case LEADING:
+                ZooLog.logWarn(""LEADING"");
+                try {
+                    setLeader(makeLeader(dataDir,dataLogDir));
+                    leader.lead();
+                    setLeader(null);
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    if (leader != null) {
+                        leader.shutdown(""Forcing shutdown"");
+                        setLeader(null);
+                    }
+                    state = ServerState.LOOKING;
+                }
+                break;
+            }
+        }
+        ZooLog.logError(""QuorumPeer main thread exited"");
+    }
+
+    public void shutdown() {
+        running = false;
+        if (leader != null) {
+            leader.shutdown(""quorum Peer shutdown"");
+        }
+        if (follower != null) {
+            follower.shutdown();
+        }
+        cnxnFactory.shutdown();
+        udpSocket.close();
+    }
+
+    long getLastLoggedZxid() {
+        File[] list = dataLogDir.listFiles();
+        if (list == null) {
+            return 0;
+        }
+        long maxLog = -1;
+        long maxSnapShot = 0;
+        for (File f : list) {
+            String name = f.getName();
+            if (name.startsWith(""log."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
+                if (zxid > maxLog) {
+                    maxLog = zxid;
+                }
+            } else if (name.startsWith(""snapshot."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
+                        ""snapshot"");
+                if (zxid > maxLog) {
+                    maxSnapShot = zxid;
+                }
+            }
+        }
+        if (maxSnapShot > maxLog) {
+            return maxSnapShot;
+        }
+        long zxid = maxLog;
+        FileInputStream logStream = null;
+        try {
+            logStream = new FileInputStream(new File(dataLogDir, ""log.""
+                    + Long.toHexString(maxLog)));
+            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
+            while (true) {
+                byte[] bytes = ia.readBuffer(""txnEntry"");
+                if (bytes.length == 0) {
+                    // Since we preallocate, we define EOF to be an
+                    // empty transaction
+                    break;
+                }
+                int B = ia.readByte(""EOR"");
+                if (B != 'B') {
+                    break;
+                }
+                InputArchive bia = BinaryInputArchive
+                        .getArchive(new ByteArrayInputStream(bytes));
+                TxnHeader hdr = new TxnHeader();
+                hdr.deserialize(bia, ""hdr"");
+                zxid = hdr.getZxid();
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(e.toString());
+        } finally {
+            try {
+                if (logStream != null) {
+                    logStream.close();
+                }
+            } catch (IOException e) {
+                ZooLog.logException(e);
+            }
+        }
+        return zxid;
+    }
+
+    public static void runPeer(QuorumPeer.Factory qpFactory) {
+        try {
+            QuorumStats.registerAsConcrete();
+            QuorumPeer self = qpFactory.create(qpFactory.createConnectionFactory());
+            self.start();
+            self.join();
+        } catch (Exception e) {
+            ZooLog.logException(e);
+        }
+        System.exit(2);
+    }
+    
+    public String[] getQuorumPeers() {
+        List<String> l = new ArrayList<String>();
+        synchronized (this) {
+            if (leader != null) {
+                synchronized (leader.followers) {
+                    for (FollowerHandler fh : leader.followers) {
+                        if (fh.s == null)
+                            continue;
+                        String s = fh.s.getRemoteSocketAddress().toString();
+                        if (leader.isFollowerSynced(fh))
+                            s += ""*"";
+                        l.add(s);
+                    }
+                }
+            } else if (follower != null) {
+                l.add(follower.sock.getRemoteSocketAddress().toString());
+            }
+        }
+        return l.toArray(new String[0]);
+    }
+
+    public String getServerState() {
+        switch (state) {
+        case LOOKING:
+            return QuorumStats.Provider.LOOKING_STATE;
+        case LEADING:
+            return QuorumStats.Provider.LEADING_STATE;
+        case FOLLOWING:
+            return QuorumStats.Provider.FOLLOWING_STATE;
+        }
+        return QuorumStats.Provider.UNKNOWN_STATE;
+    }
+
+    public static void main(String args[]) {
+        if (args.length == 2) {
+            ZooKeeperServer.main(args);
+            return;
+        }
+        QuorumPeerConfig.parse(args);
+        if (!QuorumPeerConfig.isStandalone()) {
+            runPeer(new QuorumPeer.Factory() {
+                public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) 
+                        throws IOException {
+                    return new QuorumPeer(cnxnFactory);
+                }
+                public NIOServerCnxn.Factory createConnectionFactory()
+                        throws IOException {
+                    return new NIOServerCnxn.Factory(getClientPort());
+                }
+            });
+        }else{
+            // there is only server in the quorum -- run as standalone
+            ZooKeeperServer.main(args);
+        }
+    }
+}
",,6461
2245,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,d56cc9b9acb453945257a8e3b0cf8d88e5a36d35,1204726342,503,,,,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,-1,1207349605/1204726342,"            recvWorker = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-import java.lang.InterruptedException;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Random;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.net.SocketAddress;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SocketChannel;
-import java.nio.channels.ServerSocketChannel;
-
-import com.yahoo.zookeeper.server.ZooLog;
-
-/**
- * This class implements a connection manager for leader election using TCP. It
- * maintains one coonection for every pair of servers. The tricky part is to
- * guarantee that there is exactly one connection for every pair of servers that
- * are operating correctly and that can communicate over the network.
- * 
- * If two servers try to start a connection concurrently, then the connection
- * manager uses a very simple tie-breaking mechanism to decide which connection
- * to drop based on the IP addressed of the two parties. 
- * 
- * For every peer, the manager maintains a queue of messages to send. If the
- * connection to any particular peer drops, then the sender thread puts the
- * message back on the list. As this implementation currently uses a queue
- * implementation to maintain messages to send to another peer, we add the
- * message to the tail of the queue, thus changing the order of messages.
- * Although this is not a problem for the leader election, it could be a problem
- * when consolidating peer communication. This is to be verified, though.
- * 
- */
-
-class QuorumCnxManager extends Thread {
-    /*
-     * Maximum capacity of thread queues
-     */
-
-    static final int CAPACITY = 100;
-
-    /*
-     * Maximum number of attempts to connect to a peer
-     */
-
-    static final int MAX_CONNECTION_ATTEMPTS = 2;
-
-    /*
-     * Packet size
-     */
-    int packetSize;
-
-    /*
-     * Port to listen on
-     */
-    int port;
-
-    /*
-     * Challenge to initiate connections
-     */
-    long challenge;
-
-    /*
-     * Local IP address
-     */
-    InetAddress localIP;
-
-    /*
-     * Mapping from Peer to Thread number
-     */
-    HashMap<InetAddress, SendWorker> senderWorkerMap;
-    HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
-
-    /*
-     * Reception queue
-     */
-    ArrayBlockingQueue<Message> recvQueue;
-
-    /*
-     * Shutdown flag
-     */
-
-    boolean shutdown = false;
-
-    /*
-     * Listener thread
-     */
-    Listener listener;
-
-    class Message {
-        Message(ByteBuffer buffer, InetAddress addr) {
-            this.buffer = buffer;
-            this.addr = addr;
-        }
-
-        ByteBuffer buffer;
-        InetAddress addr;
-    }
-
-    QuorumCnxManager(int port) {
-        this.port = port;
-        this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
-        this.queueSendMap = new HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>>();
-        this.senderWorkerMap = new HashMap<InetAddress, SendWorker>();
-
-        try {
-            localIP = InetAddress.getLocalHost();
-        } catch (UnknownHostException e) {
-            ZooLog.logWarn(""Couldn't get local address"");
-        }
-
-        // Generates a challenge to guarantee one connection between pairs of
-        // servers
-        genChallenge();
-
-        // Starts listener thread that waits for connection requests 
-        listener = new Listener(this);
-        listener.start();
-    }
-
-    void genChallenge() {
-        Random rand = new Random(System.currentTimeMillis()
-                + localIP.hashCode());
-        long newValue = rand.nextLong();
-        challenge = newValue;
-    }
-
-    /**
-     * If this server has initiated the connection, then it gives up on the
-     * connection if it loses challenge. Otherwise, it keeps the connection.
-     */
-
-    boolean initiateConnection(SocketChannel s) {
-        boolean challenged = true;
-        boolean wins = false;
-        long newChallenge;
-
-        // Compare IP addresses based on their hash codes 
-        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
-        //if(hashCodeRemote >= localIP.hashCode()){
-        //    wins = false;
-        //} else {
-        //    wins = true;
-        //} 
-        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
-        
-        try {
-            while (challenged && s.isConnected()) {
-                // Sending challenge
-                byte[] msgBytes = new byte[8];
-                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                msgBuffer.putLong(challenge);
-                msgBuffer.position(0);
-                s.write(msgBuffer);
-        
-                      // Reading challenge
-                    msgBuffer.position(0);
-                  int numBytes = s.read(msgBuffer);
-        
-                 msgBuffer.position(0);
-               newChallenge = msgBuffer.getLong();
-                if (challenge > newChallenge) {
-                   wins = true;
-                    challenged = false;
-                } else if (challenge == newChallenge) {
-                    genChallenge();
-                } else {
-                    challenged = false;
-                }
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(""Exception reading or writing challenge: ""
-                    + e.toString());
-            return false;
-        }
-
-        // If lost the challenge, then drop the new connection
-        if (!wins) {
-            try {
-                //ZooLog.logWarn(""lost cause (initiate"");
-                s.socket().close();
-            } catch (IOException e) {
-                ZooLog
-                        .logWarn(""Error when closing socket or trying to reopen connection: ""
-                                + e.toString());
-
-            }
-        // Otherwise proceed with the connection
-        } else
-            synchronized (senderWorkerMap) {
-                /*
-                 * It may happen that a thread from a previous connection to the same
-                 * server is still active. In this case, we terminate the thread by
-                 * calling finish(). Note that senderWorkerMap is a map from IP 
-                 * addresses to worker thread.
-                 */
-                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
-                    senderWorkerMap.get(s.socket().getInetAddress()).finish();
-                }
-
-                /*
-                 * Start new worker thread with a clean state.
-                 */
-                SendWorker sw = new SendWorker(s);
-                if (s != null) {
-                    RecvWorker rw = new RecvWorker(s);
-                    sw.setRecv(rw);
-
-                    if (senderWorkerMap
-                            .containsKey(s.socket().getInetAddress())) {
-                        InetAddress addr = s.socket().getInetAddress();
-                        senderWorkerMap.get(addr).finish();
-                    }
-
-                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
-                    sw.start();
-                    rw.start();
-
-                    return true;
-                } else {
-                    ZooLog.logWarn(""Channel null"");
-                    return false;
-                }
-            }
-
-        return false;
-    }
-
-    /**
-     * If this server receives a connection request, then it gives up on the new
-     * connection if it wins. Notice that it checks whether it has a connection
-     * to this server already or not. If it does, then it sends the smallest
-     * possible long value to lose the challenge.
-     * 
-     */
-    boolean receiveConnection(SocketChannel s) {
-        boolean challenged = true;
-        boolean wins = false;
-        long newChallenge;
-       
-        
-        //Compare IP addresses based on their hash codes.
-        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
-        //if(hashCodeRemote >= localIP.hashCode()){
-        //    wins = false;
-        //} else {
-        //    wins = true;
-        //} 
-        
-        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
-        
-        
-        try {
-            while (challenged && s.isConnected()) {
-               // Sending challenge
-                byte[] msgBytes = new byte[8];
-                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                long vsent;
-                if (senderWorkerMap.get(s.socket().getInetAddress()) == null)
-                    vsent = Long.MIN_VALUE;
-                else
-                    vsent = challenge;
-                msgBuffer.putLong(vsent);
-                msgBuffer.position(0);
-                s.write(msgBuffer);
-        
-                // Reading challenge
-                msgBuffer.position(0);
-                int numBytes = s.read(msgBuffer);
-        
-                msgBuffer.position(0);
-                newChallenge = msgBuffer.getLong();
-                if (vsent > newChallenge) {
-                    wins = true;
-                    challenged = false;
-                } else if (challenge == newChallenge) {
-                    genChallenge();
-                } else {
-                    challenged = false;
-                }
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(""Exception reading or writing challenge: ""
-                    + e.toString());
-            return false;
-        }
-
-        //If wins the challenge, then close the new connection.
-        if (wins) {
-            try {
-                InetAddress addr = s.socket().getInetAddress();
-                SendWorker sw = senderWorkerMap.get(addr);
-
-                //ZooLog.logWarn(""Keep connection (received)"");
-                //sw.connect();
-                s.socket().close();
-                sw.finish();
-                SocketChannel channel = SocketChannel.open(new InetSocketAddress(addr, port));
-                if (channel.isConnected()) {
-                    initiateConnection(channel);
-                }
-                
-                
-            } catch (IOException e) {
-                ZooLog
-                        .logWarn(""Error when closing socket or trying to reopen connection: ""
-                                + e.toString());
-            }
-        //Otherwise start worker threads to receive data.
-        } else
-            synchronized (senderWorkerMap) {
-                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
-                    senderWorkerMap.get(s.socket().getInetAddress()).finish();       
-                }
-                
-                SendWorker sw = new SendWorker(s);
-                if (s != null) {
-                    RecvWorker rw = new RecvWorker(s);
-                    sw.setRecv(rw);
-
-                    if (senderWorkerMap
-                            .containsKey(s.socket().getInetAddress())) {
-                        InetAddress addr = s.socket().getInetAddress();
-                        senderWorkerMap.get(addr).finish();
-                    }
-
-                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
-                    sw.start();
-                    rw.start();
-
-                    return true;
-                } else {
-                    ZooLog.logWarn(""Channel null"");
-                    return false;
-                }
-            }
-
-        return false;
-    }
-
-    /**
-     * Processes invoke this message to send a message. Currently, only leader
-     * election uses it.
-     */
-    void toSend(InetAddress addr, ByteBuffer b) {
-        /*
-         * If sending message to myself, then simply enqueue it (loopback).
-         */
-        if (addr.equals(localIP)) {
-            try {
-                b.position(0);
-                recvQueue.put(new Message(b.duplicate(), addr));
-            } catch (InterruptedException e) {
-                ZooLog.logWarn(""Exception when loopbacking"");
-            }
-        /*
-         * Otherwise send to the corresponding thread to send. 
-         */
-        } else
-            try {
-                /*
-                 * Start a new connection if doesn't have one already.
-                 */
-                if (!queueSendMap.containsKey(addr)) {
-                    queueSendMap.put(addr, new ArrayBlockingQueue<ByteBuffer>(
-                            CAPACITY));
-                    queueSendMap.get(addr).put(b);
-
-                } else {
-                    if (queueSendMap.get(addr).remainingCapacity() == 0) {
-                        queueSendMap.get(addr).take();
-                    }
-                    queueSendMap.get(addr).put(b);
-                }
-                
-                synchronized (senderWorkerMap) {
-                    if (senderWorkerMap.get(addr) == null) {
-                        SocketChannel channel;
-                        try {
-                            channel = SocketChannel
-                                    .open(new InetSocketAddress(addr, port));
-                            channel.socket().setTcpNoDelay(true);
-                            initiateConnection(channel);
-                        } catch (IOException e) {
-                            ZooLog.logWarn(""Cannot open channel to ""
-                                    + addr.toString() + ""( "" + e.toString()
-                                    + "")"");
-                        }
-                    }
-                }     
-            } catch (InterruptedException e) {
-                ZooLog
-                        .logWarn(""Interrupted while waiting to put message in queue.""
-                                + e.toString());
-            }
-    }
-
-    /**
-     * Check if all queues are empty, indicating that all messages have been delivered.
-     */
-    boolean haveDelivered() {
-        for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
-            if (queue.size() == 0)
-                return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * Flag that it is time to wrap up all activities and interrupt the listener.
-     */
-    public void shutdown() {
-        shutdown = true;
-        listener.interrupt();
-    }
-
-    /**
-     * Thread to listen on some port
-     */
-    class Listener extends Thread {
-        QuorumCnxManager manager;
-
-        Listener(QuorumCnxManager m) {
-            manager = m;
-        }
-
-        /**
-         * Sleeps on accept().
-         */
-        public void run() {
-            ServerSocketChannel ss = null;
-            try {
-                if (ss != null)
-                    ss.close();
-                ss = ServerSocketChannel.open();
-                ss.socket().bind(new InetSocketAddress(port));
-
-                while (!shutdown) {
-                    SocketChannel client = ss.accept();
-                    client.socket().setTcpNoDelay(true);
-                    /*
-                     * This synchronized block guarantees that if
-                     * both parties try to connect to each other
-                     * simultaneously, then only one will succeed.
-                     * If we don't have this block, then there 
-                     * are runs in which both parties act as if they
-                     * don't have any connection starting or started.
-                     * In receiveConnection(), a server sends the minimum
-                     * value for a challenge, if they believe they must
-                     * accept the connection because they don't have one.
-                     * 
-                     * This synchronized block prevents that the same server
-                     * invokes receiveConnection() and initiateConnection() 
-                     * simultaneously.
-                     */
-                    synchronized(senderWorkerMap){
-                        ZooLog.logWarn(""Connection request"");
-                        receiveConnection(client);
-                    }
-                }
-            } catch (IOException e) {
-                System.err.println(""Listener.run: "" + e.getMessage());
-            }
-        }
-    }
-
-    /**
-     * Thread to send messages. Instance waits on a queue, and send a message as
-     * soon as there is one available. If connection breaks, then opens a new
-     * one.
-     */
-
-    class SendWorker extends Thread {
-        // Send msgs to peer
-        InetAddress addr;
-        SocketChannel channel;
-        RecvWorker recvWorker;
-        boolean running = true;
-
-        SendWorker(SocketChannel channel) {
-            this.addr = channel.socket().getInetAddress();
-            this.channel = channel;
-            recvWorker = null;
-        }
-
-        void setRecv(RecvWorker recvWorker) {
-            this.recvWorker = recvWorker;
-        }
-
-        //boolean connect() throws IOException {
-        //    if (recvWorker != null)
-        //        recvWorker.finish();
-        //
-        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
-        //    if (channel.isConnected()) {
-        //        recvWorker = new RecvWorker(channel);
-        //        initiateConnection(channel);
-        //        ZooLog.logWarn(""Opened new connection"");
-        //    } else {
-        //        ZooLog.logWarn(""Channel not connected."");
-        //    }
-        //
-        //    return channel.isConnected();
-        //}
-
-        boolean finish() {
-            running = false;
-
-            this.interrupt();
-            if (recvWorker != null)
-                recvWorker.finish();
-            senderWorkerMap.remove(channel.socket().getInetAddress());
-            return running;
-        }
-
-        public void run() {
-
-            long init, init1, end1, end;
-            while (running && !shutdown) {
-
-                ByteBuffer b = null;
-                try {
-                    init = System.currentTimeMillis();
-                    b = queueSendMap.get(addr).take();
-                } catch (InterruptedException e) {
-                    ZooLog
-                            .logWarn(""Interrupted while waiting for message on queue (""
-                                    + e.toString() + "")"");
-                    continue;
-                }
-
-                try {
-                    byte[] msgBytes = new byte[b.capacity()
-                            + (Integer.SIZE / 8)];
-                    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                    msgBuffer.putInt(b.capacity());
-                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
-
-                    msgBuffer.put(b.array(), 0, b.capacity());
-                    msgBuffer.position(0);
-                    int numbytes = channel.write(msgBuffer);
-                    end = System.currentTimeMillis() - init;
-
-                } catch (IOException e) {
-                    /*
-                     * If reconnection doesn't work, then put the
-                     * message back to the beginning of the queue and leave.
-                     */
-                    ZooLog.logWarn(""Exception when using channel: "" + addr
-                            + "")"" + e.toString());
-                    running = false;
-                    synchronized (senderWorkerMap) {
-                        recvWorker.finish();
-                        recvWorker = null;
-                    
-                        senderWorkerMap.remove(channel.socket().getInetAddress());
-                    
-                        if (b != null) {
-                            if (queueSendMap.get(channel.socket().getInetAddress())
-                                    .size() == 0)
-                                queueSendMap.get(channel.socket().getInetAddress())
-                                    .offer(b);
-                        }
-                    }
-                }
-            }
-            ZooLog.logWarn(""Leaving thread"");
-        }
-    }
-
-    /**
-     * Thread to receive messages. Instance waits on a socket read. If the
-     * channel breaks, then removes itself from the pool of receivers.
-     */
-
-    class RecvWorker extends Thread {
-        InetAddress addr;
-        SocketChannel channel;
-        boolean running = true;
-
-        RecvWorker(SocketChannel channel) {
-            this.addr = channel.socket().getInetAddress();
-            this.channel = channel;
-        }
-
-        boolean finish() {
-            running = false;
-            this.interrupt();
-            return running;
-        }
-
-        public void run() {
-            try {
-                byte[] size = new byte[4];
-                ByteBuffer msgLength = ByteBuffer.wrap(size);
-                while (running && !shutdown && channel.isConnected()) {
-                    /**
-                     * Reads the first int to determine the length of the
-                     * message
-                     */
-                    while (msgLength.hasRemaining()) {
-                        channel.read(msgLength);
-                    }
-                    msgLength.position(0);
-                    int length = msgLength.getInt();
-
-                    /**
-                     * Allocates a new ByteBuffer to receive the message
-                     */
-                    if (length > 0) {
-                        byte[] msgArray = new byte[length];
-                        ByteBuffer message = ByteBuffer.wrap(msgArray);
-                        int numbytes = 0;
-                        while (message.hasRemaining()) {
-                            numbytes += channel.read(message);
-                        }
-                        message.position(0);
-                        synchronized (recvQueue) {
-                            recvQueue
-                                    .put(new Message(message.duplicate(), addr));
-                        }
-                        msgLength.position(0);
-                    }
-                }
-
-            } catch (IOException e) {
-                ZooLog.logWarn(""Connection broken: "" + e.toString());
-
-            } catch (InterruptedException e) {
-                ZooLog.logWarn(""Interrupted while trying to add new ""
-                        + ""message to the reception queue ("" + e.toString()
-                        + "")"");
-            }
-        }
-    }
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+import java.util.HashMap;
+import java.util.Random;
+import java.util.concurrent.ArrayBlockingQueue;
+
+import com.yahoo.zookeeper.server.ZooLog;
+
+/**
+ * This class implements a connection manager for leader election using TCP. It
+ * maintains one coonection for every pair of servers. The tricky part is to
+ * guarantee that there is exactly one connection for every pair of servers that
+ * are operating correctly and that can communicate over the network.
+ * 
+ * If two servers try to start a connection concurrently, then the connection
+ * manager uses a very simple tie-breaking mechanism to decide which connection
+ * to drop based on the IP addressed of the two parties. 
+ * 
+ * For every peer, the manager maintains a queue of messages to send. If the
+ * connection to any particular peer drops, then the sender thread puts the
+ * message back on the list. As this implementation currently uses a queue
+ * implementation to maintain messages to send to another peer, we add the
+ * message to the tail of the queue, thus changing the order of messages.
+ * Although this is not a problem for the leader election, it could be a problem
+ * when consolidating peer communication. This is to be verified, though.
+ * 
+ */
+
+class QuorumCnxManager extends Thread {
+    /*
+     * Maximum capacity of thread queues
+     */
+
+    static final int CAPACITY = 100;
+
+    /*
+     * Maximum number of attempts to connect to a peer
+     */
+
+    static final int MAX_CONNECTION_ATTEMPTS = 2;
+
+    /*
+     * Packet size
+     */
+    int packetSize;
+
+    /*
+     * Port to listen on
+     */
+    int port;
+
+    /*
+     * Challenge to initiate connections
+     */
+    long challenge;
+
+    /*
+     * Local IP address
+     */
+    InetAddress localIP;
+
+    /*
+     * Mapping from Peer to Thread number
+     */
+    HashMap<InetAddress, SendWorker> senderWorkerMap;
+    HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
+
+    /*
+     * Reception queue
+     */
+    ArrayBlockingQueue<Message> recvQueue;
+
+    /*
+     * Shutdown flag
+     */
+
+    boolean shutdown = false;
+
+    /*
+     * Listener thread
+     */
+    Listener listener;
+
+    class Message {
+        Message(ByteBuffer buffer, InetAddress addr) {
+            this.buffer = buffer;
+            this.addr = addr;
+        }
+
+        ByteBuffer buffer;
+        InetAddress addr;
+    }
+
+    QuorumCnxManager(int port) {
+        this.port = port;
+        this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
+        this.queueSendMap = new HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>>();
+        this.senderWorkerMap = new HashMap<InetAddress, SendWorker>();
+
+        try {
+            localIP = InetAddress.getLocalHost();
+        } catch (UnknownHostException e) {
+            ZooLog.logWarn(""Couldn't get local address"");
+        }
+
+        // Generates a challenge to guarantee one connection between pairs of
+        // servers
+        genChallenge();
+
+        // Starts listener thread that waits for connection requests 
+        listener = new Listener(this);
+        listener.start();
+    }
+
+    void genChallenge() {
+        Random rand = new Random(System.currentTimeMillis()
+                + localIP.hashCode());
+        long newValue = rand.nextLong();
+        challenge = newValue;
+    }
+
+    /**
+     * If this server has initiated the connection, then it gives up on the
+     * connection if it loses challenge. Otherwise, it keeps the connection.
+     */
+
+    boolean initiateConnection(SocketChannel s) {
+        boolean challenged = true;
+        boolean wins = false;
+        long newChallenge;
+
+        // Compare IP addresses based on their hash codes 
+        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
+        //if(hashCodeRemote >= localIP.hashCode()){
+        //    wins = false;
+        //} else {
+        //    wins = true;
+        //} 
+        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
+        
+        try {
+            while (challenged && s.isConnected()) {
+                // Sending challenge
+                byte[] msgBytes = new byte[8];
+                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                msgBuffer.putLong(challenge);
+                msgBuffer.position(0);
+                s.write(msgBuffer);
+        
+                      // Reading challenge
+                    msgBuffer.position(0);
+                  int numBytes = s.read(msgBuffer);
+        
+                 msgBuffer.position(0);
+               newChallenge = msgBuffer.getLong();
+                if (challenge > newChallenge) {
+                   wins = true;
+                    challenged = false;
+                } else if (challenge == newChallenge) {
+                    genChallenge();
+                } else {
+                    challenged = false;
+                }
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(""Exception reading or writing challenge: ""
+                    + e.toString());
+            return false;
+        }
+
+        // If lost the challenge, then drop the new connection
+        if (!wins) {
+            try {
+                //ZooLog.logWarn(""lost cause (initiate"");
+                s.socket().close();
+            } catch (IOException e) {
+                ZooLog
+                        .logWarn(""Error when closing socket or trying to reopen connection: ""
+                                + e.toString());
+
+            }
+        // Otherwise proceed with the connection
+        } else
+            synchronized (senderWorkerMap) {
+                /*
+                 * It may happen that a thread from a previous connection to the same
+                 * server is still active. In this case, we terminate the thread by
+                 * calling finish(). Note that senderWorkerMap is a map from IP 
+                 * addresses to worker thread.
+                 */
+                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
+                    senderWorkerMap.get(s.socket().getInetAddress()).finish();
+                }
+
+                /*
+                 * Start new worker thread with a clean state.
+                 */
+                SendWorker sw = new SendWorker(s);
+                if (s != null) {
+                    RecvWorker rw = new RecvWorker(s);
+                    sw.setRecv(rw);
+
+                    if (senderWorkerMap
+                            .containsKey(s.socket().getInetAddress())) {
+                        InetAddress addr = s.socket().getInetAddress();
+                        senderWorkerMap.get(addr).finish();
+                    }
+
+                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
+                    sw.start();
+                    rw.start();
+
+                    return true;
+                } else {
+                    ZooLog.logWarn(""Channel null"");
+                    return false;
+                }
+            }
+
+        return false;
+    }
+
+    /**
+     * If this server receives a connection request, then it gives up on the new
+     * connection if it wins. Notice that it checks whether it has a connection
+     * to this server already or not. If it does, then it sends the smallest
+     * possible long value to lose the challenge.
+     * 
+     */
+    boolean receiveConnection(SocketChannel s) {
+        boolean challenged = true;
+        boolean wins = false;
+        long newChallenge;
+       
+        
+        //Compare IP addresses based on their hash codes.
+        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
+        //if(hashCodeRemote >= localIP.hashCode()){
+        //    wins = false;
+        //} else {
+        //    wins = true;
+        //} 
+        
+        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
+        
+        
+        try {
+            while (challenged && s.isConnected()) {
+               // Sending challenge
+                byte[] msgBytes = new byte[8];
+                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                long vsent;
+                if (senderWorkerMap.get(s.socket().getInetAddress()) == null)
+                    vsent = Long.MIN_VALUE;
+                else
+                    vsent = challenge;
+                msgBuffer.putLong(vsent);
+                msgBuffer.position(0);
+                s.write(msgBuffer);
+        
+                // Reading challenge
+                msgBuffer.position(0);
+                s.read(msgBuffer);
+        
+                msgBuffer.position(0);
+                newChallenge = msgBuffer.getLong();
+                if (vsent > newChallenge) {
+                    wins = true;
+                    challenged = false;
+                } else if (challenge == newChallenge) {
+                    genChallenge();
+                } else {
+                    challenged = false;
+                }
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(""Exception reading or writing challenge: ""
+                    + e.toString());
+            return false;
+        }
+
+        //If wins the challenge, then close the new connection.
+        if (wins) {
+            try {
+                InetAddress addr = s.socket().getInetAddress();
+                SendWorker sw = senderWorkerMap.get(addr);
+
+                //ZooLog.logWarn(""Keep connection (received)"");
+                //sw.connect();
+                s.socket().close();
+                sw.finish();
+                SocketChannel channel = SocketChannel.open(new InetSocketAddress(addr, port));
+                if (channel.isConnected()) {
+                    initiateConnection(channel);
+                }
+                
+                
+            } catch (IOException e) {
+                ZooLog
+                        .logWarn(""Error when closing socket or trying to reopen connection: ""
+                                + e.toString());
+            }
+        //Otherwise start worker threads to receive data.
+        } else
+            synchronized (senderWorkerMap) {
+                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
+                    senderWorkerMap.get(s.socket().getInetAddress()).finish();       
+                }
+                
+                SendWorker sw = new SendWorker(s);
+                if (s != null) {
+                    RecvWorker rw = new RecvWorker(s);
+                    sw.setRecv(rw);
+
+                    if (senderWorkerMap
+                            .containsKey(s.socket().getInetAddress())) {
+                        InetAddress addr = s.socket().getInetAddress();
+                        senderWorkerMap.get(addr).finish();
+                    }
+
+                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
+                    sw.start();
+                    rw.start();
+
+                    return true;
+                } else {
+                    ZooLog.logWarn(""Channel null"");
+                    return false;
+                }
+            }
+
+        return false;
+    }
+
+    /**
+     * Processes invoke this message to send a message. Currently, only leader
+     * election uses it.
+     */
+    void toSend(InetAddress addr, ByteBuffer b) {
+        /*
+         * If sending message to myself, then simply enqueue it (loopback).
+         */
+        if (addr.equals(localIP)) {
+            try {
+                b.position(0);
+                recvQueue.put(new Message(b.duplicate(), addr));
+            } catch (InterruptedException e) {
+                ZooLog.logWarn(""Exception when loopbacking"");
+            }
+        /*
+         * Otherwise send to the corresponding thread to send. 
+         */
+        } else
+            try {
+                /*
+                 * Start a new connection if doesn't have one already.
+                 */
+                if (!queueSendMap.containsKey(addr)) {
+                    queueSendMap.put(addr, new ArrayBlockingQueue<ByteBuffer>(
+                            CAPACITY));
+                    queueSendMap.get(addr).put(b);
+
+                } else {
+                    if (queueSendMap.get(addr).remainingCapacity() == 0) {
+                        queueSendMap.get(addr).take();
+                    }
+                    queueSendMap.get(addr).put(b);
+                }
+                
+                synchronized (senderWorkerMap) {
+                    if (senderWorkerMap.get(addr) == null) {
+                        SocketChannel channel;
+                        try {
+                            channel = SocketChannel
+                                    .open(new InetSocketAddress(addr, port));
+                            channel.socket().setTcpNoDelay(true);
+                            initiateConnection(channel);
+                        } catch (IOException e) {
+                            ZooLog.logWarn(""Cannot open channel to ""
+                                    + addr.toString() + ""( "" + e.toString()
+                                    + "")"");
+                        }
+                    }
+                }     
+            } catch (InterruptedException e) {
+                ZooLog
+                        .logWarn(""Interrupted while waiting to put message in queue.""
+                                + e.toString());
+            }
+    }
+
+    /**
+     * Check if all queues are empty, indicating that all messages have been delivered.
+     */
+    boolean haveDelivered() {
+        for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
+            if (queue.size() == 0)
+                return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Flag that it is time to wrap up all activities and interrupt the listener.
+     */
+    public void shutdown() {
+        shutdown = true;
+        listener.interrupt();
+    }
+
+    /**
+     * Thread to listen on some port
+     */
+    class Listener extends Thread {
+        QuorumCnxManager manager;
+
+        Listener(QuorumCnxManager m) {
+            manager = m;
+        }
+
+        /**
+         * Sleeps on accept().
+         */
+        public void run() {
+            ServerSocketChannel ss = null;
+            try {
+                if (ss != null)
+                    ss.close();
+                ss = ServerSocketChannel.open();
+                ss.socket().bind(new InetSocketAddress(port));
+
+                while (!shutdown) {
+                    SocketChannel client = ss.accept();
+                    client.socket().setTcpNoDelay(true);
+                    /*
+                     * This synchronized block guarantees that if
+                     * both parties try to connect to each other
+                     * simultaneously, then only one will succeed.
+                     * If we don't have this block, then there 
+                     * are runs in which both parties act as if they
+                     * don't have any connection starting or started.
+                     * In receiveConnection(), a server sends the minimum
+                     * value for a challenge, if they believe they must
+                     * accept the connection because they don't have one.
+                     * 
+                     * This synchronized block prevents that the same server
+                     * invokes receiveConnection() and initiateConnection() 
+                     * simultaneously.
+                     */
+                    synchronized(senderWorkerMap){
+                        ZooLog.logWarn(""Connection request"");
+                        receiveConnection(client);
+                    }
+                }
+            } catch (IOException e) {
+                System.err.println(""Listener.run: "" + e.getMessage());
+            }
+        }
+    }
+
+    /**
+     * Thread to send messages. Instance waits on a queue, and send a message as
+     * soon as there is one available. If connection breaks, then opens a new
+     * one.
+     */
+
+    class SendWorker extends Thread {
+        // Send msgs to peer
+        InetAddress addr;
+        SocketChannel channel;
+        RecvWorker recvWorker;
+        boolean running = true;
+
+        SendWorker(SocketChannel channel) {
+            this.addr = channel.socket().getInetAddress();
+            this.channel = channel;
+            recvWorker = null;
+        }
+
+        void setRecv(RecvWorker recvWorker) {
+            this.recvWorker = recvWorker;
+        }
+
+        //boolean connect() throws IOException {
+        //    if (recvWorker != null)
+        //        recvWorker.finish();
+        //
+        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
+        //    if (channel.isConnected()) {
+        //        recvWorker = new RecvWorker(channel);
+        //        initiateConnection(channel);
+        //        ZooLog.logWarn(""Opened new connection"");
+        //    } else {
+        //        ZooLog.logWarn(""Channel not connected."");
+        //    }
+        //
+        //    return channel.isConnected();
+        //}
+
+        boolean finish() {
+            running = false;
+
+            this.interrupt();
+            if (recvWorker != null)
+                recvWorker.finish();
+            senderWorkerMap.remove(channel.socket().getInetAddress());
+            return running;
+        }
+
+        public void run() {
+
+            long init, init1, end1, end;
+            while (running && !shutdown) {
+
+                ByteBuffer b = null;
+                try {
+                    init = System.currentTimeMillis();
+                    b = queueSendMap.get(addr).take();
+                } catch (InterruptedException e) {
+                    ZooLog
+                            .logWarn(""Interrupted while waiting for message on queue (""
+                                    + e.toString() + "")"");
+                    continue;
+                }
+
+                try {
+                    byte[] msgBytes = new byte[b.capacity()
+                            + (Integer.SIZE / 8)];
+                    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                    msgBuffer.putInt(b.capacity());
+                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
+
+                    msgBuffer.put(b.array(), 0, b.capacity());
+                    msgBuffer.position(0);
+                    int numbytes = channel.write(msgBuffer);
+                    end = System.currentTimeMillis() - init;
+
+                } catch (IOException e) {
+                    /*
+                     * If reconnection doesn't work, then put the
+                     * message back to the beginning of the queue and leave.
+                     */
+                    ZooLog.logWarn(""Exception when using channel: "" + addr
+                            + "")"" + e.toString());
+                    running = false;
+                    synchronized (senderWorkerMap) {
+                        recvWorker.finish();
+                        recvWorker = null;
+                    
+                        senderWorkerMap.remove(channel.socket().getInetAddress());
+                    
+                        if (b != null) {
+                            if (queueSendMap.get(channel.socket().getInetAddress())
+                                    .size() == 0)
+                                queueSendMap.get(channel.socket().getInetAddress())
+                                    .offer(b);
+                        }
+                    }
+                }
+            }
+            ZooLog.logWarn(""Leaving thread"");
+        }
+    }
+
+    /**
+     * Thread to receive messages. Instance waits on a socket read. If the
+     * channel breaks, then removes itself from the pool of receivers.
+     */
+
+    class RecvWorker extends Thread {
+        InetAddress addr;
+        SocketChannel channel;
+        boolean running = true;
+
+        RecvWorker(SocketChannel channel) {
+            this.addr = channel.socket().getInetAddress();
+            this.channel = channel;
+        }
+
+        boolean finish() {
+            running = false;
+            this.interrupt();
+            return running;
+        }
+
+        public void run() {
+            try {
+                byte[] size = new byte[4];
+                ByteBuffer msgLength = ByteBuffer.wrap(size);
+                while (running && !shutdown && channel.isConnected()) {
+                    /**
+                     * Reads the first int to determine the length of the
+                     * message
+                     */
+                    while (msgLength.hasRemaining()) {
+                        channel.read(msgLength);
+                    }
+                    msgLength.position(0);
+                    int length = msgLength.getInt();
+
+                    /**
+                     * Allocates a new ByteBuffer to receive the message
+                     */
+                    if (length > 0) {
+                        byte[] msgArray = new byte[length];
+                        ByteBuffer message = ByteBuffer.wrap(msgArray);
+                        int numbytes = 0;
+                        while (message.hasRemaining()) {
+                            numbytes += channel.read(message);
+                        }
+                        message.position(0);
+                        synchronized (recvQueue) {
+                            recvQueue
+                                    .put(new Message(message.duplicate(), addr));
+                        }
+                        msgLength.position(0);
+                    }
+                }
+
+            } catch (IOException e) {
+                ZooLog.logWarn(""Connection broken: "" + e.toString());
+
+            } catch (InterruptedException e) {
+                ZooLog.logWarn(""Interrupted while trying to add new ""
+                        + ""message to the reception queue ("" + e.toString()
+                        + "")"");
+            }
+        }
+    }
 }
",,6461
2246,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,d56cc9b9acb453945257a8e3b0cf8d88e5a36d35,1204726342,574,,,,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,-1,1207349605/1204726342,"                        recvWorker = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-import java.lang.InterruptedException;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Random;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.net.SocketAddress;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SocketChannel;
-import java.nio.channels.ServerSocketChannel;
-
-import com.yahoo.zookeeper.server.ZooLog;
-
-/**
- * This class implements a connection manager for leader election using TCP. It
- * maintains one coonection for every pair of servers. The tricky part is to
- * guarantee that there is exactly one connection for every pair of servers that
- * are operating correctly and that can communicate over the network.
- * 
- * If two servers try to start a connection concurrently, then the connection
- * manager uses a very simple tie-breaking mechanism to decide which connection
- * to drop based on the IP addressed of the two parties. 
- * 
- * For every peer, the manager maintains a queue of messages to send. If the
- * connection to any particular peer drops, then the sender thread puts the
- * message back on the list. As this implementation currently uses a queue
- * implementation to maintain messages to send to another peer, we add the
- * message to the tail of the queue, thus changing the order of messages.
- * Although this is not a problem for the leader election, it could be a problem
- * when consolidating peer communication. This is to be verified, though.
- * 
- */
-
-class QuorumCnxManager extends Thread {
-    /*
-     * Maximum capacity of thread queues
-     */
-
-    static final int CAPACITY = 100;
-
-    /*
-     * Maximum number of attempts to connect to a peer
-     */
-
-    static final int MAX_CONNECTION_ATTEMPTS = 2;
-
-    /*
-     * Packet size
-     */
-    int packetSize;
-
-    /*
-     * Port to listen on
-     */
-    int port;
-
-    /*
-     * Challenge to initiate connections
-     */
-    long challenge;
-
-    /*
-     * Local IP address
-     */
-    InetAddress localIP;
-
-    /*
-     * Mapping from Peer to Thread number
-     */
-    HashMap<InetAddress, SendWorker> senderWorkerMap;
-    HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
-
-    /*
-     * Reception queue
-     */
-    ArrayBlockingQueue<Message> recvQueue;
-
-    /*
-     * Shutdown flag
-     */
-
-    boolean shutdown = false;
-
-    /*
-     * Listener thread
-     */
-    Listener listener;
-
-    class Message {
-        Message(ByteBuffer buffer, InetAddress addr) {
-            this.buffer = buffer;
-            this.addr = addr;
-        }
-
-        ByteBuffer buffer;
-        InetAddress addr;
-    }
-
-    QuorumCnxManager(int port) {
-        this.port = port;
-        this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
-        this.queueSendMap = new HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>>();
-        this.senderWorkerMap = new HashMap<InetAddress, SendWorker>();
-
-        try {
-            localIP = InetAddress.getLocalHost();
-        } catch (UnknownHostException e) {
-            ZooLog.logWarn(""Couldn't get local address"");
-        }
-
-        // Generates a challenge to guarantee one connection between pairs of
-        // servers
-        genChallenge();
-
-        // Starts listener thread that waits for connection requests 
-        listener = new Listener(this);
-        listener.start();
-    }
-
-    void genChallenge() {
-        Random rand = new Random(System.currentTimeMillis()
-                + localIP.hashCode());
-        long newValue = rand.nextLong();
-        challenge = newValue;
-    }
-
-    /**
-     * If this server has initiated the connection, then it gives up on the
-     * connection if it loses challenge. Otherwise, it keeps the connection.
-     */
-
-    boolean initiateConnection(SocketChannel s) {
-        boolean challenged = true;
-        boolean wins = false;
-        long newChallenge;
-
-        // Compare IP addresses based on their hash codes 
-        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
-        //if(hashCodeRemote >= localIP.hashCode()){
-        //    wins = false;
-        //} else {
-        //    wins = true;
-        //} 
-        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
-        
-        try {
-            while (challenged && s.isConnected()) {
-                // Sending challenge
-                byte[] msgBytes = new byte[8];
-                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                msgBuffer.putLong(challenge);
-                msgBuffer.position(0);
-                s.write(msgBuffer);
-        
-                      // Reading challenge
-                    msgBuffer.position(0);
-                  int numBytes = s.read(msgBuffer);
-        
-                 msgBuffer.position(0);
-               newChallenge = msgBuffer.getLong();
-                if (challenge > newChallenge) {
-                   wins = true;
-                    challenged = false;
-                } else if (challenge == newChallenge) {
-                    genChallenge();
-                } else {
-                    challenged = false;
-                }
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(""Exception reading or writing challenge: ""
-                    + e.toString());
-            return false;
-        }
-
-        // If lost the challenge, then drop the new connection
-        if (!wins) {
-            try {
-                //ZooLog.logWarn(""lost cause (initiate"");
-                s.socket().close();
-            } catch (IOException e) {
-                ZooLog
-                        .logWarn(""Error when closing socket or trying to reopen connection: ""
-                                + e.toString());
-
-            }
-        // Otherwise proceed with the connection
-        } else
-            synchronized (senderWorkerMap) {
-                /*
-                 * It may happen that a thread from a previous connection to the same
-                 * server is still active. In this case, we terminate the thread by
-                 * calling finish(). Note that senderWorkerMap is a map from IP 
-                 * addresses to worker thread.
-                 */
-                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
-                    senderWorkerMap.get(s.socket().getInetAddress()).finish();
-                }
-
-                /*
-                 * Start new worker thread with a clean state.
-                 */
-                SendWorker sw = new SendWorker(s);
-                if (s != null) {
-                    RecvWorker rw = new RecvWorker(s);
-                    sw.setRecv(rw);
-
-                    if (senderWorkerMap
-                            .containsKey(s.socket().getInetAddress())) {
-                        InetAddress addr = s.socket().getInetAddress();
-                        senderWorkerMap.get(addr).finish();
-                    }
-
-                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
-                    sw.start();
-                    rw.start();
-
-                    return true;
-                } else {
-                    ZooLog.logWarn(""Channel null"");
-                    return false;
-                }
-            }
-
-        return false;
-    }
-
-    /**
-     * If this server receives a connection request, then it gives up on the new
-     * connection if it wins. Notice that it checks whether it has a connection
-     * to this server already or not. If it does, then it sends the smallest
-     * possible long value to lose the challenge.
-     * 
-     */
-    boolean receiveConnection(SocketChannel s) {
-        boolean challenged = true;
-        boolean wins = false;
-        long newChallenge;
-       
-        
-        //Compare IP addresses based on their hash codes.
-        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
-        //if(hashCodeRemote >= localIP.hashCode()){
-        //    wins = false;
-        //} else {
-        //    wins = true;
-        //} 
-        
-        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
-        
-        
-        try {
-            while (challenged && s.isConnected()) {
-               // Sending challenge
-                byte[] msgBytes = new byte[8];
-                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                long vsent;
-                if (senderWorkerMap.get(s.socket().getInetAddress()) == null)
-                    vsent = Long.MIN_VALUE;
-                else
-                    vsent = challenge;
-                msgBuffer.putLong(vsent);
-                msgBuffer.position(0);
-                s.write(msgBuffer);
-        
-                // Reading challenge
-                msgBuffer.position(0);
-                int numBytes = s.read(msgBuffer);
-        
-                msgBuffer.position(0);
-                newChallenge = msgBuffer.getLong();
-                if (vsent > newChallenge) {
-                    wins = true;
-                    challenged = false;
-                } else if (challenge == newChallenge) {
-                    genChallenge();
-                } else {
-                    challenged = false;
-                }
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(""Exception reading or writing challenge: ""
-                    + e.toString());
-            return false;
-        }
-
-        //If wins the challenge, then close the new connection.
-        if (wins) {
-            try {
-                InetAddress addr = s.socket().getInetAddress();
-                SendWorker sw = senderWorkerMap.get(addr);
-
-                //ZooLog.logWarn(""Keep connection (received)"");
-                //sw.connect();
-                s.socket().close();
-                sw.finish();
-                SocketChannel channel = SocketChannel.open(new InetSocketAddress(addr, port));
-                if (channel.isConnected()) {
-                    initiateConnection(channel);
-                }
-                
-                
-            } catch (IOException e) {
-                ZooLog
-                        .logWarn(""Error when closing socket or trying to reopen connection: ""
-                                + e.toString());
-            }
-        //Otherwise start worker threads to receive data.
-        } else
-            synchronized (senderWorkerMap) {
-                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
-                    senderWorkerMap.get(s.socket().getInetAddress()).finish();       
-                }
-                
-                SendWorker sw = new SendWorker(s);
-                if (s != null) {
-                    RecvWorker rw = new RecvWorker(s);
-                    sw.setRecv(rw);
-
-                    if (senderWorkerMap
-                            .containsKey(s.socket().getInetAddress())) {
-                        InetAddress addr = s.socket().getInetAddress();
-                        senderWorkerMap.get(addr).finish();
-                    }
-
-                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
-                    sw.start();
-                    rw.start();
-
-                    return true;
-                } else {
-                    ZooLog.logWarn(""Channel null"");
-                    return false;
-                }
-            }
-
-        return false;
-    }
-
-    /**
-     * Processes invoke this message to send a message. Currently, only leader
-     * election uses it.
-     */
-    void toSend(InetAddress addr, ByteBuffer b) {
-        /*
-         * If sending message to myself, then simply enqueue it (loopback).
-         */
-        if (addr.equals(localIP)) {
-            try {
-                b.position(0);
-                recvQueue.put(new Message(b.duplicate(), addr));
-            } catch (InterruptedException e) {
-                ZooLog.logWarn(""Exception when loopbacking"");
-            }
-        /*
-         * Otherwise send to the corresponding thread to send. 
-         */
-        } else
-            try {
-                /*
-                 * Start a new connection if doesn't have one already.
-                 */
-                if (!queueSendMap.containsKey(addr)) {
-                    queueSendMap.put(addr, new ArrayBlockingQueue<ByteBuffer>(
-                            CAPACITY));
-                    queueSendMap.get(addr).put(b);
-
-                } else {
-                    if (queueSendMap.get(addr).remainingCapacity() == 0) {
-                        queueSendMap.get(addr).take();
-                    }
-                    queueSendMap.get(addr).put(b);
-                }
-                
-                synchronized (senderWorkerMap) {
-                    if (senderWorkerMap.get(addr) == null) {
-                        SocketChannel channel;
-                        try {
-                            channel = SocketChannel
-                                    .open(new InetSocketAddress(addr, port));
-                            channel.socket().setTcpNoDelay(true);
-                            initiateConnection(channel);
-                        } catch (IOException e) {
-                            ZooLog.logWarn(""Cannot open channel to ""
-                                    + addr.toString() + ""( "" + e.toString()
-                                    + "")"");
-                        }
-                    }
-                }     
-            } catch (InterruptedException e) {
-                ZooLog
-                        .logWarn(""Interrupted while waiting to put message in queue.""
-                                + e.toString());
-            }
-    }
-
-    /**
-     * Check if all queues are empty, indicating that all messages have been delivered.
-     */
-    boolean haveDelivered() {
-        for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
-            if (queue.size() == 0)
-                return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * Flag that it is time to wrap up all activities and interrupt the listener.
-     */
-    public void shutdown() {
-        shutdown = true;
-        listener.interrupt();
-    }
-
-    /**
-     * Thread to listen on some port
-     */
-    class Listener extends Thread {
-        QuorumCnxManager manager;
-
-        Listener(QuorumCnxManager m) {
-            manager = m;
-        }
-
-        /**
-         * Sleeps on accept().
-         */
-        public void run() {
-            ServerSocketChannel ss = null;
-            try {
-                if (ss != null)
-                    ss.close();
-                ss = ServerSocketChannel.open();
-                ss.socket().bind(new InetSocketAddress(port));
-
-                while (!shutdown) {
-                    SocketChannel client = ss.accept();
-                    client.socket().setTcpNoDelay(true);
-                    /*
-                     * This synchronized block guarantees that if
-                     * both parties try to connect to each other
-                     * simultaneously, then only one will succeed.
-                     * If we don't have this block, then there 
-                     * are runs in which both parties act as if they
-                     * don't have any connection starting or started.
-                     * In receiveConnection(), a server sends the minimum
-                     * value for a challenge, if they believe they must
-                     * accept the connection because they don't have one.
-                     * 
-                     * This synchronized block prevents that the same server
-                     * invokes receiveConnection() and initiateConnection() 
-                     * simultaneously.
-                     */
-                    synchronized(senderWorkerMap){
-                        ZooLog.logWarn(""Connection request"");
-                        receiveConnection(client);
-                    }
-                }
-            } catch (IOException e) {
-                System.err.println(""Listener.run: "" + e.getMessage());
-            }
-        }
-    }
-
-    /**
-     * Thread to send messages. Instance waits on a queue, and send a message as
-     * soon as there is one available. If connection breaks, then opens a new
-     * one.
-     */
-
-    class SendWorker extends Thread {
-        // Send msgs to peer
-        InetAddress addr;
-        SocketChannel channel;
-        RecvWorker recvWorker;
-        boolean running = true;
-
-        SendWorker(SocketChannel channel) {
-            this.addr = channel.socket().getInetAddress();
-            this.channel = channel;
-            recvWorker = null;
-        }
-
-        void setRecv(RecvWorker recvWorker) {
-            this.recvWorker = recvWorker;
-        }
-
-        //boolean connect() throws IOException {
-        //    if (recvWorker != null)
-        //        recvWorker.finish();
-        //
-        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
-        //    if (channel.isConnected()) {
-        //        recvWorker = new RecvWorker(channel);
-        //        initiateConnection(channel);
-        //        ZooLog.logWarn(""Opened new connection"");
-        //    } else {
-        //        ZooLog.logWarn(""Channel not connected."");
-        //    }
-        //
-        //    return channel.isConnected();
-        //}
-
-        boolean finish() {
-            running = false;
-
-            this.interrupt();
-            if (recvWorker != null)
-                recvWorker.finish();
-            senderWorkerMap.remove(channel.socket().getInetAddress());
-            return running;
-        }
-
-        public void run() {
-
-            long init, init1, end1, end;
-            while (running && !shutdown) {
-
-                ByteBuffer b = null;
-                try {
-                    init = System.currentTimeMillis();
-                    b = queueSendMap.get(addr).take();
-                } catch (InterruptedException e) {
-                    ZooLog
-                            .logWarn(""Interrupted while waiting for message on queue (""
-                                    + e.toString() + "")"");
-                    continue;
-                }
-
-                try {
-                    byte[] msgBytes = new byte[b.capacity()
-                            + (Integer.SIZE / 8)];
-                    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                    msgBuffer.putInt(b.capacity());
-                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
-
-                    msgBuffer.put(b.array(), 0, b.capacity());
-                    msgBuffer.position(0);
-                    int numbytes = channel.write(msgBuffer);
-                    end = System.currentTimeMillis() - init;
-
-                } catch (IOException e) {
-                    /*
-                     * If reconnection doesn't work, then put the
-                     * message back to the beginning of the queue and leave.
-                     */
-                    ZooLog.logWarn(""Exception when using channel: "" + addr
-                            + "")"" + e.toString());
-                    running = false;
-                    synchronized (senderWorkerMap) {
-                        recvWorker.finish();
-                        recvWorker = null;
-                    
-                        senderWorkerMap.remove(channel.socket().getInetAddress());
-                    
-                        if (b != null) {
-                            if (queueSendMap.get(channel.socket().getInetAddress())
-                                    .size() == 0)
-                                queueSendMap.get(channel.socket().getInetAddress())
-                                    .offer(b);
-                        }
-                    }
-                }
-            }
-            ZooLog.logWarn(""Leaving thread"");
-        }
-    }
-
-    /**
-     * Thread to receive messages. Instance waits on a socket read. If the
-     * channel breaks, then removes itself from the pool of receivers.
-     */
-
-    class RecvWorker extends Thread {
-        InetAddress addr;
-        SocketChannel channel;
-        boolean running = true;
-
-        RecvWorker(SocketChannel channel) {
-            this.addr = channel.socket().getInetAddress();
-            this.channel = channel;
-        }
-
-        boolean finish() {
-            running = false;
-            this.interrupt();
-            return running;
-        }
-
-        public void run() {
-            try {
-                byte[] size = new byte[4];
-                ByteBuffer msgLength = ByteBuffer.wrap(size);
-                while (running && !shutdown && channel.isConnected()) {
-                    /**
-                     * Reads the first int to determine the length of the
-                     * message
-                     */
-                    while (msgLength.hasRemaining()) {
-                        channel.read(msgLength);
-                    }
-                    msgLength.position(0);
-                    int length = msgLength.getInt();
-
-                    /**
-                     * Allocates a new ByteBuffer to receive the message
-                     */
-                    if (length > 0) {
-                        byte[] msgArray = new byte[length];
-                        ByteBuffer message = ByteBuffer.wrap(msgArray);
-                        int numbytes = 0;
-                        while (message.hasRemaining()) {
-                            numbytes += channel.read(message);
-                        }
-                        message.position(0);
-                        synchronized (recvQueue) {
-                            recvQueue
-                                    .put(new Message(message.duplicate(), addr));
-                        }
-                        msgLength.position(0);
-                    }
-                }
-
-            } catch (IOException e) {
-                ZooLog.logWarn(""Connection broken: "" + e.toString());
-
-            } catch (InterruptedException e) {
-                ZooLog.logWarn(""Interrupted while trying to add new ""
-                        + ""message to the reception queue ("" + e.toString()
-                        + "")"");
-            }
-        }
-    }
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+import java.util.HashMap;
+import java.util.Random;
+import java.util.concurrent.ArrayBlockingQueue;
+
+import com.yahoo.zookeeper.server.ZooLog;
+
+/**
+ * This class implements a connection manager for leader election using TCP. It
+ * maintains one coonection for every pair of servers. The tricky part is to
+ * guarantee that there is exactly one connection for every pair of servers that
+ * are operating correctly and that can communicate over the network.
+ * 
+ * If two servers try to start a connection concurrently, then the connection
+ * manager uses a very simple tie-breaking mechanism to decide which connection
+ * to drop based on the IP addressed of the two parties. 
+ * 
+ * For every peer, the manager maintains a queue of messages to send. If the
+ * connection to any particular peer drops, then the sender thread puts the
+ * message back on the list. As this implementation currently uses a queue
+ * implementation to maintain messages to send to another peer, we add the
+ * message to the tail of the queue, thus changing the order of messages.
+ * Although this is not a problem for the leader election, it could be a problem
+ * when consolidating peer communication. This is to be verified, though.
+ * 
+ */
+
+class QuorumCnxManager extends Thread {
+    /*
+     * Maximum capacity of thread queues
+     */
+
+    static final int CAPACITY = 100;
+
+    /*
+     * Maximum number of attempts to connect to a peer
+     */
+
+    static final int MAX_CONNECTION_ATTEMPTS = 2;
+
+    /*
+     * Packet size
+     */
+    int packetSize;
+
+    /*
+     * Port to listen on
+     */
+    int port;
+
+    /*
+     * Challenge to initiate connections
+     */
+    long challenge;
+
+    /*
+     * Local IP address
+     */
+    InetAddress localIP;
+
+    /*
+     * Mapping from Peer to Thread number
+     */
+    HashMap<InetAddress, SendWorker> senderWorkerMap;
+    HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
+
+    /*
+     * Reception queue
+     */
+    ArrayBlockingQueue<Message> recvQueue;
+
+    /*
+     * Shutdown flag
+     */
+
+    boolean shutdown = false;
+
+    /*
+     * Listener thread
+     */
+    Listener listener;
+
+    class Message {
+        Message(ByteBuffer buffer, InetAddress addr) {
+            this.buffer = buffer;
+            this.addr = addr;
+        }
+
+        ByteBuffer buffer;
+        InetAddress addr;
+    }
+
+    QuorumCnxManager(int port) {
+        this.port = port;
+        this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
+        this.queueSendMap = new HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>>();
+        this.senderWorkerMap = new HashMap<InetAddress, SendWorker>();
+
+        try {
+            localIP = InetAddress.getLocalHost();
+        } catch (UnknownHostException e) {
+            ZooLog.logWarn(""Couldn't get local address"");
+        }
+
+        // Generates a challenge to guarantee one connection between pairs of
+        // servers
+        genChallenge();
+
+        // Starts listener thread that waits for connection requests 
+        listener = new Listener(this);
+        listener.start();
+    }
+
+    void genChallenge() {
+        Random rand = new Random(System.currentTimeMillis()
+                + localIP.hashCode());
+        long newValue = rand.nextLong();
+        challenge = newValue;
+    }
+
+    /**
+     * If this server has initiated the connection, then it gives up on the
+     * connection if it loses challenge. Otherwise, it keeps the connection.
+     */
+
+    boolean initiateConnection(SocketChannel s) {
+        boolean challenged = true;
+        boolean wins = false;
+        long newChallenge;
+
+        // Compare IP addresses based on their hash codes 
+        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
+        //if(hashCodeRemote >= localIP.hashCode()){
+        //    wins = false;
+        //} else {
+        //    wins = true;
+        //} 
+        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
+        
+        try {
+            while (challenged && s.isConnected()) {
+                // Sending challenge
+                byte[] msgBytes = new byte[8];
+                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                msgBuffer.putLong(challenge);
+                msgBuffer.position(0);
+                s.write(msgBuffer);
+        
+                      // Reading challenge
+                    msgBuffer.position(0);
+                  int numBytes = s.read(msgBuffer);
+        
+                 msgBuffer.position(0);
+               newChallenge = msgBuffer.getLong();
+                if (challenge > newChallenge) {
+                   wins = true;
+                    challenged = false;
+                } else if (challenge == newChallenge) {
+                    genChallenge();
+                } else {
+                    challenged = false;
+                }
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(""Exception reading or writing challenge: ""
+                    + e.toString());
+            return false;
+        }
+
+        // If lost the challenge, then drop the new connection
+        if (!wins) {
+            try {
+                //ZooLog.logWarn(""lost cause (initiate"");
+                s.socket().close();
+            } catch (IOException e) {
+                ZooLog
+                        .logWarn(""Error when closing socket or trying to reopen connection: ""
+                                + e.toString());
+
+            }
+        // Otherwise proceed with the connection
+        } else
+            synchronized (senderWorkerMap) {
+                /*
+                 * It may happen that a thread from a previous connection to the same
+                 * server is still active. In this case, we terminate the thread by
+                 * calling finish(). Note that senderWorkerMap is a map from IP 
+                 * addresses to worker thread.
+                 */
+                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
+                    senderWorkerMap.get(s.socket().getInetAddress()).finish();
+                }
+
+                /*
+                 * Start new worker thread with a clean state.
+                 */
+                SendWorker sw = new SendWorker(s);
+                if (s != null) {
+                    RecvWorker rw = new RecvWorker(s);
+                    sw.setRecv(rw);
+
+                    if (senderWorkerMap
+                            .containsKey(s.socket().getInetAddress())) {
+                        InetAddress addr = s.socket().getInetAddress();
+                        senderWorkerMap.get(addr).finish();
+                    }
+
+                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
+                    sw.start();
+                    rw.start();
+
+                    return true;
+                } else {
+                    ZooLog.logWarn(""Channel null"");
+                    return false;
+                }
+            }
+
+        return false;
+    }
+
+    /**
+     * If this server receives a connection request, then it gives up on the new
+     * connection if it wins. Notice that it checks whether it has a connection
+     * to this server already or not. If it does, then it sends the smallest
+     * possible long value to lose the challenge.
+     * 
+     */
+    boolean receiveConnection(SocketChannel s) {
+        boolean challenged = true;
+        boolean wins = false;
+        long newChallenge;
+       
+        
+        //Compare IP addresses based on their hash codes.
+        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
+        //if(hashCodeRemote >= localIP.hashCode()){
+        //    wins = false;
+        //} else {
+        //    wins = true;
+        //} 
+        
+        //ZooLog.logWarn(""Hash codes: "" + hashCodeRemote + "", "" + localIP.hashCode());
+        
+        
+        try {
+            while (challenged && s.isConnected()) {
+               // Sending challenge
+                byte[] msgBytes = new byte[8];
+                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                long vsent;
+                if (senderWorkerMap.get(s.socket().getInetAddress()) == null)
+                    vsent = Long.MIN_VALUE;
+                else
+                    vsent = challenge;
+                msgBuffer.putLong(vsent);
+                msgBuffer.position(0);
+                s.write(msgBuffer);
+        
+                // Reading challenge
+                msgBuffer.position(0);
+                s.read(msgBuffer);
+        
+                msgBuffer.position(0);
+                newChallenge = msgBuffer.getLong();
+                if (vsent > newChallenge) {
+                    wins = true;
+                    challenged = false;
+                } else if (challenge == newChallenge) {
+                    genChallenge();
+                } else {
+                    challenged = false;
+                }
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(""Exception reading or writing challenge: ""
+                    + e.toString());
+            return false;
+        }
+
+        //If wins the challenge, then close the new connection.
+        if (wins) {
+            try {
+                InetAddress addr = s.socket().getInetAddress();
+                SendWorker sw = senderWorkerMap.get(addr);
+
+                //ZooLog.logWarn(""Keep connection (received)"");
+                //sw.connect();
+                s.socket().close();
+                sw.finish();
+                SocketChannel channel = SocketChannel.open(new InetSocketAddress(addr, port));
+                if (channel.isConnected()) {
+                    initiateConnection(channel);
+                }
+                
+                
+            } catch (IOException e) {
+                ZooLog
+                        .logWarn(""Error when closing socket or trying to reopen connection: ""
+                                + e.toString());
+            }
+        //Otherwise start worker threads to receive data.
+        } else
+            synchronized (senderWorkerMap) {
+                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
+                    senderWorkerMap.get(s.socket().getInetAddress()).finish();       
+                }
+                
+                SendWorker sw = new SendWorker(s);
+                if (s != null) {
+                    RecvWorker rw = new RecvWorker(s);
+                    sw.setRecv(rw);
+
+                    if (senderWorkerMap
+                            .containsKey(s.socket().getInetAddress())) {
+                        InetAddress addr = s.socket().getInetAddress();
+                        senderWorkerMap.get(addr).finish();
+                    }
+
+                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
+                    sw.start();
+                    rw.start();
+
+                    return true;
+                } else {
+                    ZooLog.logWarn(""Channel null"");
+                    return false;
+                }
+            }
+
+        return false;
+    }
+
+    /**
+     * Processes invoke this message to send a message. Currently, only leader
+     * election uses it.
+     */
+    void toSend(InetAddress addr, ByteBuffer b) {
+        /*
+         * If sending message to myself, then simply enqueue it (loopback).
+         */
+        if (addr.equals(localIP)) {
+            try {
+                b.position(0);
+                recvQueue.put(new Message(b.duplicate(), addr));
+            } catch (InterruptedException e) {
+                ZooLog.logWarn(""Exception when loopbacking"");
+            }
+        /*
+         * Otherwise send to the corresponding thread to send. 
+         */
+        } else
+            try {
+                /*
+                 * Start a new connection if doesn't have one already.
+                 */
+                if (!queueSendMap.containsKey(addr)) {
+                    queueSendMap.put(addr, new ArrayBlockingQueue<ByteBuffer>(
+                            CAPACITY));
+                    queueSendMap.get(addr).put(b);
+
+                } else {
+                    if (queueSendMap.get(addr).remainingCapacity() == 0) {
+                        queueSendMap.get(addr).take();
+                    }
+                    queueSendMap.get(addr).put(b);
+                }
+                
+                synchronized (senderWorkerMap) {
+                    if (senderWorkerMap.get(addr) == null) {
+                        SocketChannel channel;
+                        try {
+                            channel = SocketChannel
+                                    .open(new InetSocketAddress(addr, port));
+                            channel.socket().setTcpNoDelay(true);
+                            initiateConnection(channel);
+                        } catch (IOException e) {
+                            ZooLog.logWarn(""Cannot open channel to ""
+                                    + addr.toString() + ""( "" + e.toString()
+                                    + "")"");
+                        }
+                    }
+                }     
+            } catch (InterruptedException e) {
+                ZooLog
+                        .logWarn(""Interrupted while waiting to put message in queue.""
+                                + e.toString());
+            }
+    }
+
+    /**
+     * Check if all queues are empty, indicating that all messages have been delivered.
+     */
+    boolean haveDelivered() {
+        for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
+            if (queue.size() == 0)
+                return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Flag that it is time to wrap up all activities and interrupt the listener.
+     */
+    public void shutdown() {
+        shutdown = true;
+        listener.interrupt();
+    }
+
+    /**
+     * Thread to listen on some port
+     */
+    class Listener extends Thread {
+        QuorumCnxManager manager;
+
+        Listener(QuorumCnxManager m) {
+            manager = m;
+        }
+
+        /**
+         * Sleeps on accept().
+         */
+        public void run() {
+            ServerSocketChannel ss = null;
+            try {
+                if (ss != null)
+                    ss.close();
+                ss = ServerSocketChannel.open();
+                ss.socket().bind(new InetSocketAddress(port));
+
+                while (!shutdown) {
+                    SocketChannel client = ss.accept();
+                    client.socket().setTcpNoDelay(true);
+                    /*
+                     * This synchronized block guarantees that if
+                     * both parties try to connect to each other
+                     * simultaneously, then only one will succeed.
+                     * If we don't have this block, then there 
+                     * are runs in which both parties act as if they
+                     * don't have any connection starting or started.
+                     * In receiveConnection(), a server sends the minimum
+                     * value for a challenge, if they believe they must
+                     * accept the connection because they don't have one.
+                     * 
+                     * This synchronized block prevents that the same server
+                     * invokes receiveConnection() and initiateConnection() 
+                     * simultaneously.
+                     */
+                    synchronized(senderWorkerMap){
+                        ZooLog.logWarn(""Connection request"");
+                        receiveConnection(client);
+                    }
+                }
+            } catch (IOException e) {
+                System.err.println(""Listener.run: "" + e.getMessage());
+            }
+        }
+    }
+
+    /**
+     * Thread to send messages. Instance waits on a queue, and send a message as
+     * soon as there is one available. If connection breaks, then opens a new
+     * one.
+     */
+
+    class SendWorker extends Thread {
+        // Send msgs to peer
+        InetAddress addr;
+        SocketChannel channel;
+        RecvWorker recvWorker;
+        boolean running = true;
+
+        SendWorker(SocketChannel channel) {
+            this.addr = channel.socket().getInetAddress();
+            this.channel = channel;
+            recvWorker = null;
+        }
+
+        void setRecv(RecvWorker recvWorker) {
+            this.recvWorker = recvWorker;
+        }
+
+        //boolean connect() throws IOException {
+        //    if (recvWorker != null)
+        //        recvWorker.finish();
+        //
+        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
+        //    if (channel.isConnected()) {
+        //        recvWorker = new RecvWorker(channel);
+        //        initiateConnection(channel);
+        //        ZooLog.logWarn(""Opened new connection"");
+        //    } else {
+        //        ZooLog.logWarn(""Channel not connected."");
+        //    }
+        //
+        //    return channel.isConnected();
+        //}
+
+        boolean finish() {
+            running = false;
+
+            this.interrupt();
+            if (recvWorker != null)
+                recvWorker.finish();
+            senderWorkerMap.remove(channel.socket().getInetAddress());
+            return running;
+        }
+
+        public void run() {
+
+            long init, init1, end1, end;
+            while (running && !shutdown) {
+
+                ByteBuffer b = null;
+                try {
+                    init = System.currentTimeMillis();
+                    b = queueSendMap.get(addr).take();
+                } catch (InterruptedException e) {
+                    ZooLog
+                            .logWarn(""Interrupted while waiting for message on queue (""
+                                    + e.toString() + "")"");
+                    continue;
+                }
+
+                try {
+                    byte[] msgBytes = new byte[b.capacity()
+                            + (Integer.SIZE / 8)];
+                    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                    msgBuffer.putInt(b.capacity());
+                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
+
+                    msgBuffer.put(b.array(), 0, b.capacity());
+                    msgBuffer.position(0);
+                    int numbytes = channel.write(msgBuffer);
+                    end = System.currentTimeMillis() - init;
+
+                } catch (IOException e) {
+                    /*
+                     * If reconnection doesn't work, then put the
+                     * message back to the beginning of the queue and leave.
+                     */
+                    ZooLog.logWarn(""Exception when using channel: "" + addr
+                            + "")"" + e.toString());
+                    running = false;
+                    synchronized (senderWorkerMap) {
+                        recvWorker.finish();
+                        recvWorker = null;
+                    
+                        senderWorkerMap.remove(channel.socket().getInetAddress());
+                    
+                        if (b != null) {
+                            if (queueSendMap.get(channel.socket().getInetAddress())
+                                    .size() == 0)
+                                queueSendMap.get(channel.socket().getInetAddress())
+                                    .offer(b);
+                        }
+                    }
+                }
+            }
+            ZooLog.logWarn(""Leaving thread"");
+        }
+    }
+
+    /**
+     * Thread to receive messages. Instance waits on a socket read. If the
+     * channel breaks, then removes itself from the pool of receivers.
+     */
+
+    class RecvWorker extends Thread {
+        InetAddress addr;
+        SocketChannel channel;
+        boolean running = true;
+
+        RecvWorker(SocketChannel channel) {
+            this.addr = channel.socket().getInetAddress();
+            this.channel = channel;
+        }
+
+        boolean finish() {
+            running = false;
+            this.interrupt();
+            return running;
+        }
+
+        public void run() {
+            try {
+                byte[] size = new byte[4];
+                ByteBuffer msgLength = ByteBuffer.wrap(size);
+                while (running && !shutdown && channel.isConnected()) {
+                    /**
+                     * Reads the first int to determine the length of the
+                     * message
+                     */
+                    while (msgLength.hasRemaining()) {
+                        channel.read(msgLength);
+                    }
+                    msgLength.position(0);
+                    int length = msgLength.getInt();
+
+                    /**
+                     * Allocates a new ByteBuffer to receive the message
+                     */
+                    if (length > 0) {
+                        byte[] msgArray = new byte[length];
+                        ByteBuffer message = ByteBuffer.wrap(msgArray);
+                        int numbytes = 0;
+                        while (message.hasRemaining()) {
+                            numbytes += channel.read(message);
+                        }
+                        message.position(0);
+                        synchronized (recvQueue) {
+                            recvQueue
+                                    .put(new Message(message.duplicate(), addr));
+                        }
+                        msgLength.position(0);
+                    }
+                }
+
+            } catch (IOException e) {
+                ZooLog.logWarn(""Connection broken: "" + e.toString());
+
+            } catch (InterruptedException e) {
+                ZooLog.logWarn(""Interrupted while trying to add new ""
+                        + ""message to the reception queue ("" + e.toString()
+                        + "")"");
+            }
+        }
+    }
 }
",,6461
2247,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumPeer.java,688f039444b44c925b3103cd0d05102a4b7ba690,1204899909,359,,,,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,-1,1207349605/1204899909,"                    follower = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-
-import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.*;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetSocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.InputArchive;
-import com.yahoo.zookeeper.server.NIOServerCnxn;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooLog;
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+
+import static com.yahoo.zookeeper.server.ServerConfig.getClientPort;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataDir;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataLogDir;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionAlg;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionPort;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getInitLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServerId;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServers;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getSyncLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getTickTime;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.InputArchive;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.Vote;
 import com.yahoo.zookeeper.server.quorum.FastLeaderElection;
 import com.yahoo.zookeeper.server.quorum.QuorumCnxManager;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This class manages the quorum protocol. There are three states this server
- * can be in:
- * <ol>
- * <li>Leader election - each server will elect a leader (proposing itself as a
- * leader initially).</li>
- * <li>Follower - the server will synchronize with the leader and replicate any
- * transactions.</li>
- * <li>Leader - the server will process requests and forward them to followers.
- * A majority of followers must log the request before it can be accepted.
- * </ol>
- * 
- * This class will setup a datagram socket that will always respond with its
- * view of the current leader. The response will take the form of:
- * 
- * <pre>
- * int xid;
- * 
- * long myid;
- * 
- * long leader_id;
- * 
- * long leader_zxid;
- * </pre>
- * 
- * The request for the current leader will consist solely of an xid: int xid;
- * 
- * <h2>Configuration file</h2>
- * 
- * When the main() method of this class is used to start the program, the file
- * ""zoo.cfg"" in the current directory will be used to obtain configuration
- * information. zoo.cfg is a Properties file, so keys and values are separated
- * by equals (=) and the key/value pairs are separated by new lines. The
- * following keys are used in the configuration file:
- * <ol>
- * <li>dataDir - The directory where the zookeeper data is stored.</li>
- * <li>clientPort - The port used to communicate with clients.</li>
- * <li>tickTime - The duration of a tick in milliseconds. This is the basic
- * unit of time in zookeeper.</li>
- * <li>initLimit - The maximum number of ticks that a follower will wait to
- * initially synchronize with a leader.</li>
- * <li>syncLimit - The maximum number of ticks that a follower will wait for a
- * message (including heartbeats) from the leader.</li>
- * <li>server.<i>id</i> - This is the host:port that the server with the
- * given id will use for the quorum protocol.</li>
- * </ol>
- * In addition to the zoo.cfg file. There is a file in the data directory called
- * ""myid"" that contains the server id as an ASCII decimal value.
- */
-public class QuorumPeer extends Thread {
-	/**
-	 * Create an instance of a quorum peer 
-	 */
-	public interface Factory{
-		public QuorumPeer create() throws IOException;
-	}
-    public static class QuorumServer {
-        public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-        }
-
-        public InetSocketAddress addr;
-
-        public long id;
-    }
-
-    public enum ServerState {
-        LOOKING, FOLLOWING, LEADING;
-    }
-    /**
-     * The servers that make up the cluster
-     */
-    ArrayList<QuorumServer> quorumPeers;
-    public int getQuorumSize(){
-    	return quorumPeers.size();
-    }
-    /**
-     * My id
-     */
-    private long myid;
-
-
-    /**
-     * get the id of this quorum peer.
-     */
-    public long getId() {
-    	return myid;
-    }
-
-    /**
-     * This is who I think the leader currently is.
-     */
-    volatile Vote currentVote;
-
-    boolean running = true;
-
-    /**
-     * The number of milliseconds of each tick
-     */
-    int tickTime;
-
-    /**
-     * The number of ticks that the initial synchronization phase can take
-     */
-    int initLimit;
-
-    /**
-     * The number of ticks that can pass between sending a request and getting
-     * an acknowledgement
-     */
-    int syncLimit;
-
-    /**
-     * The current tick
-     */
-    int tick;
-
-    /**
-     * This class simply responds to requests for the current leader of this
-     * node.
-     * <p>
-     * The request contains just an xid generated by the requestor.
-     * <p>
-     * The response has the xid, the id of this server, the id of the leader,
-     * and the zxid of the leader.
-     * 
-     * @author breed
-     * 
-     */
-    class ResponderThread extends Thread {
-        ResponderThread() {
-            super(""ResponderThread"");
-        }
-
-        public void run() {
-            try {
-                byte b[] = new byte[36];
-                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
-                DatagramPacket packet = new DatagramPacket(b, b.length);
-                while (true) {
-                    udpSocket.receive(packet);
-                    if (packet.getLength() != 4) {
-                        ZooLog.logError(""Got more than just an xid! Len = ""
-                                + packet.getLength());
-                    } else {
-                        responseBuffer.clear();
-                        responseBuffer.getInt(); // Skip the xid
-                        responseBuffer.putLong(myid);
-                        switch (state) {
-                        case LOOKING:
-                            responseBuffer.putLong(currentVote.id);
-                            responseBuffer.putLong(currentVote.zxid);
-                            break;
-                        case LEADING:
-                            responseBuffer.putLong(myid);
-                            try {
-                                responseBuffer.putLong(leader.lastProposed);
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                            break;
-                        case FOLLOWING:
-                            responseBuffer.putLong(currentVote.id);
-                            try {
-                                responseBuffer.putLong(follower.getZxid());
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                        }
-                        packet.setData(b);
-                        udpSocket.send(packet);
-                    }
-                    packet.setLength(b.length);
-                }
-            } catch (Exception e) {
-                ZooLog.logException(e);
-            } finally {
-                ZooLog.logError(""QuorumPeer responder thread exited"");
-            }
-        }
-    }
-
-    public ServerState state = ServerState.LOOKING;
-
-    DatagramSocket udpSocket;
-
-    InetSocketAddress myQuorumAddr;
-
-    /**
-     * the directory where the snapshot is stored.
-     */
-    private File dataDir;
-
-    /**
-     * the directory where the logs are stored.
-     */
-    private File dataLogDir;
-
-    int clientPort;
-
-    int electionAlg;
-    
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This class manages the quorum protocol. There are three states this server
+ * can be in:
+ * <ol>
+ * <li>Leader election - each server will elect a leader (proposing itself as a
+ * leader initially).</li>
+ * <li>Follower - the server will synchronize with the leader and replicate any
+ * transactions.</li>
+ * <li>Leader - the server will process requests and forward them to followers.
+ * A majority of followers must log the request before it can be accepted.
+ * </ol>
+ * 
+ * This class will setup a datagram socket that will always respond with its
+ * view of the current leader. The response will take the form of:
+ * 
+ * <pre>
+ * int xid;
+ * 
+ * long myid;
+ * 
+ * long leader_id;
+ * 
+ * long leader_zxid;
+ * </pre>
+ * 
+ * The request for the current leader will consist solely of an xid: int xid;
+ * 
+ * <h2>Configuration file</h2>
+ * 
+ * When the main() method of this class is used to start the program, the file
+ * ""zoo.cfg"" in the current directory will be used to obtain configuration
+ * information. zoo.cfg is a Properties file, so keys and values are separated
+ * by equals (=) and the key/value pairs are separated by new lines. The
+ * following keys are used in the configuration file:
+ * <ol>
+ * <li>dataDir - The directory where the zookeeper data is stored.</li>
+ * <li>clientPort - The port used to communicate with clients.</li>
+ * <li>tickTime - The duration of a tick in milliseconds. This is the basic
+ * unit of time in zookeeper.</li>
+ * <li>initLimit - The maximum number of ticks that a follower will wait to
+ * initially synchronize with a leader.</li>
+ * <li>syncLimit - The maximum number of ticks that a follower will wait for a
+ * message (including heartbeats) from the leader.</li>
+ * <li>server.<i>id</i> - This is the host:port that the server with the
+ * given id will use for the quorum protocol.</li>
+ * </ol>
+ * In addition to the zoo.cfg file. There is a file in the data directory called
+ * ""myid"" that contains the server id as an ASCII decimal value.
+ */
+public class QuorumPeer extends Thread implements QuorumStats.Provider {
+    /**
+     * Create an instance of a quorum peer 
+     */
+    public interface Factory{
+        public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) throws IOException;
+        public NIOServerCnxn.Factory createConnectionFactory() throws IOException;
+    }
+    
+    public static class QuorumServer {
+        public QuorumServer(long id, InetSocketAddress addr) {
+            this.id = id;
+            this.addr = addr;
+        }
+
+        public InetSocketAddress addr;
+
+        public long id;
+    }
+
+    public enum ServerState {
+        LOOKING, FOLLOWING, LEADING;
+    }
+    /**
+     * The servers that make up the cluster
+     */
+    ArrayList<QuorumServer> quorumPeers;
+    public int getQuorumSize(){
+        return quorumPeers.size();
+    }
+    /**
+     * My id
+     */
+    private long myid;
+
+
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getId() {
+        return myid;
+    }
+
+    /**
+     * This is who I think the leader currently is.
+     */
+    volatile Vote currentVote;
+
+    volatile boolean running = true;
+
+    /**
+     * The number of milliseconds of each tick
+     */
+    int tickTime;
+
+    /**
+     * The number of ticks that the initial synchronization phase can take
+     */
+    int initLimit;
+
+    /**
+     * The number of ticks that can pass between sending a request and getting
+     * an acknowledgement
+     */
+    int syncLimit;
+
+    /**
+     * The current tick
+     */
+    int tick;
+
+    /**
+     * This class simply responds to requests for the current leader of this
+     * node.
+     * <p>
+     * The request contains just an xid generated by the requestor.
+     * <p>
+     * The response has the xid, the id of this server, the id of the leader,
+     * and the zxid of the leader.
+     * 
+     * @author breed
+     * 
+     */
+    class ResponderThread extends Thread {
+        ResponderThread() {
+            super(""ResponderThread"");
+        }
+
+        public void run() {
+            try {
+                byte b[] = new byte[36];
+                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
+                DatagramPacket packet = new DatagramPacket(b, b.length);
+                while (true) {
+                    udpSocket.receive(packet);
+                    if (packet.getLength() != 4) {
+                        ZooLog.logError(""Got more than just an xid! Len = ""
+                                + packet.getLength());
+                    } else {
+                        responseBuffer.clear();
+                        responseBuffer.getInt(); // Skip the xid
+                        responseBuffer.putLong(myid);
+                        switch (state) {
+                        case LOOKING:
+                            responseBuffer.putLong(currentVote.id);
+                            responseBuffer.putLong(currentVote.zxid);
+                            break;
+                        case LEADING:
+                            responseBuffer.putLong(myid);
+                            try {
+                                responseBuffer.putLong(leader.lastProposed);
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                            break;
+                        case FOLLOWING:
+                            responseBuffer.putLong(currentVote.id);
+                            try {
+                                responseBuffer.putLong(follower.getZxid());
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                        }
+                        packet.setData(b);
+                        udpSocket.send(packet);
+                    }
+                    packet.setLength(b.length);
+                }
+            } catch (Exception e) {
+                ZooLog.logException(e);
+            } finally {
+                ZooLog.logError(""QuorumPeer responder thread exited"");
+            }
+        }
+    }
+
+    private ServerState state = ServerState.LOOKING;
+    
+    public void setPeerState(ServerState newState){
+        state=newState;
+    }
+    
+    public ServerState getPeerState(){
+        return state;
+    }
+    
+    DatagramSocket udpSocket;
+
+    private InetSocketAddress myQuorumAddr;
+    
+    public InetSocketAddress getQuorumAddress(){
+        return myQuorumAddr;
+    }
+
+    /**
+     * the directory where the snapshot is stored.
+     */
+    private File dataDir;
+
+    /**
+     * the directory where the logs are stored.
+     */
+    private File dataLogDir;
+
+    Election electionAlg;
+
     int electionPort;
 
-    NIOServerCnxn.Factory cnxnFactory;
-
-    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
-            File dataLogDir, int clientPort, int electionAlg, int electionPort,
-            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
-        super(""QuorumPeer"");
-        this.clientPort = clientPort;
-        this.cnxnFactory = new NIOServerCnxn.Factory(clientPort, this);
-        this.quorumPeers = quorumPeers;
-        this.dataDir = dataDir;
-        this.electionAlg = electionAlg;
+    NIOServerCnxn.Factory cnxnFactory;
+
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionAlg, int electionPort,long myid, int tickTime, 
+            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        super(""QuorumPeer"");
+        this.cnxnFactory = cnxnFactory;
+        this.quorumPeers = quorumPeers;
+        this.dataDir = dataDir;
         this.electionPort = electionPort;
-        this.dataLogDir = dataLogDir;
-        this.myid = myid;
-        this.tickTime = tickTime;
-        this.initLimit = initLimit;
-        this.syncLimit = syncLimit;
-        currentVote = new Vote(myid, getLastLoggedZxid());
-        for (QuorumServer p : quorumPeers) {
-            if (p.id == myid) {
-                myQuorumAddr = p.addr;
-                break;
-            }
-        }
-        if (myQuorumAddr == null) {
-            throw new SocketException(""My id "" + myid + "" not in the peer list"");
-        }
-        if (electionAlg == 0) {
-            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-            new ResponderThread().start();
-        }
-    }
-
-    public QuorumPeer() throws IOException {
-    	// use quorum peer config to instantiate the class 
-		this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
-				getClientPort(), getElectionAlg(), getElectionPort(),
-				getServerId(), getTickTime(), getInitLimit(), getSyncLimit());
-	}
-    public Follower follower;
-
-    public Leader leader;
-
-    protected Follower makeFollower() throws IOException {
-		return new Follower(this, new FollowerZooKeeperServer(dataDir,
-				dataLogDir, this));
-	}
-
-	protected Leader makeLeader() throws IOException {
-		return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
-				this));
-	}
-    
-    public void run() {
-
-        /*
-         * Main loop
-         */
-        Election le = null;
-        switch(electionAlg){
-        case 1:
-            le = new AuthFastLeaderElection(this, this.electionPort);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, this.electionPort, true);                break;
-        case 3:
-            le =
-                new FastLeaderElection(this,
-                        new QuorumCnxManager(this.electionPort));
-        }
-
-        while (running) {
-            switch (state) {
-            case LOOKING:
-                try {
-                    ZooLog.logWarn(""LOOKING"");
-                    long init, end, diff;
-                    switch (electionAlg) {
-                    // Legacy algorithm
-                    case 0:
-                       init = System.currentTimeMillis();
-                        currentVote = new LeaderElection(this).lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff + "" "" + currentVote.id);
-                        break;
-                    // All other algorithms
-                    default:
-                        init = System.currentTimeMillis();
-                        if(le != null) currentVote = le.lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff);
-                        break;
-                    } 
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                    state = ServerState.LOOKING;
-                }
-                break;            
-            case FOLLOWING:
-                try {
-                    ZooLog.logWarn(""FOLLOWING"");
-                    follower = makeFollower();
-                    follower.followLeader();
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    follower.shutdown();
-                    follower = null;
-                    state = ServerState.LOOKING;
-                }
-                break;
-            case LEADING:
-                ZooLog.logWarn(""LEADING"");
-                try {
-                    leader = makeLeader();
-                    leader.lead();
-                    leader = null;
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    if (leader != null) {
-                        leader.shutdown(""Forcing shutdown"");
-                    }
-                    state = ServerState.LOOKING;
-                }
-                break;
-            }
-        }
-        ZooLog.logError(""QuorumPeer main thread exited"");
-    }
-
-    public void shutdown() {
-        running = false;
-        if (leader != null) {
-            leader.shutdown(""quorum Peer shutdown"");
-        }
-        if (follower != null) {
-            follower.shutdown();
-        }
-        cnxnFactory.shutdown();
-        udpSocket.close();
-    }
-
-    long getLastLoggedZxid() {
-        File[] list = dataLogDir.listFiles();
-        if (list == null) {
-            return 0;
-        }
-        long maxLog = -1;
-        long maxSnapShot = 0;
-        for (File f : list) {
-            String name = f.getName();
-            if (name.startsWith(""log."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
-                if (zxid > maxLog) {
-                    maxLog = zxid;
-                }
-            } else if (name.startsWith(""snapshot."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
-                        ""snapshot"");
-                if (zxid > maxLog) {
-                    maxSnapShot = zxid;
-                }
-            }
-        }
-        if (maxSnapShot > maxLog) {
-            return maxSnapShot;
-        }
-        long zxid = maxLog;
-        FileInputStream logStream = null;
-        try {
-            logStream = new FileInputStream(new File(dataLogDir, ""log.""
-                    + Long.toHexString(maxLog)));
-            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
-            while (true) {
-                byte[] bytes = ia.readBuffer(""txnEntry"");
-                if (bytes.length == 0) {
-                    // Since we preallocate, we define EOF to be an
-                    // empty transaction
-                    break;
-                }
-                int B = ia.readByte(""EOR"");
-                if (B != 'B') {
-                    break;
-                }
-                InputArchive bia = BinaryInputArchive
-                        .getArchive(new ByteArrayInputStream(bytes));
-                TxnHeader hdr = new TxnHeader();
-                hdr.deserialize(bia, ""hdr"");
-                zxid = hdr.getZxid();
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(e.toString());
-        } finally {
-            try {
-                if (logStream != null) {
-                    logStream.close();
-                }
-            } catch (IOException e) {
-                ZooLog.logException(e);
-            }
-        }
-        return zxid;
-    }
-
-    public static void runPeer(QuorumPeer.Factory qpFactory) {
-		try {
-			QuorumPeer self = qpFactory.create();
-			self.start();
-			self.join();
-		} catch (Exception e) {
-			ZooLog.logException(e);
-		}
-		System.exit(2);
-	}
-    
-    public static void main(String args[]) {
-		if (args.length == 2) {
-			ZooKeeperServer.main(args);
-			return;
-		}
-		QuorumPeerConfig.parse(args);
-		if (!QuorumPeerConfig.isStandalone()) {
-			runPeer(new QuorumPeer.Factory() {
-				public QuorumPeer create() throws IOException {
-					return new QuorumPeer();
-				}
-			});
-		}else{
-			// there is only server in the quorum -- run as standalone
-			ZooKeeperServer.main(args);
-		}
-	}
-}
+        this.dataLogDir = dataLogDir;
+        this.myid = myid;
+        this.tickTime = tickTime;
+        this.initLimit = initLimit;
+        this.syncLimit = syncLimit;
+        currentVote = new Vote(myid, getLastLoggedZxid());
+        for (QuorumServer p : quorumPeers) {
+            if (p.id == myid) {
+                myQuorumAddr = p.addr;
+                break;
+            }
+        }
+        if (myQuorumAddr == null) {
+            throw new SocketException(""My id "" + myid + "" not in the peer list"");
+        }
+        if (electionAlg == 0) {
+            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
+            new ResponderThread().start();
+        }
+        this.electionAlg = createElectionAlgorithm(electionAlg);
+        QuorumStats.getInstance().setStatsProvider(this);
+    }
+
+    /**
+     * This constructor is only used by the existing unit test code.
+     */
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int clientPort, int electionAlg, int electionPort,
+            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
+        this(quorumPeers,dataDir,dataLogDir,electionAlg,electionPort,myid,tickTime,
+                initLimit,syncLimit,new NIOServerCnxn.Factory(clientPort));
+    }
+    /**
+     *  The constructor uses the quorum peer config to instantiate the class
+     */
+    public QuorumPeer(NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
+                getElectionAlg(), getElectionPort(),getServerId(),getTickTime(), 
+                getInitLimit(), getSyncLimit(),cnxnFactory);
+    }
+    
+    public Follower follower;
+    public Leader leader;
+
+    protected Follower makeFollower(File dataDir,File dataLogDir) throws IOException {
+        return new Follower(this, new FollowerZooKeeperServer(dataDir,
+                dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+
+    protected Leader makeLeader(File dataDir,File dataLogDir) throws IOException {
+        return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
+                this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+    
+    private Election createElectionAlgorithm(int electionAlgorithm){
+        Election le=null;
+        //TODO: use a factory rather than a switch
+        switch (electionAlgorithm) {
+        case 0:
+            // will create a new instance for each run of the protocol
+            break;
+        case 1:
+            le = new AuthFastLeaderElection(this, this.electionPort);
+            break;
+        case 2:
+            le = new AuthFastLeaderElection(this, this.electionPort, true); 
+            break;
+        case 3:
+            le = new FastLeaderElection(this,
+                        new QuorumCnxManager(this.electionPort));
+        default:
+            assert false;
+        }
+        return le;       
+    }
+    
+    protected Election makeLEStrategy(){
+        if(electionAlg==null)
+            return new LeaderElection(this);
+        return electionAlg;
+    }
+    
+    synchronized protected void setLeader(Leader newLeader){
+        leader=newLeader;
+    }
+
+    synchronized protected void setFollower(Follower newFollower){
+        follower=newFollower;
+    }
+    
+    synchronized public ZooKeeperServer getActiveServer(){
+        if(leader!=null)
+            return leader.zk;
+        else if(follower!=null)
+            return follower.zk;
+        return null;
+    }
+    
+    public void run() {
+        /*
+         * Main loop
+         */
+        while (running) {
+            switch (state) {
+            case LOOKING:
+                try {
+                    ZooLog.logWarn(""LOOKING"");
+                    currentVote = makeLEStrategy().lookForLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case FOLLOWING:
+                try {
+                    ZooLog.logWarn(""FOLLOWING"");
+                    setFollower(makeFollower(dataDir,dataLogDir));
+                    follower.followLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    follower.shutdown();
+                    setFollower(null);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case LEADING:
+                ZooLog.logWarn(""LEADING"");
+                try {
+                    setLeader(makeLeader(dataDir,dataLogDir));
+                    leader.lead();
+                    setLeader(null);
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    if (leader != null) {
+                        leader.shutdown(""Forcing shutdown"");
+                        setLeader(null);
+                    }
+                    state = ServerState.LOOKING;
+                }
+                break;
+            }
+        }
+        ZooLog.logError(""QuorumPeer main thread exited"");
+    }
+
+    public void shutdown() {
+        running = false;
+        if (leader != null) {
+            leader.shutdown(""quorum Peer shutdown"");
+        }
+        if (follower != null) {
+            follower.shutdown();
+        }
+        cnxnFactory.shutdown();
+        udpSocket.close();
+    }
+
+    long getLastLoggedZxid() {
+        File[] list = dataLogDir.listFiles();
+        if (list == null) {
+            return 0;
+        }
+        long maxLog = -1;
+        long maxSnapShot = 0;
+        for (File f : list) {
+            String name = f.getName();
+            if (name.startsWith(""log."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
+                if (zxid > maxLog) {
+                    maxLog = zxid;
+                }
+            } else if (name.startsWith(""snapshot."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
+                        ""snapshot"");
+                if (zxid > maxLog) {
+                    maxSnapShot = zxid;
+                }
+            }
+        }
+        if (maxSnapShot > maxLog) {
+            return maxSnapShot;
+        }
+        long zxid = maxLog;
+        FileInputStream logStream = null;
+        try {
+            logStream = new FileInputStream(new File(dataLogDir, ""log.""
+                    + Long.toHexString(maxLog)));
+            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
+            while (true) {
+                byte[] bytes = ia.readBuffer(""txnEntry"");
+                if (bytes.length == 0) {
+                    // Since we preallocate, we define EOF to be an
+                    // empty transaction
+                    break;
+                }
+                int B = ia.readByte(""EOR"");
+                if (B != 'B') {
+                    break;
+                }
+                InputArchive bia = BinaryInputArchive
+                        .getArchive(new ByteArrayInputStream(bytes));
+                TxnHeader hdr = new TxnHeader();
+                hdr.deserialize(bia, ""hdr"");
+                zxid = hdr.getZxid();
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(e.toString());
+        } finally {
+            try {
+                if (logStream != null) {
+                    logStream.close();
+                }
+            } catch (IOException e) {
+                ZooLog.logException(e);
+            }
+        }
+        return zxid;
+    }
+
+    public static void runPeer(QuorumPeer.Factory qpFactory) {
+        try {
+            QuorumStats.registerAsConcrete();
+            QuorumPeer self = qpFactory.create(qpFactory.createConnectionFactory());
+            self.start();
+            self.join();
+        } catch (Exception e) {
+            ZooLog.logException(e);
+        }
+        System.exit(2);
+    }
+    
+    public String[] getQuorumPeers() {
+        List<String> l = new ArrayList<String>();
+        synchronized (this) {
+            if (leader != null) {
+                synchronized (leader.followers) {
+                    for (FollowerHandler fh : leader.followers) {
+                        if (fh.s == null)
+                            continue;
+                        String s = fh.s.getRemoteSocketAddress().toString();
+                        if (leader.isFollowerSynced(fh))
+                            s += ""*"";
+                        l.add(s);
+                    }
+                }
+            } else if (follower != null) {
+                l.add(follower.sock.getRemoteSocketAddress().toString());
+            }
+        }
+        return l.toArray(new String[0]);
+    }
+
+    public String getServerState() {
+        switch (state) {
+        case LOOKING:
+            return QuorumStats.Provider.LOOKING_STATE;
+        case LEADING:
+            return QuorumStats.Provider.LEADING_STATE;
+        case FOLLOWING:
+            return QuorumStats.Provider.FOLLOWING_STATE;
+        }
+        return QuorumStats.Provider.UNKNOWN_STATE;
+    }
+
+    public static void main(String args[]) {
+        if (args.length == 2) {
+            ZooKeeperServer.main(args);
+            return;
+        }
+        QuorumPeerConfig.parse(args);
+        if (!QuorumPeerConfig.isStandalone()) {
+            runPeer(new QuorumPeer.Factory() {
+                public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) 
+                        throws IOException {
+                    return new QuorumPeer(cnxnFactory);
+                }
+                public NIOServerCnxn.Factory createConnectionFactory()
+                        throws IOException {
+                    return new NIOServerCnxn.Factory(getClientPort());
+                }
+            });
+        }else{
+            // there is only server in the quorum -- run as standalone
+            ZooKeeperServer.main(args);
+        }
+    }
+}
",,6461
2248,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumPeer.java,688f039444b44c925b3103cd0d05102a4b7ba690,1204899909,368,,,,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,-1,1207349605/1204899909,"                    leader = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-
-import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.*;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetSocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.InputArchive;
-import com.yahoo.zookeeper.server.NIOServerCnxn;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooLog;
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+
+import static com.yahoo.zookeeper.server.ServerConfig.getClientPort;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataDir;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataLogDir;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionAlg;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionPort;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getInitLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServerId;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServers;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getSyncLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getTickTime;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.InputArchive;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.Vote;
 import com.yahoo.zookeeper.server.quorum.FastLeaderElection;
 import com.yahoo.zookeeper.server.quorum.QuorumCnxManager;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This class manages the quorum protocol. There are three states this server
- * can be in:
- * <ol>
- * <li>Leader election - each server will elect a leader (proposing itself as a
- * leader initially).</li>
- * <li>Follower - the server will synchronize with the leader and replicate any
- * transactions.</li>
- * <li>Leader - the server will process requests and forward them to followers.
- * A majority of followers must log the request before it can be accepted.
- * </ol>
- * 
- * This class will setup a datagram socket that will always respond with its
- * view of the current leader. The response will take the form of:
- * 
- * <pre>
- * int xid;
- * 
- * long myid;
- * 
- * long leader_id;
- * 
- * long leader_zxid;
- * </pre>
- * 
- * The request for the current leader will consist solely of an xid: int xid;
- * 
- * <h2>Configuration file</h2>
- * 
- * When the main() method of this class is used to start the program, the file
- * ""zoo.cfg"" in the current directory will be used to obtain configuration
- * information. zoo.cfg is a Properties file, so keys and values are separated
- * by equals (=) and the key/value pairs are separated by new lines. The
- * following keys are used in the configuration file:
- * <ol>
- * <li>dataDir - The directory where the zookeeper data is stored.</li>
- * <li>clientPort - The port used to communicate with clients.</li>
- * <li>tickTime - The duration of a tick in milliseconds. This is the basic
- * unit of time in zookeeper.</li>
- * <li>initLimit - The maximum number of ticks that a follower will wait to
- * initially synchronize with a leader.</li>
- * <li>syncLimit - The maximum number of ticks that a follower will wait for a
- * message (including heartbeats) from the leader.</li>
- * <li>server.<i>id</i> - This is the host:port that the server with the
- * given id will use for the quorum protocol.</li>
- * </ol>
- * In addition to the zoo.cfg file. There is a file in the data directory called
- * ""myid"" that contains the server id as an ASCII decimal value.
- */
-public class QuorumPeer extends Thread {
-	/**
-	 * Create an instance of a quorum peer 
-	 */
-	public interface Factory{
-		public QuorumPeer create() throws IOException;
-	}
-    public static class QuorumServer {
-        public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-        }
-
-        public InetSocketAddress addr;
-
-        public long id;
-    }
-
-    public enum ServerState {
-        LOOKING, FOLLOWING, LEADING;
-    }
-    /**
-     * The servers that make up the cluster
-     */
-    ArrayList<QuorumServer> quorumPeers;
-    public int getQuorumSize(){
-    	return quorumPeers.size();
-    }
-    /**
-     * My id
-     */
-    private long myid;
-
-
-    /**
-     * get the id of this quorum peer.
-     */
-    public long getId() {
-    	return myid;
-    }
-
-    /**
-     * This is who I think the leader currently is.
-     */
-    volatile Vote currentVote;
-
-    boolean running = true;
-
-    /**
-     * The number of milliseconds of each tick
-     */
-    int tickTime;
-
-    /**
-     * The number of ticks that the initial synchronization phase can take
-     */
-    int initLimit;
-
-    /**
-     * The number of ticks that can pass between sending a request and getting
-     * an acknowledgement
-     */
-    int syncLimit;
-
-    /**
-     * The current tick
-     */
-    int tick;
-
-    /**
-     * This class simply responds to requests for the current leader of this
-     * node.
-     * <p>
-     * The request contains just an xid generated by the requestor.
-     * <p>
-     * The response has the xid, the id of this server, the id of the leader,
-     * and the zxid of the leader.
-     * 
-     * @author breed
-     * 
-     */
-    class ResponderThread extends Thread {
-        ResponderThread() {
-            super(""ResponderThread"");
-        }
-
-        public void run() {
-            try {
-                byte b[] = new byte[36];
-                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
-                DatagramPacket packet = new DatagramPacket(b, b.length);
-                while (true) {
-                    udpSocket.receive(packet);
-                    if (packet.getLength() != 4) {
-                        ZooLog.logError(""Got more than just an xid! Len = ""
-                                + packet.getLength());
-                    } else {
-                        responseBuffer.clear();
-                        responseBuffer.getInt(); // Skip the xid
-                        responseBuffer.putLong(myid);
-                        switch (state) {
-                        case LOOKING:
-                            responseBuffer.putLong(currentVote.id);
-                            responseBuffer.putLong(currentVote.zxid);
-                            break;
-                        case LEADING:
-                            responseBuffer.putLong(myid);
-                            try {
-                                responseBuffer.putLong(leader.lastProposed);
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                            break;
-                        case FOLLOWING:
-                            responseBuffer.putLong(currentVote.id);
-                            try {
-                                responseBuffer.putLong(follower.getZxid());
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                        }
-                        packet.setData(b);
-                        udpSocket.send(packet);
-                    }
-                    packet.setLength(b.length);
-                }
-            } catch (Exception e) {
-                ZooLog.logException(e);
-            } finally {
-                ZooLog.logError(""QuorumPeer responder thread exited"");
-            }
-        }
-    }
-
-    public ServerState state = ServerState.LOOKING;
-
-    DatagramSocket udpSocket;
-
-    InetSocketAddress myQuorumAddr;
-
-    /**
-     * the directory where the snapshot is stored.
-     */
-    private File dataDir;
-
-    /**
-     * the directory where the logs are stored.
-     */
-    private File dataLogDir;
-
-    int clientPort;
-
-    int electionAlg;
-    
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This class manages the quorum protocol. There are three states this server
+ * can be in:
+ * <ol>
+ * <li>Leader election - each server will elect a leader (proposing itself as a
+ * leader initially).</li>
+ * <li>Follower - the server will synchronize with the leader and replicate any
+ * transactions.</li>
+ * <li>Leader - the server will process requests and forward them to followers.
+ * A majority of followers must log the request before it can be accepted.
+ * </ol>
+ * 
+ * This class will setup a datagram socket that will always respond with its
+ * view of the current leader. The response will take the form of:
+ * 
+ * <pre>
+ * int xid;
+ * 
+ * long myid;
+ * 
+ * long leader_id;
+ * 
+ * long leader_zxid;
+ * </pre>
+ * 
+ * The request for the current leader will consist solely of an xid: int xid;
+ * 
+ * <h2>Configuration file</h2>
+ * 
+ * When the main() method of this class is used to start the program, the file
+ * ""zoo.cfg"" in the current directory will be used to obtain configuration
+ * information. zoo.cfg is a Properties file, so keys and values are separated
+ * by equals (=) and the key/value pairs are separated by new lines. The
+ * following keys are used in the configuration file:
+ * <ol>
+ * <li>dataDir - The directory where the zookeeper data is stored.</li>
+ * <li>clientPort - The port used to communicate with clients.</li>
+ * <li>tickTime - The duration of a tick in milliseconds. This is the basic
+ * unit of time in zookeeper.</li>
+ * <li>initLimit - The maximum number of ticks that a follower will wait to
+ * initially synchronize with a leader.</li>
+ * <li>syncLimit - The maximum number of ticks that a follower will wait for a
+ * message (including heartbeats) from the leader.</li>
+ * <li>server.<i>id</i> - This is the host:port that the server with the
+ * given id will use for the quorum protocol.</li>
+ * </ol>
+ * In addition to the zoo.cfg file. There is a file in the data directory called
+ * ""myid"" that contains the server id as an ASCII decimal value.
+ */
+public class QuorumPeer extends Thread implements QuorumStats.Provider {
+    /**
+     * Create an instance of a quorum peer 
+     */
+    public interface Factory{
+        public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) throws IOException;
+        public NIOServerCnxn.Factory createConnectionFactory() throws IOException;
+    }
+    
+    public static class QuorumServer {
+        public QuorumServer(long id, InetSocketAddress addr) {
+            this.id = id;
+            this.addr = addr;
+        }
+
+        public InetSocketAddress addr;
+
+        public long id;
+    }
+
+    public enum ServerState {
+        LOOKING, FOLLOWING, LEADING;
+    }
+    /**
+     * The servers that make up the cluster
+     */
+    ArrayList<QuorumServer> quorumPeers;
+    public int getQuorumSize(){
+        return quorumPeers.size();
+    }
+    /**
+     * My id
+     */
+    private long myid;
+
+
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getId() {
+        return myid;
+    }
+
+    /**
+     * This is who I think the leader currently is.
+     */
+    volatile Vote currentVote;
+
+    volatile boolean running = true;
+
+    /**
+     * The number of milliseconds of each tick
+     */
+    int tickTime;
+
+    /**
+     * The number of ticks that the initial synchronization phase can take
+     */
+    int initLimit;
+
+    /**
+     * The number of ticks that can pass between sending a request and getting
+     * an acknowledgement
+     */
+    int syncLimit;
+
+    /**
+     * The current tick
+     */
+    int tick;
+
+    /**
+     * This class simply responds to requests for the current leader of this
+     * node.
+     * <p>
+     * The request contains just an xid generated by the requestor.
+     * <p>
+     * The response has the xid, the id of this server, the id of the leader,
+     * and the zxid of the leader.
+     * 
+     * @author breed
+     * 
+     */
+    class ResponderThread extends Thread {
+        ResponderThread() {
+            super(""ResponderThread"");
+        }
+
+        public void run() {
+            try {
+                byte b[] = new byte[36];
+                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
+                DatagramPacket packet = new DatagramPacket(b, b.length);
+                while (true) {
+                    udpSocket.receive(packet);
+                    if (packet.getLength() != 4) {
+                        ZooLog.logError(""Got more than just an xid! Len = ""
+                                + packet.getLength());
+                    } else {
+                        responseBuffer.clear();
+                        responseBuffer.getInt(); // Skip the xid
+                        responseBuffer.putLong(myid);
+                        switch (state) {
+                        case LOOKING:
+                            responseBuffer.putLong(currentVote.id);
+                            responseBuffer.putLong(currentVote.zxid);
+                            break;
+                        case LEADING:
+                            responseBuffer.putLong(myid);
+                            try {
+                                responseBuffer.putLong(leader.lastProposed);
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                            break;
+                        case FOLLOWING:
+                            responseBuffer.putLong(currentVote.id);
+                            try {
+                                responseBuffer.putLong(follower.getZxid());
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                        }
+                        packet.setData(b);
+                        udpSocket.send(packet);
+                    }
+                    packet.setLength(b.length);
+                }
+            } catch (Exception e) {
+                ZooLog.logException(e);
+            } finally {
+                ZooLog.logError(""QuorumPeer responder thread exited"");
+            }
+        }
+    }
+
+    private ServerState state = ServerState.LOOKING;
+    
+    public void setPeerState(ServerState newState){
+        state=newState;
+    }
+    
+    public ServerState getPeerState(){
+        return state;
+    }
+    
+    DatagramSocket udpSocket;
+
+    private InetSocketAddress myQuorumAddr;
+    
+    public InetSocketAddress getQuorumAddress(){
+        return myQuorumAddr;
+    }
+
+    /**
+     * the directory where the snapshot is stored.
+     */
+    private File dataDir;
+
+    /**
+     * the directory where the logs are stored.
+     */
+    private File dataLogDir;
+
+    Election electionAlg;
+
     int electionPort;
 
-    NIOServerCnxn.Factory cnxnFactory;
-
-    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
-            File dataLogDir, int clientPort, int electionAlg, int electionPort,
-            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
-        super(""QuorumPeer"");
-        this.clientPort = clientPort;
-        this.cnxnFactory = new NIOServerCnxn.Factory(clientPort, this);
-        this.quorumPeers = quorumPeers;
-        this.dataDir = dataDir;
-        this.electionAlg = electionAlg;
+    NIOServerCnxn.Factory cnxnFactory;
+
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionAlg, int electionPort,long myid, int tickTime, 
+            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        super(""QuorumPeer"");
+        this.cnxnFactory = cnxnFactory;
+        this.quorumPeers = quorumPeers;
+        this.dataDir = dataDir;
         this.electionPort = electionPort;
-        this.dataLogDir = dataLogDir;
-        this.myid = myid;
-        this.tickTime = tickTime;
-        this.initLimit = initLimit;
-        this.syncLimit = syncLimit;
-        currentVote = new Vote(myid, getLastLoggedZxid());
-        for (QuorumServer p : quorumPeers) {
-            if (p.id == myid) {
-                myQuorumAddr = p.addr;
-                break;
-            }
-        }
-        if (myQuorumAddr == null) {
-            throw new SocketException(""My id "" + myid + "" not in the peer list"");
-        }
-        if (electionAlg == 0) {
-            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-            new ResponderThread().start();
-        }
-    }
-
-    public QuorumPeer() throws IOException {
-    	// use quorum peer config to instantiate the class 
-		this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
-				getClientPort(), getElectionAlg(), getElectionPort(),
-				getServerId(), getTickTime(), getInitLimit(), getSyncLimit());
-	}
-    public Follower follower;
-
-    public Leader leader;
-
-    protected Follower makeFollower() throws IOException {
-		return new Follower(this, new FollowerZooKeeperServer(dataDir,
-				dataLogDir, this));
-	}
-
-	protected Leader makeLeader() throws IOException {
-		return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
-				this));
-	}
-    
-    public void run() {
-
-        /*
-         * Main loop
-         */
-        Election le = null;
-        switch(electionAlg){
-        case 1:
-            le = new AuthFastLeaderElection(this, this.electionPort);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, this.electionPort, true);                break;
-        case 3:
-            le =
-                new FastLeaderElection(this,
-                        new QuorumCnxManager(this.electionPort));
-        }
-
-        while (running) {
-            switch (state) {
-            case LOOKING:
-                try {
-                    ZooLog.logWarn(""LOOKING"");
-                    long init, end, diff;
-                    switch (electionAlg) {
-                    // Legacy algorithm
-                    case 0:
-                       init = System.currentTimeMillis();
-                        currentVote = new LeaderElection(this).lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff + "" "" + currentVote.id);
-                        break;
-                    // All other algorithms
-                    default:
-                        init = System.currentTimeMillis();
-                        if(le != null) currentVote = le.lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn(""Leader election latency: "" + diff);
-                        break;
-                    } 
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                    state = ServerState.LOOKING;
-                }
-                break;            
-            case FOLLOWING:
-                try {
-                    ZooLog.logWarn(""FOLLOWING"");
-                    follower = makeFollower();
-                    follower.followLeader();
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    follower.shutdown();
-                    follower = null;
-                    state = ServerState.LOOKING;
-                }
-                break;
-            case LEADING:
-                ZooLog.logWarn(""LEADING"");
-                try {
-                    leader = makeLeader();
-                    leader.lead();
-                    leader = null;
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    if (leader != null) {
-                        leader.shutdown(""Forcing shutdown"");
-                    }
-                    state = ServerState.LOOKING;
-                }
-                break;
-            }
-        }
-        ZooLog.logError(""QuorumPeer main thread exited"");
-    }
-
-    public void shutdown() {
-        running = false;
-        if (leader != null) {
-            leader.shutdown(""quorum Peer shutdown"");
-        }
-        if (follower != null) {
-            follower.shutdown();
-        }
-        cnxnFactory.shutdown();
-        udpSocket.close();
-    }
-
-    long getLastLoggedZxid() {
-        File[] list = dataLogDir.listFiles();
-        if (list == null) {
-            return 0;
-        }
-        long maxLog = -1;
-        long maxSnapShot = 0;
-        for (File f : list) {
-            String name = f.getName();
-            if (name.startsWith(""log."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
-                if (zxid > maxLog) {
-                    maxLog = zxid;
-                }
-            } else if (name.startsWith(""snapshot."")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
-                        ""snapshot"");
-                if (zxid > maxLog) {
-                    maxSnapShot = zxid;
-                }
-            }
-        }
-        if (maxSnapShot > maxLog) {
-            return maxSnapShot;
-        }
-        long zxid = maxLog;
-        FileInputStream logStream = null;
-        try {
-            logStream = new FileInputStream(new File(dataLogDir, ""log.""
-                    + Long.toHexString(maxLog)));
-            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
-            while (true) {
-                byte[] bytes = ia.readBuffer(""txnEntry"");
-                if (bytes.length == 0) {
-                    // Since we preallocate, we define EOF to be an
-                    // empty transaction
-                    break;
-                }
-                int B = ia.readByte(""EOR"");
-                if (B != 'B') {
-                    break;
-                }
-                InputArchive bia = BinaryInputArchive
-                        .getArchive(new ByteArrayInputStream(bytes));
-                TxnHeader hdr = new TxnHeader();
-                hdr.deserialize(bia, ""hdr"");
-                zxid = hdr.getZxid();
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(e.toString());
-        } finally {
-            try {
-                if (logStream != null) {
-                    logStream.close();
-                }
-            } catch (IOException e) {
-                ZooLog.logException(e);
-            }
-        }
-        return zxid;
-    }
-
-    public static void runPeer(QuorumPeer.Factory qpFactory) {
-		try {
-			QuorumPeer self = qpFactory.create();
-			self.start();
-			self.join();
-		} catch (Exception e) {
-			ZooLog.logException(e);
-		}
-		System.exit(2);
-	}
-    
-    public static void main(String args[]) {
-		if (args.length == 2) {
-			ZooKeeperServer.main(args);
-			return;
-		}
-		QuorumPeerConfig.parse(args);
-		if (!QuorumPeerConfig.isStandalone()) {
-			runPeer(new QuorumPeer.Factory() {
-				public QuorumPeer create() throws IOException {
-					return new QuorumPeer();
-				}
-			});
-		}else{
-			// there is only server in the quorum -- run as standalone
-			ZooKeeperServer.main(args);
-		}
-	}
-}
+        this.dataLogDir = dataLogDir;
+        this.myid = myid;
+        this.tickTime = tickTime;
+        this.initLimit = initLimit;
+        this.syncLimit = syncLimit;
+        currentVote = new Vote(myid, getLastLoggedZxid());
+        for (QuorumServer p : quorumPeers) {
+            if (p.id == myid) {
+                myQuorumAddr = p.addr;
+                break;
+            }
+        }
+        if (myQuorumAddr == null) {
+            throw new SocketException(""My id "" + myid + "" not in the peer list"");
+        }
+        if (electionAlg == 0) {
+            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
+            new ResponderThread().start();
+        }
+        this.electionAlg = createElectionAlgorithm(electionAlg);
+        QuorumStats.getInstance().setStatsProvider(this);
+    }
+
+    /**
+     * This constructor is only used by the existing unit test code.
+     */
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int clientPort, int electionAlg, int electionPort,
+            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
+        this(quorumPeers,dataDir,dataLogDir,electionAlg,electionPort,myid,tickTime,
+                initLimit,syncLimit,new NIOServerCnxn.Factory(clientPort));
+    }
+    /**
+     *  The constructor uses the quorum peer config to instantiate the class
+     */
+    public QuorumPeer(NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
+                getElectionAlg(), getElectionPort(),getServerId(),getTickTime(), 
+                getInitLimit(), getSyncLimit(),cnxnFactory);
+    }
+    
+    public Follower follower;
+    public Leader leader;
+
+    protected Follower makeFollower(File dataDir,File dataLogDir) throws IOException {
+        return new Follower(this, new FollowerZooKeeperServer(dataDir,
+                dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+
+    protected Leader makeLeader(File dataDir,File dataLogDir) throws IOException {
+        return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
+                this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+    
+    private Election createElectionAlgorithm(int electionAlgorithm){
+        Election le=null;
+        //TODO: use a factory rather than a switch
+        switch (electionAlgorithm) {
+        case 0:
+            // will create a new instance for each run of the protocol
+            break;
+        case 1:
+            le = new AuthFastLeaderElection(this, this.electionPort);
+            break;
+        case 2:
+            le = new AuthFastLeaderElection(this, this.electionPort, true); 
+            break;
+        case 3:
+            le = new FastLeaderElection(this,
+                        new QuorumCnxManager(this.electionPort));
+        default:
+            assert false;
+        }
+        return le;       
+    }
+    
+    protected Election makeLEStrategy(){
+        if(electionAlg==null)
+            return new LeaderElection(this);
+        return electionAlg;
+    }
+    
+    synchronized protected void setLeader(Leader newLeader){
+        leader=newLeader;
+    }
+
+    synchronized protected void setFollower(Follower newFollower){
+        follower=newFollower;
+    }
+    
+    synchronized public ZooKeeperServer getActiveServer(){
+        if(leader!=null)
+            return leader.zk;
+        else if(follower!=null)
+            return follower.zk;
+        return null;
+    }
+    
+    public void run() {
+        /*
+         * Main loop
+         */
+        while (running) {
+            switch (state) {
+            case LOOKING:
+                try {
+                    ZooLog.logWarn(""LOOKING"");
+                    currentVote = makeLEStrategy().lookForLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case FOLLOWING:
+                try {
+                    ZooLog.logWarn(""FOLLOWING"");
+                    setFollower(makeFollower(dataDir,dataLogDir));
+                    follower.followLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    follower.shutdown();
+                    setFollower(null);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case LEADING:
+                ZooLog.logWarn(""LEADING"");
+                try {
+                    setLeader(makeLeader(dataDir,dataLogDir));
+                    leader.lead();
+                    setLeader(null);
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    if (leader != null) {
+                        leader.shutdown(""Forcing shutdown"");
+                        setLeader(null);
+                    }
+                    state = ServerState.LOOKING;
+                }
+                break;
+            }
+        }
+        ZooLog.logError(""QuorumPeer main thread exited"");
+    }
+
+    public void shutdown() {
+        running = false;
+        if (leader != null) {
+            leader.shutdown(""quorum Peer shutdown"");
+        }
+        if (follower != null) {
+            follower.shutdown();
+        }
+        cnxnFactory.shutdown();
+        udpSocket.close();
+    }
+
+    long getLastLoggedZxid() {
+        File[] list = dataLogDir.listFiles();
+        if (list == null) {
+            return 0;
+        }
+        long maxLog = -1;
+        long maxSnapShot = 0;
+        for (File f : list) {
+            String name = f.getName();
+            if (name.startsWith(""log."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), ""log"");
+                if (zxid > maxLog) {
+                    maxLog = zxid;
+                }
+            } else if (name.startsWith(""snapshot."")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
+                        ""snapshot"");
+                if (zxid > maxLog) {
+                    maxSnapShot = zxid;
+                }
+            }
+        }
+        if (maxSnapShot > maxLog) {
+            return maxSnapShot;
+        }
+        long zxid = maxLog;
+        FileInputStream logStream = null;
+        try {
+            logStream = new FileInputStream(new File(dataLogDir, ""log.""
+                    + Long.toHexString(maxLog)));
+            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
+            while (true) {
+                byte[] bytes = ia.readBuffer(""txnEntry"");
+                if (bytes.length == 0) {
+                    // Since we preallocate, we define EOF to be an
+                    // empty transaction
+                    break;
+                }
+                int B = ia.readByte(""EOR"");
+                if (B != 'B') {
+                    break;
+                }
+                InputArchive bia = BinaryInputArchive
+                        .getArchive(new ByteArrayInputStream(bytes));
+                TxnHeader hdr = new TxnHeader();
+                hdr.deserialize(bia, ""hdr"");
+                zxid = hdr.getZxid();
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(e.toString());
+        } finally {
+            try {
+                if (logStream != null) {
+                    logStream.close();
+                }
+            } catch (IOException e) {
+                ZooLog.logException(e);
+            }
+        }
+        return zxid;
+    }
+
+    public static void runPeer(QuorumPeer.Factory qpFactory) {
+        try {
+            QuorumStats.registerAsConcrete();
+            QuorumPeer self = qpFactory.create(qpFactory.createConnectionFactory());
+            self.start();
+            self.join();
+        } catch (Exception e) {
+            ZooLog.logException(e);
+        }
+        System.exit(2);
+    }
+    
+    public String[] getQuorumPeers() {
+        List<String> l = new ArrayList<String>();
+        synchronized (this) {
+            if (leader != null) {
+                synchronized (leader.followers) {
+                    for (FollowerHandler fh : leader.followers) {
+                        if (fh.s == null)
+                            continue;
+                        String s = fh.s.getRemoteSocketAddress().toString();
+                        if (leader.isFollowerSynced(fh))
+                            s += ""*"";
+                        l.add(s);
+                    }
+                }
+            } else if (follower != null) {
+                l.add(follower.sock.getRemoteSocketAddress().toString());
+            }
+        }
+        return l.toArray(new String[0]);
+    }
+
+    public String getServerState() {
+        switch (state) {
+        case LOOKING:
+            return QuorumStats.Provider.LOOKING_STATE;
+        case LEADING:
+            return QuorumStats.Provider.LEADING_STATE;
+        case FOLLOWING:
+            return QuorumStats.Provider.FOLLOWING_STATE;
+        }
+        return QuorumStats.Provider.UNKNOWN_STATE;
+    }
+
+    public static void main(String args[]) {
+        if (args.length == 2) {
+            ZooKeeperServer.main(args);
+            return;
+        }
+        QuorumPeerConfig.parse(args);
+        if (!QuorumPeerConfig.isStandalone()) {
+            runPeer(new QuorumPeer.Factory() {
+                public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) 
+                        throws IOException {
+                    return new QuorumPeer(cnxnFactory);
+                }
+                public NIOServerCnxn.Factory createConnectionFactory()
+                        throws IOException {
+                    return new NIOServerCnxn.Factory(getClientPort());
+                }
+            });
+        }else{
+            // there is only server in the quorum -- run as standalone
+            ZooKeeperServer.main(args);
+        }
+    }
+}
",,6461
2249,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/test/com/yahoo/zookeeper/test/DataTreeTest.java,bf1880ecb1385d570461213c352ff80b6ec9fb2f,1206576387,39,a5cc7ba8b6739698f81f7d50bdac8f610f60d5b8,1207089029,38,,,,,"        dt=null;",,,6461
2250,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/ServerStats.java,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,43,,,,,,,,"        instance=null;",,,6461
2251,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,501,5347de99d0d1fdd1d41ffb02e69931eda5fa2342,1210628199,493,,,,,"            recvWorker = null;",,,6461
2252,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,7f56417f9404afb0f8975b0fe616433ab75a5de8,1207349605,572,a6bc7d54791e73b06083996ab57fdba9340ae1aa,1210283432,570,,,,,"                        recvWorker = null;",,,6461
2253,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/test/com/yahoo/zookeeper/test/AsyncTest.java,a40b75cd0894135def963ae24b8cbe37041a0592,1207349686,56,ffce83512370e970426f7f6b7cff8f519de59bd4,1210633285,58,,,,,"        clientConnected=null;",,,6461
2254,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/test/com/yahoo/zookeeper/test/ClientTest.java,a40b75cd0894135def963ae24b8cbe37041a0592,1207349686,59,e2f182cf0c095784e205b5bd63d72c73d1258297,1211225341,63,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,-1,1212778917/1207349686,"        clientConnected=null;"," import com.yahoo.zookeeper.ZooDefs.Ids;
 import com.yahoo.zookeeper.data.Stat;
 import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.NIOServerCnxn;
-import com.yahoo.zookeeper.server.ServerStats;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-
-public class ClientTest extends TestCase implements Watcher {
-    private static final Logger LOG = Logger.getLogger(ClientTest.class);
-
-    private static final int CONNECTION_TIMEOUT=30000;
-    protected static String hostPort = ""127.0.0.1:33221"";
-    LinkedBlockingQueue<WatcherEvent> events = new LinkedBlockingQueue<WatcherEvent>();
-    static File baseTest = new File(System.getProperty(""build.test.dir"", ""build""));
-    NIOServerCnxn.Factory f = null;
-    File tmpDir = null;
-    volatile private CountDownLatch clientConnected;
-
-    protected void setUp() throws Exception {
-        LOG.error(""Client test setup"");
-        tmpDir = File.createTempFile(""test"", "".junit"", baseTest);
-        tmpDir = new File(tmpDir + "".dir"");
-        tmpDir.mkdirs();
-    	ServerStats.registerAsConcrete();
-        ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
-        hostPort = ""127.0.0.1:33221"";
-        f = new NIOServerCnxn.Factory(33221);
-        f.startup(zks);
-        Thread.sleep(5000);
-        LOG.error(""Client test setup finished"");
-    }
-
-    protected void tearDown() throws Exception {
-        LOG.error(""Clent test shutdown"");
-        if (tmpDir != null) {
-            recursiveDelete(tmpDir);
-        }
-        if (f != null) {
-            f.shutdown();
-        }
-    	ServerStats.unregister();
-        clientConnected=null;
-        LOG.error(""Client test shutdown finished"");
-    }
     
-    static void recursiveDelete(File d) {
-        if (d.isDirectory()) {
-            File children[] = d.listFiles();
-            for (File f : children) {
-                recursiveDelete(f);
-            }
-        }
-        d.delete();
-    }
+public class ClientTest extends ClientBase implements Watcher {
+    LinkedBlockingQueue<WatcherEvent> events = 
+        new LinkedBlockingQueue<WatcherEvent>();
+    protected volatile CountDownLatch clientConnected;
 
-    private ZooKeeper createClient() throws IOException,InterruptedException{
+    protected ZooKeeper createClient(Watcher watcher) 
+        throws IOException, InterruptedException
+    {
         clientConnected=new CountDownLatch(1);
-		ZooKeeper zk = new ZooKeeper(hostPort, 20000, this);
+        ZooKeeper zk = new ZooKeeper(hostPort, 20000, watcher);
 		if(!clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)){
 			fail(""Unable to connect to server"");
 		}
 		return zk;
     }
     
+    protected void tearDown() throws Exception {
+        clientConnected = null;
+        super.tearDown();
+    }
+
     @Test
     public void testPing() throws Exception {
         ZooKeeper zkIdle = null;
         ZooKeeper zkWatchCreator = null;
         try {
-            zkIdle = createClient();
-            zkWatchCreator = createClient();
+            zkIdle = createClient(this);
+            zkWatchCreator = createClient(this);
             for (int i = 0; i < 30; i++) {
                 zkWatchCreator.create(""/"" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, 0);
             }
",,6461
2255,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/DataTree.java,90090902302f923a98b24185a56b392ca4144e54,1207716357,533,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,554,,,,,"        root = null;",,,6461
2256,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/ZooLog.java,888e0c5fc576415a7949a938bf1aad4be74984eb,1209508052,146,8b68d78491052fc44bb5ef51ad866ce48d078725,1209508602,146,,,,,"                textTos = null;",,,6461
2257,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ClientCnxn.java,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,762,,,,ffce83512370e970426f7f6b7cff8f519de59bd4,1210633285,-1,1210633285/1210382051,"            sockKey = null;","-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.lang.Thread.UncaughtExceptionHandler;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.SocketChannel;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
-import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
-import com.yahoo.zookeeper.AsyncCallback.DataCallback;
-import com.yahoo.zookeeper.AsyncCallback.StatCallback;
-import com.yahoo.zookeeper.AsyncCallback.StringCallback;
-import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
-import com.yahoo.zookeeper.Watcher.Event;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.ZooKeeper.States;
-import com.yahoo.zookeeper.proto.AuthPacket;
-import com.yahoo.zookeeper.proto.ConnectRequest;
-import com.yahoo.zookeeper.proto.ConnectResponse;
-import com.yahoo.zookeeper.proto.CreateResponse;
-import com.yahoo.zookeeper.proto.ExistsResponse;
-import com.yahoo.zookeeper.proto.GetACLResponse;
-import com.yahoo.zookeeper.proto.GetChildrenResponse;
-import com.yahoo.zookeeper.proto.GetDataResponse;
-import com.yahoo.zookeeper.proto.ReplyHeader;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.proto.SetACLResponse;
-import com.yahoo.zookeeper.proto.SetDataResponse;
-import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.ByteBufferInputStream;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooTrace;
-
-/**
- * This class manages the socket i/o for the client. ClientCnxn maintains a list
- * of available servers to connect to and ""transparently"" switches servers it is
- * connected to as needed.
- *
- */
-class ClientCnxn {
-    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
-
-    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
-
-    static class AuthData {
-        AuthData(String scheme, byte data[]) {
-            this.scheme = scheme;
-            this.data = data;
-        }
-
-        String scheme;
-
-        byte data[];
-    }
-
-    private ArrayList<AuthData> authInfo = new ArrayList<AuthData>();
-
-    /**
-     * These are the packets that have been sent and are waiting for a response.
-     */
-    private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
-
-    private LinkedBlockingQueue waitingEvents = new LinkedBlockingQueue();
-
-    /**
-     * These are the packets that need to be sent.
-     */
-    private LinkedList<Packet> outgoingQueue = new LinkedList<Packet>();
-
-    private int nextAddrToTry = 0;
-
-    private int connectTimeout;
-
-    private int readTimeout;
-
-    private final int sessionTimeout;
-
-    private final ZooKeeper zooKeeper;
-
-    private long sessionId;
-
-    private byte sessionPasswd[] = new byte[16];
-
-    final SendThread sendThread;
-
-    final EventThread eventThread;
-
-    final Selector selector = Selector.open();
-
-    public long getSessionId() {
-        return sessionId;
-    }
-
-    public byte[] getSessionPasswd() {
-        return sessionPasswd;
-    }
-
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append(""sessionId: "").append(sessionId).append(""\n"");
-        sb.append(""lastZxid: "").append(lastZxid).append(""\n"");
-        sb.append(""xid: "").append(xid).append(""\n"");
-        sb.append(""nextAddrToTry: "").append(nextAddrToTry).append(""\n"");
-        sb.append(""serverAddrs: "").append(serverAddrs.get(nextAddrToTry))
-                .append(""\n"");
-        return sb.toString();
-    }
-
-    /**
-     * This class allows us to pass the headers and the relevant records around.
-     */
-    static class Packet {
-        RequestHeader header;
-
-        ByteBuffer bb;
-
-        String path;
-
-        ReplyHeader replyHeader;
-
-        Record request;
-
-        Record response;
-
-        boolean finished;
-
-        AsyncCallback cb;
-
-        Object ctx;
-
-        Packet(RequestHeader header, ReplyHeader replyHeader, Record record,
-                Record response, ByteBuffer bb) {
-            this.header = header;
-            this.replyHeader = replyHeader;
-            this.request = record;
-            this.response = response;
-            if (bb != null) {
-                this.bb = bb;
-            } else {
-                try {
-                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                    BinaryOutputArchive boa = BinaryOutputArchive
-                            .getArchive(baos);
-                    boa.writeInt(-1, ""len""); // We'll fill this in later
-                    header.serialize(boa, ""header"");
-                    if (record != null) {
-                        record.serialize(boa, ""request"");
-                    }
-                    baos.close();
-                    this.bb = ByteBuffer.wrap(baos.toByteArray());
-                    this.bb.putInt(this.bb.capacity() - 4);
-                    this.bb.rewind();
-                } catch (IOException e) {
-                    LOG.warn(""Unexpected exception"",e);
-                }
-            }
-        }
-    }
-
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper)
-            throws KeeperException, IOException {
-        this(hosts, sessionTimeout, zooKeeper, 0, new byte[16]);
-    }
-
-    /**
-     * Creates a connection object. The actual network connect doesn't get
-     * established until needed.
-     *
-     * @param hosts
-     *                a comma separated list of hosts that can be connected to.
-     * @param connectTimeout
-     *                the timeout for connections.
-     * @param readTimeout
-     *                the read timeout.
-     * @param zooKeeper
-     *                the zookeeper object that this connection is related to.
-     * @throws KeeperException
-     * @throws IOException
-     */
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
-            long sessionId, byte[] sessionPasswd) throws KeeperException,
-            IOException {
-        this.zooKeeper = zooKeeper;
-        this.sessionId = sessionId;
-        this.sessionPasswd = sessionPasswd;
-        String hostsList[] = hosts.split("","");
-        for (String host : hostsList) {
-            int port = 2181;
-            String parts[] = host.split("":"");
-            if (parts.length > 1) {
-                port = Integer.parseInt(parts[1]);
-                host = parts[0];
-            }
-            InetAddress addrs[] = InetAddress.getAllByName(host);
-            for (InetAddress addr : addrs) {
-                serverAddrs.add(new InetSocketAddress(addr, port));
-            }
-        }
-        this.sessionTimeout = sessionTimeout;
-        connectTimeout = sessionTimeout / hostsList.length;
-        readTimeout = sessionTimeout * 2 / 3;
-        Collections.shuffle(serverAddrs);
-        sendThread = new SendThread();
-        sendThread.start();
-        eventThread = new EventThread();
-        eventThread.start();
-    }
-
-    WatcherEvent eventOfDeath = new WatcherEvent();
-
-    final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
-        public void uncaughtException(Thread t, Throwable e) {
-            LOG.error(""from "" + t.getName(), e);
-        }
-    };
-
-    class EventThread extends Thread {
-        EventThread() {
-            super(""EventThread"");
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
-            setDaemon(true);
-        }
-
-        public void run() {
-            try {
-                while (true) {
-                    Object event = waitingEvents.take();
-                    if (event == eventOfDeath) {
-                        break;
-                    }
-                    if (event instanceof WatcherEvent) {
-                        zooKeeper.watcher.process((WatcherEvent) event);
-                    } else {
-                        Packet p = (Packet) event;
-                        int rc = 0;
-                        String path = p.path;
-                        if (p.replyHeader.getErr() != 0) {
-                            rc = p.replyHeader.getErr();
-                        }
-                        if (p.cb == null) {
-                            LOG.warn(""Somehow a null cb got to EventThread!"");
-                        } else if (p.response instanceof ExistsResponse
-                                || p.response instanceof SetDataResponse
-                                || p.response instanceof SetACLResponse) {
-                            StatCallback cb = (StatCallback) p.cb;
-                            if (rc == 0) {
-                                if (p.response instanceof ExistsResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((ExistsResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetDataResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetDataResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetACLResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetACLResponse) p.response)
-                                                    .getStat());
-                                }
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.response instanceof GetDataResponse) {
-                            DataCallback cb = (DataCallback) p.cb;
-                            GetDataResponse rsp = (GetDataResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx,
-                                        rsp.getData(), rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
-                            }
-                        } else if (p.response instanceof GetACLResponse) {
-                            ACLCallback cb = (ACLCallback) p.cb;
-                            GetACLResponse rsp = (GetACLResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp.getAcl(),
-                                        rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
-                            }
-                        } else if (p.response instanceof GetChildrenResponse) {
-                            ChildrenCallback cb = (ChildrenCallback) p.cb;
-                            GetChildrenResponse rsp = (GetChildrenResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp
-                                        .getChildren());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.response instanceof CreateResponse) {
-                            StringCallback cb = (StringCallback) p.cb;
-                            CreateResponse rsp = (CreateResponse) p.response;
-                            if (rc == 0) {
-                                cb
-                                        .processResult(rc, path, p.ctx, rsp
-                                                .getPath());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.cb instanceof VoidCallback) {
-                            VoidCallback cb = (VoidCallback) p.cb;
-                            cb.processResult(rc, path, p.ctx);
-                        }
-                    }
-                }
-            } catch (InterruptedException e) {
-            }
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    private void finishPacket(Packet p) {
-        p.finished = true;
-        if (p.cb == null) {
-            synchronized (p) {
-                p.notifyAll();
-            }
-        } else {
-            waitingEvents.add(p);
-        }
-    }
-
-    private void conLossPacket(Packet p) {
-        if (p.replyHeader == null) {
-            return;
-        }
-        switch(zooKeeper.state) {
-        case AUTH_FAILED:
-            p.replyHeader.setErr(KeeperException.Code.AuthFailed);
-            break;
-        case CLOSED:
-            p.replyHeader.setErr(KeeperException.Code.SessionExpired);
-            break;
-        default:
-            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
-        }
-        finishPacket(p);
-    }
-
-    long lastZxid;
-
-    /**
-     * This class services the outgoing request queue and generates the heart
-     * beats. It also spawns the ReadThread.
-     */
-    class SendThread extends Thread {
-        SelectionKey sockKey;
-
-        ByteBuffer lenBuffer = ByteBuffer.allocateDirect(4);
-
-        ByteBuffer incomingBuffer = lenBuffer;
-
-        boolean initialized;
-
-        void readLength() throws IOException {
-            int len = incomingBuffer.getInt();
-            if (len < 0 || len >= 4096 * 1024) {
-                throw new IOException(""Packet len"" + len + "" is out of range!"");
-            }
-            incomingBuffer = ByteBuffer.allocate(len);
-        }
-
-        void readConnectResult() throws IOException {
-            ByteBufferInputStream bbis = new ByteBufferInputStream(
-                    incomingBuffer);
-            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
-            ConnectResponse conRsp = new ConnectResponse();
-            conRsp.deserialize(bbia, ""connect"");
-            int sessionTimeout = conRsp.getTimeOut();
-            if (sessionTimeout <= 0) {
-                zooKeeper.state = States.CLOSED;
-                waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
-                        Watcher.Event.KeeperStateExpired, null));
-                throw new IOException(""Session Expired"");
-            }
-            readTimeout = sessionTimeout * 2 / 3;
-            connectTimeout = sessionTimeout / serverAddrs.size();
-            sessionId = conRsp.getSessionId();
-            sessionPasswd = conRsp.getPasswd();
-            waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
-                    Watcher.Event.KeeperStateSyncConnected, null));
-        }
-
-        @SuppressWarnings(""unchecked"")
-        void readResponse() throws IOException {
-            ByteBufferInputStream bbis = new ByteBufferInputStream(
-                    incomingBuffer);
-            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
-            ReplyHeader r = new ReplyHeader();
-
-            r.deserialize(bbia, ""header"");
-            if (r.getXid() == -2) {
-                // -2 is the xid for pings
-                return;
-            }
-            if (r.getXid() == -4) {
-                // -2 is the xid for AuthPacket
-                // TODO: process AuthPacket here
-                return;
-            }
-            if (r.getXid() == -1) {
-                // -1 means notification
-                WatcherEvent event = new WatcherEvent();
-                event.deserialize(bbia, ""response"");
-                // System.out.println(""Got an event: "" + event + "" for "" +
-                // sessionId + "" through"" + _cnxn);
-                waitingEvents.add(event);
-                return;
-            }
-            if (pendingQueue.size() == 0) {
-                throw new IOException(""Nothing in the queue, but got ""
-                        + r.getXid());
-            }
-            Packet p = null;
-            synchronized (pendingQueue) {
-                p = pendingQueue.remove();
-            }
-            /*
-             * Since requests are processed in order, we better get a response
-             * to the first request!
-             */
-            if (p.header.getXid() != r.getXid()) {
-                throw new IOException(""Xid out of order. Got "" + r.getXid()
-                        + "" expected "" + p.header.getXid());
-            }
-            p.replyHeader.setXid(r.getXid());
-            p.replyHeader.setErr(r.getErr());
-            p.replyHeader.setZxid(r.getZxid());
-            lastZxid = r.getZxid();
-            if (p.response != null && r.getErr() == 0) {
-                p.response.deserialize(bbia, ""response"");
-            }
-            p.finished = true;
-            finishPacket(p);
-        }
-
-        /**
-         * @return true if a packet was received
-         * @param k
-         * @throws InterruptedException
-         * @throws IOException
-         */
-        boolean doIO() throws InterruptedException, IOException {
-            boolean packetReceived = false;
-            SocketChannel sock = (SocketChannel) sockKey.channel();
-            if (sock == null) {
-                throw new IOException(""Socket is null!"");
-            }
-            if (sockKey.isReadable()) {
-                int rc = sock.read(incomingBuffer);
-                if (rc < 0) {
-                    throw new IOException(""Read error rc = "" + rc + "" ""
-                            + incomingBuffer);
-                }
-                if (incomingBuffer.remaining() == 0) {
-                    incomingBuffer.flip();
-                    if (incomingBuffer == lenBuffer) {
-                        readLength();
-                    } else if (!initialized) {
-                        readConnectResult();
-                        enableRead();
-                        if (outgoingQueue.size() > 0) {
-                            enableWrite();
-                        }
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                        packetReceived = true;
-                        initialized = true;
-                    } else {
-                        readResponse();
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                        packetReceived = true;
-                    }
-                }
-            }
-            if (sockKey.isWritable()) {
-                synchronized (outgoingQueue) {
-                    if (outgoingQueue.size() > 0) {
-                        int rc = sock.write(outgoingQueue.getFirst().bb);
-                        if (outgoingQueue.getFirst().bb.remaining() == 0) {
-                            Packet p = outgoingQueue.removeFirst();
-                            if (p.header != null
-                                    && p.header.getType() != OpCode.ping
-                                    && p.header.getType() != OpCode.auth) {
-                                pendingQueue.add(p);
-                            }
-                        }
-                    }
-                }
-            }
-            if (outgoingQueue.size() == 0) {
-                disableWrite();
-            } else {
-                enableWrite();
-            }
-            return packetReceived;
-        }
-
-        synchronized private void enableWrite() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_WRITE) == 0) {
-                sockKey.interestOps(i | SelectionKey.OP_WRITE);
-            }
-        }
-
-        synchronized private void disableWrite() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_WRITE) != 0) {
-                sockKey.interestOps(i & (~SelectionKey.OP_WRITE));
-            }
-        }
-
-        synchronized private void enableRead() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_READ) == 0) {
-                sockKey.interestOps(i | SelectionKey.OP_READ);
-            }
-        }
-
-        synchronized private void disableRead() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_READ) != 0) {
-                sockKey.interestOps(i & (~SelectionKey.OP_READ));
-            }
-        }
-
-        SendThread() {
-            super(""SendThread"");
-            zooKeeper.state = States.CONNECTING;
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
-            setDaemon(true);
-        }
-
-        private void primeConnection(SelectionKey k) throws IOException {
-            LOG.info(""Priming connection to ""
-                    + ((SocketChannel) sockKey.channel()));
-            lastConnectIndex = currentConnectIndex;
-            ConnectRequest conReq = new ConnectRequest(0, lastZxid,
-                    sessionTimeout, sessionId, sessionPasswd);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
-            boa.writeInt(-1, ""len"");
-            conReq.serialize(boa, ""connect"");
-            baos.close();
-            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
-            bb.putInt(bb.capacity() - 4);
-            bb.rewind();
-            synchronized (outgoingQueue) {
-                for (AuthData id : authInfo) {
-                    outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
-                            OpCode.auth), null, new AuthPacket(0, id.scheme,
-                            id.data), null, null));
-                }
-                outgoingQueue
-                        .addFirst((new Packet(null, null, null, null, bb)));
-            }
-            synchronized (this) {
-                k.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
-            }
-        }
-
-        private void sendPing() {
-            RequestHeader h = new RequestHeader(-2, OpCode.ping);
-            queuePacket(h, null, null, null, null, null, null);
-        }
-
-        int lastConnectIndex = -1;
-
-        int currentConnectIndex;
-
-        Random r = new Random(System.nanoTime());
-
-        private void startConnect() throws IOException {
-            if (lastConnectIndex == -1) {
-                // We don't want to delay the first try at a connect, so we
-                // start with -1 the first time around
-                lastConnectIndex = 0;
-            } else {
-                try {
-                    Thread.sleep(r.nextInt(1000));
-                } catch (InterruptedException e1) {
-                    LOG.warn(""Unexpected exception"", e1);
-                }
-                if (nextAddrToTry == lastConnectIndex) {
-                    try {
-                        // Try not to spin too fast!
-                        Thread.sleep(1000);
-                    } catch (InterruptedException e) {
-                        LOG.warn(""Unexpected exception"", e);
-                    }
-                }
-            }
-            zooKeeper.state = States.CONNECTING;
-            currentConnectIndex = nextAddrToTry;
-            InetSocketAddress addr = serverAddrs.get(nextAddrToTry);
-            nextAddrToTry++;
-            if (nextAddrToTry == serverAddrs.size()) {
-                nextAddrToTry = 0;
-            }
-            SocketChannel sock;
-            sock = SocketChannel.open();
-            sock.configureBlocking(false);
-            sock.socket().setSoLinger(false, -1);
-            sock.socket().setTcpNoDelay(true);
-            LOG.info(""Attempting connection to server "" + addr);
-            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-            if (sock.connect(addr)) {
-                primeConnection(sockKey);
-            }
-            initialized = false;
-        }
-
-        @Override
-        public void run() {
-            long now = System.currentTimeMillis();
-            long lastHeard = now;
-            long lastSend = now;
-            while (zooKeeper.state.isAlive()) {
-                try {
-                    if (sockKey == null) {
-                        startConnect();
-                        lastSend = now;
-                        lastHeard = now;
-                    }
-                    int idleRecv = (int) (now - lastHeard);
-                    int idleSend = (int) (now - lastSend);
-                    int to = readTimeout - idleRecv;
-                    if (zooKeeper.state != States.CONNECTED) {
-                        to = connectTimeout - idleRecv;
-                    }
-                    if (to <= 0) {
-                        throw new IOException(""TIMED OUT"");
-                    }
-                    if (zooKeeper.state == States.CONNECTED) {
-                        int timeToNextPing = readTimeout/2 - idleSend;
-                        if (timeToNextPing <= 0) {
-                            sendPing();
-                            lastSend = now;
-                            enableWrite();
-                        } else {
-                            if (timeToNextPing < to) {
-                                to = timeToNextPing;
-                            }
-                        }
-                    }
-
-                    selector.select(to);
-                    Set<SelectionKey> selected;
-                    synchronized (this) {
-                        selected = selector.selectedKeys();
-                    }
-                    // Everything below and until we get back to the select is
-                    // non blocking, so time is effectively a constant. That is
-                    // Why we just have to do this once, here
-                    now = System.currentTimeMillis();
-                    for (SelectionKey k : selected) {
-                        SocketChannel sc = ((SocketChannel) k.channel());
-                        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
-                            if (sc.finishConnect()) {
-                                zooKeeper.state = States.CONNECTED;
-                                lastHeard = now;
-                                lastSend = now;
-                                primeConnection(k);
-                                LOG.info(""Server connection successful"");
-                            }
-                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
-                            if (outgoingQueue.size() > 0) {
-                                // We have something to send so it's the same
-                                // as if we do the send now.
-                                lastSend = now;
-                            }
-                            if (doIO()) {
-                                lastHeard = now;
-                            }
-                        }
-                    }
-                    if (zooKeeper.state == States.CONNECTED) {
-                        if (outgoingQueue.size() > 0) {
-                            enableWrite();
-                        } else {
-                            disableWrite();
-                        }
-                    }
-                    selected.clear();
-                } catch (Exception e) {
-                    LOG.warn(""Closing: "", e);
-                    cleanup();
-                    if (zooKeeper.state.isAlive()) {
-                        waitingEvents.add(new WatcherEvent(Event.EventNone,
-                                Event.KeeperStateDisconnected, null));
-                    }
-
-                    now = System.currentTimeMillis();
-                    lastHeard = now;
-                    lastSend = now;
-                }
-            }
-            cleanup();
-            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""SendThread exitedloop."");
-        }
-
-        private void cleanup() {
-            if (sockKey != null) {
-                SocketChannel sock = (SocketChannel) sockKey.channel();
-                sockKey.cancel();
-                try {
-                    sock.socket().shutdownInput();
-                } catch (IOException e2) {
-                }
-                try {
-                    sock.socket().shutdownOutput();
-                } catch (IOException e2) {
-                }
-                try {
-                    sock.socket().close();
-                } catch (IOException e1) {
-                }
-                try {
-                    sock.close();
-                } catch (IOException e1) {
-                }
-            }
-            try {
-                Thread.sleep(100);
-            } catch (InterruptedException e1) {
-                e1.printStackTrace();
-            }
-            sockKey = null;
-            synchronized (pendingQueue) {
-                for (Packet p : pendingQueue) {
-                    conLossPacket(p);
-                }
-                pendingQueue.clear();
-            }
-            synchronized (outgoingQueue) {
-                for (Packet p : outgoingQueue) {
-                    conLossPacket(p);
-                }
-                outgoingQueue.clear();
-            }
-        }
-
-        public void close() {
-            zooKeeper.state = States.CLOSED;
-            synchronized (this) {
-                selector.wakeup();
-            }
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    public void close() throws IOException {
-        long traceMask = ZooTrace.SESSION_TRACE_MASK;
-        if (ZooTrace.isTraceEnabled(LOG, traceMask)) {
-            ZooTrace.logTraceMessage(LOG, traceMask,
-                    ""Close ClientCnxn for session: "" + sessionId + ""!"");
-        }
-        sendThread.close();
-        waitingEvents.add(eventOfDeath);
-    }
-
-    private int xid = 1;
-
-    synchronized private int getXid() {
-        return xid++;
-    }
-
-    public ReplyHeader submitRequest(RequestHeader h, Record request,
-            Record response) throws InterruptedException {
-        ReplyHeader r = new ReplyHeader();
-        Packet packet = queuePacket(h, r, request, response, null, null, null);
-        synchronized (packet) {
-            while (!packet.finished) {
-                packet.wait();
-            }
-        }
-        return r;
-    }
-
-    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
-            Record response, AsyncCallback cb, String path, Object ctx) {
-        Packet packet = null;
-        synchronized (outgoingQueue) {
-            if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
-                h.setXid(getXid());
-            }
-            packet = new Packet(h, r, request, response, null);
-            packet.cb = cb;
-            packet.ctx = ctx;
-            packet.path = path;
-            if (!zooKeeper.state.isAlive()) {
-                conLossPacket(packet);
-            } else {
-                outgoingQueue.add(packet);
-            }
-        }
-        synchronized (sendThread) {
-            selector.wakeup();
-        }
-        return packet;
-    }
-
-    public void addAuthInfo(String scheme, byte auth[]) {
-        authInfo.add(new AuthData(scheme, auth));
-        if (zooKeeper.state == States.CONNECTED) {
-            queuePacket(new RequestHeader(-4, OpCode.auth), null,
-                    new AuthPacket(0, scheme, auth), null, null, null, null);
-        }
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
+import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
+import com.yahoo.zookeeper.AsyncCallback.DataCallback;
+import com.yahoo.zookeeper.AsyncCallback.StatCallback;
+import com.yahoo.zookeeper.AsyncCallback.StringCallback;
+import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
+import com.yahoo.zookeeper.Watcher.Event;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.ZooKeeper.States;
+import com.yahoo.zookeeper.proto.AuthPacket;
+import com.yahoo.zookeeper.proto.ConnectRequest;
+import com.yahoo.zookeeper.proto.ConnectResponse;
+import com.yahoo.zookeeper.proto.CreateResponse;
+import com.yahoo.zookeeper.proto.ExistsResponse;
+import com.yahoo.zookeeper.proto.GetACLResponse;
+import com.yahoo.zookeeper.proto.GetChildrenResponse;
+import com.yahoo.zookeeper.proto.GetDataResponse;
+import com.yahoo.zookeeper.proto.ReplyHeader;
+import com.yahoo.zookeeper.proto.RequestHeader;
+import com.yahoo.zookeeper.proto.SetACLResponse;
+import com.yahoo.zookeeper.proto.SetDataResponse;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.ByteBufferInputStream;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooTrace;
+
+/**
+ * This class manages the socket i/o for the client. ClientCnxn maintains a list
+ * of available servers to connect to and ""transparently"" switches servers it is
+ * connected to as needed.
+ *
+ */
+class ClientCnxn {
+    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
+
+    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
+
+    static class AuthData {
+        AuthData(String scheme, byte data[]) {
+            this.scheme = scheme;
+            this.data = data;
+        }
+
+        String scheme;
+
+        byte data[];
+    }
+
+    private ArrayList<AuthData> authInfo = new ArrayList<AuthData>();
+
+    /**
+     * These are the packets that have been sent and are waiting for a response.
+     */
+    private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
+
+    private LinkedBlockingQueue waitingEvents = new LinkedBlockingQueue();
+
+    /**
+     * These are the packets that need to be sent.
+     */
+    private LinkedList<Packet> outgoingQueue = new LinkedList<Packet>();
+
+    private int nextAddrToTry = 0;
+
+    private int connectTimeout;
+
+    private int readTimeout;
+
+    private final int sessionTimeout;
+
+    private final ZooKeeper zooKeeper;
+
+    private long sessionId;
+
+    private byte sessionPasswd[] = new byte[16];
+
+    final SendThread sendThread;
+
+    final EventThread eventThread;
+
+    final Selector selector = Selector.open();
+
+    public long getSessionId() {
+        return sessionId;
+    }
+
+    public byte[] getSessionPasswd() {
+        return sessionPasswd;
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(""sessionId: "").append(sessionId).append(""\n"");
+        sb.append(""lastZxid: "").append(lastZxid).append(""\n"");
+        sb.append(""xid: "").append(xid).append(""\n"");
+        sb.append(""nextAddrToTry: "").append(nextAddrToTry).append(""\n"");
+        sb.append(""serverAddrs: "").append(serverAddrs.get(nextAddrToTry))
+                .append(""\n"");
+        return sb.toString();
+    }
+
+    /**
+     * This class allows us to pass the headers and the relevant records around.
+     */
+    static class Packet {
+        RequestHeader header;
+
+        ByteBuffer bb;
+
+        String path;
+
+        ReplyHeader replyHeader;
+
+        Record request;
+
+        Record response;
+
+        boolean finished;
+
+        AsyncCallback cb;
+
+        Object ctx;
+
+        Packet(RequestHeader header, ReplyHeader replyHeader, Record record,
+                Record response, ByteBuffer bb) {
+            this.header = header;
+            this.replyHeader = replyHeader;
+            this.request = record;
+            this.response = response;
+            if (bb != null) {
+                this.bb = bb;
+            } else {
+                try {
+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                    BinaryOutputArchive boa = BinaryOutputArchive
+                            .getArchive(baos);
+                    boa.writeInt(-1, ""len""); // We'll fill this in later
+                    header.serialize(boa, ""header"");
+                    if (record != null) {
+                        record.serialize(boa, ""request"");
+                    }
+                    baos.close();
+                    this.bb = ByteBuffer.wrap(baos.toByteArray());
+                    this.bb.putInt(this.bb.capacity() - 4);
+                    this.bb.rewind();
+                } catch (IOException e) {
+                    LOG.warn(""Unexpected exception"",e);
+                }
+            }
+        }
+    }
+
+    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper)
+            throws IOException {
+        this(hosts, sessionTimeout, zooKeeper, 0, new byte[16]);
+    }
+
+    /**
+     * Creates a connection object. The actual network connect doesn't get
+     * established until needed.
+     *
+     * @param hosts
+     *                a comma separated list of hosts that can be connected to.
+     * @param sessionTimeout
+     *                the timeout for connections.
+     * @param zooKeeper
+     *                the zookeeper object that this connection is related to.
+     * @throws KeeperException
+     * @throws IOException
+     */
+    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
+            long sessionId, byte[] sessionPasswd) throws IOException {
+        this.zooKeeper = zooKeeper;
+        this.sessionId = sessionId;
+        this.sessionPasswd = sessionPasswd;
+        String hostsList[] = hosts.split("","");
+        for (String host : hostsList) {
+            int port = 2181;
+            String parts[] = host.split("":"");
+            if (parts.length > 1) {
+                port = Integer.parseInt(parts[1]);
+                host = parts[0];
+            }
+            InetAddress addrs[] = InetAddress.getAllByName(host);
+            for (InetAddress addr : addrs) {
+                serverAddrs.add(new InetSocketAddress(addr, port));
+            }
+        }
+        this.sessionTimeout = sessionTimeout;
+        connectTimeout = sessionTimeout / hostsList.length;
+        readTimeout = sessionTimeout * 2 / 3;
+        Collections.shuffle(serverAddrs);
+        sendThread = new SendThread();
+        sendThread.start();
+        eventThread = new EventThread();
+        eventThread.start();
+    }
+
+    WatcherEvent eventOfDeath = new WatcherEvent();
+
+    final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
+        public void uncaughtException(Thread t, Throwable e) {
+            LOG.error(""from "" + t.getName(), e);
+        }
+    };
+
+    class EventThread extends Thread {
+        EventThread() {
+            super(""EventThread"");
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
+            setDaemon(true);
+        }
+
+        public void run() {
+            try {
+                while (true) {
+                    Object event = waitingEvents.take();
+                    if (event == eventOfDeath) {
+                        break;
+                    }
+                    if (event instanceof WatcherEvent) {
+                        zooKeeper.watcher.process((WatcherEvent) event);
+                    } else {
+                        Packet p = (Packet) event;
+                        int rc = 0;
+                        String path = p.path;
+                        if (p.replyHeader.getErr() != 0) {
+                            rc = p.replyHeader.getErr();
+                        }
+                        if (p.cb == null) {
+                            LOG.warn(""Somehow a null cb got to EventThread!"");
+                        } else if (p.response instanceof ExistsResponse
+                                || p.response instanceof SetDataResponse
+                                || p.response instanceof SetACLResponse) {
+                            StatCallback cb = (StatCallback) p.cb;
+                            if (rc == 0) {
+                                if (p.response instanceof ExistsResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((ExistsResponse) p.response)
+                                                    .getStat());
+                                } else if (p.response instanceof SetDataResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((SetDataResponse) p.response)
+                                                    .getStat());
+                                } else if (p.response instanceof SetACLResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((SetACLResponse) p.response)
+                                                    .getStat());
+                                }
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.response instanceof GetDataResponse) {
+                            DataCallback cb = (DataCallback) p.cb;
+                            GetDataResponse rsp = (GetDataResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx,
+                                        rsp.getData(), rsp.getStat());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null, null);
+                            }
+                        } else if (p.response instanceof GetACLResponse) {
+                            ACLCallback cb = (ACLCallback) p.cb;
+                            GetACLResponse rsp = (GetACLResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx, rsp.getAcl(),
+                                        rsp.getStat());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null, null);
+                            }
+                        } else if (p.response instanceof GetChildrenResponse) {
+                            ChildrenCallback cb = (ChildrenCallback) p.cb;
+                            GetChildrenResponse rsp = (GetChildrenResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx, rsp
+                                        .getChildren());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.response instanceof CreateResponse) {
+                            StringCallback cb = (StringCallback) p.cb;
+                            CreateResponse rsp = (CreateResponse) p.response;
+                            if (rc == 0) {
+                                cb
+                                        .processResult(rc, path, p.ctx, rsp
+                                                .getPath());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.cb instanceof VoidCallback) {
+                            VoidCallback cb = (VoidCallback) p.cb;
+                            cb.processResult(rc, path, p.ctx);
+                        }
+                    }
+                }
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private void finishPacket(Packet p) {
+        p.finished = true;
+        if (p.cb == null) {
+            synchronized (p) {
+                p.notifyAll();
+            }
+        } else {
+            waitingEvents.add(p);
+        }
+    }
+
+    private void conLossPacket(Packet p) {
+        if (p.replyHeader == null) {
+            return;
+        }
+        switch(zooKeeper.state) {
+        case AUTH_FAILED:
+            p.replyHeader.setErr(KeeperException.Code.AuthFailed);
+            break;
+        case CLOSED:
+            p.replyHeader.setErr(KeeperException.Code.SessionExpired);
+            break;
+        default:
+            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
+        }
+        finishPacket(p);
+    }
+
+    long lastZxid;
+
+    /**
+     * This class services the outgoing request queue and generates the heart
+     * beats. It also spawns the ReadThread.
+     */
+    class SendThread extends Thread {
+        SelectionKey sockKey;
+
+        ByteBuffer lenBuffer = ByteBuffer.allocateDirect(4);
+
+        ByteBuffer incomingBuffer = lenBuffer;
+
+        boolean initialized;
+
+        void readLength() throws IOException {
+            int len = incomingBuffer.getInt();
+            if (len < 0 || len >= 4096 * 1024) {
+                throw new IOException(""Packet len"" + len + "" is out of range!"");
+            }
+            incomingBuffer = ByteBuffer.allocate(len);
+        }
+
+        void readConnectResult() throws IOException {
+            ByteBufferInputStream bbis = new ByteBufferInputStream(
+                    incomingBuffer);
+            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
+            ConnectResponse conRsp = new ConnectResponse();
+            conRsp.deserialize(bbia, ""connect"");
+            int sessionTimeout = conRsp.getTimeOut();
+            if (sessionTimeout <= 0) {
+                zooKeeper.state = States.CLOSED;
+                waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+                        Watcher.Event.KeeperStateExpired, null));
+                throw new IOException(""Session Expired"");
+            }
+            readTimeout = sessionTimeout * 2 / 3;
+            connectTimeout = sessionTimeout / serverAddrs.size();
+            sessionId = conRsp.getSessionId();
+            sessionPasswd = conRsp.getPasswd();
+            waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+                    Watcher.Event.KeeperStateSyncConnected, null));
+        }
+
+        @SuppressWarnings(""unchecked"")
+        void readResponse() throws IOException {
+            ByteBufferInputStream bbis = new ByteBufferInputStream(
+                    incomingBuffer);
+            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
+            ReplyHeader r = new ReplyHeader();
+
+            r.deserialize(bbia, ""header"");
+            if (r.getXid() == -2) {
+                // -2 is the xid for pings
+                return;
+            }
+            if (r.getXid() == -4) {
+                // -2 is the xid for AuthPacket
+                // TODO: process AuthPacket here
+                return;
+            }
+            if (r.getXid() == -1) {
+                // -1 means notification
+                WatcherEvent event = new WatcherEvent();
+                event.deserialize(bbia, ""response"");
+                // System.out.println(""Got an event: "" + event + "" for "" +
+                // sessionId + "" through"" + _cnxn);
+                waitingEvents.add(event);
+                return;
+            }
+            if (pendingQueue.size() == 0) {
+                throw new IOException(""Nothing in the queue, but got ""
+                        + r.getXid());
+            }
+            Packet p = null;
+            synchronized (pendingQueue) {
+                p = pendingQueue.remove();
+            }
+            /*
+             * Since requests are processed in order, we better get a response
+             * to the first request!
+             */
+            if (p.header.getXid() != r.getXid()) {
+                throw new IOException(""Xid out of order. Got "" + r.getXid()
+                        + "" expected "" + p.header.getXid());
+            }
+            p.replyHeader.setXid(r.getXid());
+            p.replyHeader.setErr(r.getErr());
+            p.replyHeader.setZxid(r.getZxid());
+            lastZxid = r.getZxid();
+            if (p.response != null && r.getErr() == 0) {
+                p.response.deserialize(bbia, ""response"");
+            }
+            p.finished = true;
+            finishPacket(p);
+        }
+
+        /**
+         * @return true if a packet was received
+         * @throws InterruptedException
+         * @throws IOException
+         */
+        boolean doIO() throws InterruptedException, IOException {
+            boolean packetReceived = false;
+            SocketChannel sock = (SocketChannel) sockKey.channel();
+            if (sock == null) {
+                throw new IOException(""Socket is null!"");
+            }
+            if (sockKey.isReadable()) {
+                int rc = sock.read(incomingBuffer);
+                if (rc < 0) {
+                    throw new IOException(""Read error rc = "" + rc + "" ""
+                            + incomingBuffer);
+                }
+                if (incomingBuffer.remaining() == 0) {
+                    incomingBuffer.flip();
+                    if (incomingBuffer == lenBuffer) {
+                        readLength();
+                    } else if (!initialized) {
+                        readConnectResult();
+                        enableRead();
+                        if (outgoingQueue.size() > 0) {
+                            enableWrite();
+                        }
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                        packetReceived = true;
+                        initialized = true;
+                    } else {
+                        readResponse();
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                        packetReceived = true;
+                    }
+                }
+            }
+            if (sockKey.isWritable()) {
+                synchronized (outgoingQueue) {
+                    if (outgoingQueue.size() > 0) {
+                        int rc = sock.write(outgoingQueue.getFirst().bb);
+                        if (outgoingQueue.getFirst().bb.remaining() == 0) {
+                            Packet p = outgoingQueue.removeFirst();
+                            if (p.header != null
+                                    && p.header.getType() != OpCode.ping
+                                    && p.header.getType() != OpCode.auth) {
+                                pendingQueue.add(p);
+                            }
+                        }
+                    }
+                }
+            }
+            if (outgoingQueue.size() == 0) {
+                disableWrite();
+            } else {
+                enableWrite();
+            }
+            return packetReceived;
+        }
+
+        synchronized private void enableWrite() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_WRITE) == 0) {
+                sockKey.interestOps(i | SelectionKey.OP_WRITE);
+            }
+        }
+
+        synchronized private void disableWrite() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_WRITE) != 0) {
+                sockKey.interestOps(i & (~SelectionKey.OP_WRITE));
+            }
+        }
+
+        synchronized private void enableRead() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_READ) == 0) {
+                sockKey.interestOps(i | SelectionKey.OP_READ);
+            }
+        }
+
+        synchronized private void disableRead() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_READ) != 0) {
+                sockKey.interestOps(i & (~SelectionKey.OP_READ));
+            }
+        }
+
+        SendThread() {
+            super(""SendThread"");
+            zooKeeper.state = States.CONNECTING;
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
+            setDaemon(true);
+        }
+
+        private void primeConnection(SelectionKey k) throws IOException {
+            LOG.info(""Priming connection to ""
+                    + ((SocketChannel) sockKey.channel()));
+            lastConnectIndex = currentConnectIndex;
+            ConnectRequest conReq = new ConnectRequest(0, lastZxid,
+                    sessionTimeout, sessionId, sessionPasswd);
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+            boa.writeInt(-1, ""len"");
+            conReq.serialize(boa, ""connect"");
+            baos.close();
+            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
+            bb.putInt(bb.capacity() - 4);
+            bb.rewind();
+            synchronized (outgoingQueue) {
+                for (AuthData id : authInfo) {
+                    outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
+                            OpCode.auth), null, new AuthPacket(0, id.scheme,
+                            id.data), null, null));
+                }
+                outgoingQueue
+                        .addFirst((new Packet(null, null, null, null, bb)));
+            }
+            synchronized (this) {
+                k.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
+            }
+        }
+
+        private void sendPing() {
+            RequestHeader h = new RequestHeader(-2, OpCode.ping);
+            queuePacket(h, null, null, null, null, null, null);
+        }
+
+        int lastConnectIndex = -1;
+
+        int currentConnectIndex;
+
+        Random r = new Random(System.nanoTime());
+
+        private void startConnect() throws IOException {
+            if (lastConnectIndex == -1) {
+                // We don't want to delay the first try at a connect, so we
+                // start with -1 the first time around
+                lastConnectIndex = 0;
+            } else {
+                try {
+                    Thread.sleep(r.nextInt(1000));
+                } catch (InterruptedException e1) {
+                    LOG.warn(""Unexpected exception"", e1);
+                }
+                if (nextAddrToTry == lastConnectIndex) {
+                    try {
+                        // Try not to spin too fast!
+                        Thread.sleep(1000);
+                    } catch (InterruptedException e) {
+                        LOG.warn(""Unexpected exception"", e);
+                    }
+                }
+            }
+            zooKeeper.state = States.CONNECTING;
+            currentConnectIndex = nextAddrToTry;
+            InetSocketAddress addr = serverAddrs.get(nextAddrToTry);
+            nextAddrToTry++;
+            if (nextAddrToTry == serverAddrs.size()) {
+                nextAddrToTry = 0;
+            }
+            SocketChannel sock;
+            sock = SocketChannel.open();
+            sock.configureBlocking(false);
+            sock.socket().setSoLinger(false, -1);
+            sock.socket().setTcpNoDelay(true);
+            LOG.info(""Attempting connection to server "" + addr);
+            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
+            if (sock.connect(addr)) {
+                primeConnection(sockKey);
+            }
+            initialized = false;
+        }
+
+        @Override
+        public void run() {
+            long now = System.currentTimeMillis();
+            long lastHeard = now;
+            long lastSend = now;
+            while (zooKeeper.state.isAlive()) {
+                try {
+                    if (sockKey == null) {
+                        startConnect();
+                        lastSend = now;
+                        lastHeard = now;
+                    }
+                    int idleRecv = (int) (now - lastHeard);
+                    int idleSend = (int) (now - lastSend);
+                    int to = readTimeout - idleRecv;
+                    if (zooKeeper.state != States.CONNECTED) {
+                        to = connectTimeout - idleRecv;
+                    }
+                    if (to <= 0) {
+                        throw new IOException(""TIMED OUT"");
+                    }
+                    if (zooKeeper.state == States.CONNECTED) {
+                        int timeToNextPing = readTimeout/2 - idleSend;
+                        if (timeToNextPing <= 0) {
+                            sendPing();
+                            lastSend = now;
+                            enableWrite();
+                        } else {
+                            if (timeToNextPing < to) {
+                                to = timeToNextPing;
+                            }
+                        }
+                    }
+
+                    selector.select(to);
+                    Set<SelectionKey> selected;
+                    synchronized (this) {
+                        selected = selector.selectedKeys();
+                    }
+                    // Everything below and until we get back to the select is
+                    // non blocking, so time is effectively a constant. That is
+                    // Why we just have to do this once, here
+                    now = System.currentTimeMillis();
+                    for (SelectionKey k : selected) {
+                        SocketChannel sc = ((SocketChannel) k.channel());
+                        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
+                            if (sc.finishConnect()) {
+                                zooKeeper.state = States.CONNECTED;
+                                lastHeard = now;
+                                lastSend = now;
+                                primeConnection(k);
+                                LOG.info(""Server connection successful"");
+                            }
+                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
+                            if (outgoingQueue.size() > 0) {
+                                // We have something to send so it's the same
+                                // as if we do the send now.
+                                lastSend = now;
+                            }
+                            if (doIO()) {
+                                lastHeard = now;
+                            }
+                        }
+                    }
+                    if (zooKeeper.state == States.CONNECTED) {
+                        if (outgoingQueue.size() > 0) {
+                            enableWrite();
+                        } else {
+                            disableWrite();
+                        }
+                    }
+                    selected.clear();
+                } catch (Exception e) {
+                    LOG.warn(""Closing: "", e);
+                    cleanup();
+                    if (zooKeeper.state.isAlive()) {
+                        waitingEvents.add(new WatcherEvent(Event.EventNone,
+                                Event.KeeperStateDisconnected, null));
+                    }
+
+                    now = System.currentTimeMillis();
+                    lastHeard = now;
+                    lastSend = now;
+                }
+            }
+            cleanup();
+            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""SendThread exitedloop."");
+        }
+
+        private void cleanup() {
+            if (sockKey != null) {
+                SocketChannel sock = (SocketChannel) sockKey.channel();
+                sockKey.cancel();
+                try {
+                    sock.socket().shutdownInput();
+                } catch (IOException e2) {
+                }
+                try {
+                    sock.socket().shutdownOutput();
+                } catch (IOException e2) {
+                }
+                try {
+                    sock.socket().close();
+                } catch (IOException e1) {
+                }
+                try {
+                    sock.close();
+                } catch (IOException e1) {
+                }
+            }
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e1) {
+                e1.printStackTrace();
+            }
+            sockKey = null;
+            synchronized (pendingQueue) {
+                for (Packet p : pendingQueue) {
+                    conLossPacket(p);
+                }
+                pendingQueue.clear();
+            }
+            synchronized (outgoingQueue) {
+                for (Packet p : outgoingQueue) {
+                    conLossPacket(p);
+                }
+                outgoingQueue.clear();
+            }
+        }
+
+        public void close() {
+            zooKeeper.state = States.CLOSED;
+            synchronized (this) {
+                selector.wakeup();
+            }
+        }
+    }
+
+    @SuppressWarnings(""unchecked"")
+    public void close() throws IOException {
+        long traceMask = ZooTrace.SESSION_TRACE_MASK;
+        if (ZooTrace.isTraceEnabled(LOG, traceMask)) {
+            ZooTrace.logTraceMessage(LOG, traceMask,
+                    ""Close ClientCnxn for session: "" + sessionId + ""!"");
+        }
+        sendThread.close();
+        waitingEvents.add(eventOfDeath);
+    }
+
+    private int xid = 1;
+
+    synchronized private int getXid() {
+        return xid++;
+    }
+
+    public ReplyHeader submitRequest(RequestHeader h, Record request,
+            Record response) throws InterruptedException {
+        ReplyHeader r = new ReplyHeader();
+        Packet packet = queuePacket(h, r, request, response, null, null, null);
+        synchronized (packet) {
+            while (!packet.finished) {
+                packet.wait();
+            }
+        }
+        return r;
+    }
+
+    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
+            Record response, AsyncCallback cb, String path, Object ctx) {
+        Packet packet = null;
+        synchronized (outgoingQueue) {
+            if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
+                h.setXid(getXid());
+            }
+            packet = new Packet(h, r, request, response, null);
+            packet.cb = cb;
+            packet.ctx = ctx;
+            packet.path = path;
+            if (!zooKeeper.state.isAlive()) {
+                conLossPacket(packet);
+            } else {
+                outgoingQueue.add(packet);
+            }
+        }
+        synchronized (sendThread) {
+            selector.wakeup();
+        }
+        return packet;
+    }
+
+    public void addAuthInfo(String scheme, byte auth[]) {
+        authInfo.add(new AuthData(scheme, auth));
+        if (zooKeeper.state == States.CONNECTED) {
+            queuePacket(new RequestHeader(-4, OpCode.auth), null,
+                    new AuthPacket(0, scheme, auth), null, null, null, null);
+        }
+    }
+}
",,6461
2258,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/NIOServerCnxn.java,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,696,,,,,,,,"        sock = null;",,,6461
2259,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/SyncRequestProcessor.java,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,192,,,,,,,,"                                logStream = null;",,,6461
2260,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/SyncRequestProcessor.java,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,193,,,,,,,,"                                logArchive = null;",,,6461
2261,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/CommitProcessor.java,e1e8bffbc2f3bcb28cd59b4a54568c26cf92cc8e,1210382051,98,,,,,,,,"                            nextPending = null;",,,6461
2262,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,5347de99d0d1fdd1d41ffb02e69931eda5fa2342,1210628199,543,,,,,,,,"                        recvWorker = null;",,,6461
2263,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ClientCnxn.java,ffce83512370e970426f7f6b7cff8f519de59bd4,1210633285,758,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,767,,,,,"            sockKey = null;",,,6461
2264,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,f1dd874ed7ddd42f006600319dd5e896ed8ac349,1212508278,91,,,,,,,,"            svrBean=null;",,,6461
2265,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,f1dd874ed7ddd42f006600319dd5e896ed8ac349,1212508278,98,,,,,,,,"            leBean=null;",,,6461
2266,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,f1dd874ed7ddd42f006600319dd5e896ed8ac349,1212508278,114,,,,,,,,"            svrBean=null;",,,6461
2267,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,f1dd874ed7ddd42f006600319dd5e896ed8ac349,1212508278,121,,,,,,,,"            leBean=null;",,,6461
2268,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,f1dd874ed7ddd42f006600319dd5e896ed8ac349,1212508278,180,,,,,,,,"            dataTreeBean=null;",,,6461
2269,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,526,,,,,,,,"        return exists(path, watch ? defaultWatcher : null);",,,6461
2270,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,559,,,,,,,,"        exists(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2271,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,622,,,,,,,,"        return getData(path, watch ? defaultWatcher : null, stat);",,,6461
2272,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,653,,,,,,,,"        getData(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2273,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,876,,,,,,,,"        return getChildren(path, watch ? defaultWatcher : null);",,,6461
2274,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,909,,,,,,,,"        getChildren(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2275,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/zookeeper/test/com/yahoo/zookeeper/test/ClientTest.java,23e39b5a8797d2be1b1ed0420d67f26983887c84,1212778917,40,,,,,,,,"        clientConnected = null;",,,6461
2276,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,91,,,,,,,,"            svrBean=null;",,,6461
2277,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,98,,,,,,,,"            leBean=null;",,,6461
2278,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,114,,,,,,,,"            svrBean=null;",,,6461
2279,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,121,,,,,,,,"            leBean=null;",,,6461
2280,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,180,,,,,,,,"            dataTreeBean=null;",,,6461
2281,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/jute/compiler/generated/RccTokenManager.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,722,,,,,,,,"   image = null;",,,6461
2282,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/jute/compiler/generated/SimpleCharStream.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,404,,,,,,,,"     buffer = null;",,,6461
2283,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/jute/compiler/generated/SimpleCharStream.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,405,,,,,,,,"     bufline = null;",,,6461
2284,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/jute/compiler/generated/SimpleCharStream.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,406,,,,,,,,"     bufcolumn = null;",,,6461
2285,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/ClientCnxn.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,767,,,,,,,,"            sockKey = null;",,,6461
2286,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,526,,,,,,,,"        return exists(path, watch ? defaultWatcher : null);",,,6461
2287,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,559,,,,,,,,"        exists(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2288,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,622,,,,,,,,"        return getData(path, watch ? defaultWatcher : null, stat);",,,6461
2289,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,653,,,,,,,,"        getData(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2290,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,876,,,,,,,,"        return getChildren(path, watch ? defaultWatcher : null);",,,6461
2291,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,909,,,,,,,,"        getChildren(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2292,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/DataTree.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,220,,,,,,,,"            node.parent = null;",,,6461
2293,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/DataTree.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,554,,,,,,,,"        root = null;",,,6461
2294,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/NIOServerCnxn.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,696,,,,,,,,"        sock = null;",,,6461
2295,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/ServerStats.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,43,,,,,,,,"        instance=null;",,,6461
2296,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/SyncRequestProcessor.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,192,,,,,,,,"                                logStream = null;",,,6461
2297,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/SyncRequestProcessor.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,193,,,,,,,,"                                logArchive = null;",,,6461
2298,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/CommitProcessor.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,98,,,,,,,,"                            nextPending = null;",,,6461
2299,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,493,,,,,,,,"            recvWorker = null;",,,6461
2300,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,543,,,,,,,,"                        recvWorker = null;",,,6461
2301,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/test/com/yahoo/zookeeper/test/AsyncTest.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,58,,,,,,,,"        clientConnected=null;",,,6461
2302,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/test/com/yahoo/zookeeper/test/ClientTest.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,40,,,,,,,,"        clientConnected = null;",,,6461
2303,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/test/com/yahoo/zookeeper/test/DataTreeTest.java,083aaac1bb6f2d56f1034ca6c53e7c5cb4115c5a,1214326554,38,,,,,,,,"        dt=null;",,,6461
2304,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/jute/compiler/generated/RccTokenManager.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,722,,,,,,,,"   image = null;",,,6461
2305,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/jute/compiler/generated/SimpleCharStream.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,404,,,,,,,,"     buffer = null;",,,6461
2306,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/jute/compiler/generated/SimpleCharStream.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,405,,,,,,,,"     bufline = null;",,,6461
2307,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/jute/compiler/generated/SimpleCharStream.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,406,,,,,,,,"     bufcolumn = null;",,,6461
2308,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/ClientCnxn.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,767,,,,,,,,"            sockKey = null;",,,6461
2309,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/ZooKeeper.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,526,,,,,,,,"        return exists(path, watch ? defaultWatcher : null);",,,6461
2310,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/ZooKeeper.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,559,,,,,,,,"        exists(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2311,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/ZooKeeper.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,622,,,,,,,,"        return getData(path, watch ? defaultWatcher : null, stat);",,,6461
2312,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/ZooKeeper.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,653,,,,,,,,"        getData(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2313,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/ZooKeeper.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,876,,,,,,,,"        return getChildren(path, watch ? defaultWatcher : null);",,,6461
2314,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/ZooKeeper.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,909,,,,,,,,"        getChildren(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2315,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/DataTree.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,220,,,,,,,,"            node.parent = null;",,,6461
2316,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/DataTree.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,554,,,,,,,,"        root = null;",,,6461
2317,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/NIOServerCnxn.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,696,,,,,,,,"        sock = null;",,,6461
2318,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/ServerStats.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,43,,,,,,,,"        instance=null;",,,6461
2319,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/SyncRequestProcessor.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,192,,,,,,,,"                                logStream = null;",,,6461
2320,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/SyncRequestProcessor.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,193,,,,,,,,"                                logArchive = null;",,,6461
2321,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/quorum/CommitProcessor.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,98,,,,,,,,"                            nextPending = null;",,,6461
2322,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,493,,,,,,,,"            recvWorker = null;",,,6461
2323,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/java/main/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,03f3e5f76692d134f630be726557120ee8706212,1214326842,543,,,,,,,,"                        recvWorker = null;",,,6461
2324,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,91,,,,,,,,"            svrBean=null;",,,6461
2325,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,98,,,,,,,,"            leBean=null;",,,6461
2326,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,114,,,,,,,,"            svrBean=null;",,,6461
2327,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,121,,,,,,,,"            leBean=null;",,,6461
2328,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/yahoo/zookeeper/server/quorum/ManagedQuorumPeer.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,180,,,,,,,,"            dataTreeBean=null;",,,6461
2329,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/jute/compiler/generated/RccTokenManager.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,722,,,,,,,,"   image = null;",,,6461
2330,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/jute/compiler/generated/SimpleCharStream.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,404,,,,,,,,"     buffer = null;",,,6461
2331,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/jute/compiler/generated/SimpleCharStream.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,405,,,,,,,,"     bufline = null;",,,6461
2332,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/jute/compiler/generated/SimpleCharStream.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,406,,,,,,,,"     bufcolumn = null;",,,6461
2333,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/ClientCnxn.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,767,,,,,,,,"            sockKey = null;",,,6461
2334,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/ZooKeeper.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,526,,,,,,,,"        return exists(path, watch ? defaultWatcher : null);",,,6461
2335,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/ZooKeeper.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,559,,,,,,,,"        exists(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2336,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/ZooKeeper.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,622,,,,,,,,"        return getData(path, watch ? defaultWatcher : null, stat);",,,6461
2337,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/ZooKeeper.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,653,,,,,,,,"        getData(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2338,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/ZooKeeper.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,876,,,,,,,,"        return getChildren(path, watch ? defaultWatcher : null);",,,6461
2339,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/ZooKeeper.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,909,,,,,,,,"        getChildren(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2340,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/DataTree.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,220,,,,,,,,"            node.parent = null;",,,6461
2341,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/DataTree.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,554,,,,,,,,"        root = null;",,,6461
2342,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/NIOServerCnxn.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,696,,,,,,,,"        sock = null;",,,6461
2343,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/ServerStats.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,43,,,,,,,,"        instance=null;",,,6461
2344,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/SyncRequestProcessor.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,192,,,,,,,,"                                logStream = null;",,,6461
2345,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/SyncRequestProcessor.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,193,,,,,,,,"                                logArchive = null;",,,6461
2346,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/quorum/CommitProcessor.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,98,,,,,,,,"                            nextPending = null;",,,6461
2347,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,493,,,,,,,,"            recvWorker = null;",,,6461
2348,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/yahoo/zookeeper/server/quorum/QuorumCnxManager.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,543,,,,,,,,"                        recvWorker = null;",,,6461
2349,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/com/yahoo/zookeeper/test/AsyncTest.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,58,,,,,,,,"        clientConnected=null;",,,6461
2350,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/com/yahoo/zookeeper/test/ClientTest.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,40,,,,,,,,"        clientConnected = null;",,,6461
2351,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/com/yahoo/zookeeper/test/DataTreeTest.java,be031cb42c842f5c5362b2333b6155f4985000fc,1214327076,38,,,,,,,,"        dt=null;",,,6461
2352,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/jute/compiler/generated/RccTokenManager.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,722,,,,,,,,"   image = null;",,,6461
2353,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/jute/compiler/generated/SimpleCharStream.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,404,,,,,,,,"     buffer = null;",,,6461
2354,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/jute/compiler/generated/SimpleCharStream.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,405,,,,,,,,"     bufline = null;",,,6461
2355,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/jute/compiler/generated/SimpleCharStream.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,406,,,,,,,,"     bufcolumn = null;",,,6461
2356,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/ClientCnxn.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,767,,,,,,,,"            sockKey = null;",,,6461
2357,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/ZooKeeper.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,526,,,,,,,,"        return exists(path, watch ? defaultWatcher : null);",,,6461
2358,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/ZooKeeper.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,559,,,,,,,,"        exists(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2359,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/ZooKeeper.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,622,,,,,,,,"        return getData(path, watch ? defaultWatcher : null, stat);",,,6461
2360,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/ZooKeeper.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,653,,,,,,,,"        getData(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2361,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/ZooKeeper.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,876,,,,,,,,"        return getChildren(path, watch ? defaultWatcher : null);",,,6461
2362,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/ZooKeeper.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,909,,,,,,,,"        getChildren(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2363,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/DataTree.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,220,,,,,,,,"            node.parent = null;",,,6461
2364,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/DataTree.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,554,,,,,,,,"        root = null;",,,6461
2365,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/NIOServerCnxn.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,696,,,,,,,,"        sock = null;",,,6461
2366,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/ServerStats.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,43,,,,,,,,"        instance=null;",,,6461
2367,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/SyncRequestProcessor.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,192,,,,,,,,"                                logStream = null;",,,6461
2368,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/SyncRequestProcessor.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,193,,,,,,,,"                                logArchive = null;",,,6461
2369,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/quorum/CommitProcessor.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,98,,,,,,,,"                            nextPending = null;",,,6461
2370,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/quorum/QuorumCnxManager.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,493,,,,,,,,"            recvWorker = null;",,,6461
2371,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/com/apache/zookeeper/server/quorum/QuorumCnxManager.java,daa66b7c180c4342ce7acc7b595106fa3a49a12d,1214327620,543,,,,,,,,"                        recvWorker = null;",,,6461
2372,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/jute/compiler/generated/RccTokenManager.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,722,cfd2ecb8d049c1b51b2c1e6d5fd02edd5d3c26e8,1214331647,722,,,,,"   image = null;",,,6461
2373,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/jute/compiler/generated/SimpleCharStream.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,404,cfd2ecb8d049c1b51b2c1e6d5fd02edd5d3c26e8,1214331647,404,,,,,"     buffer = null;",,,6461
2374,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/jute/compiler/generated/SimpleCharStream.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,405,cfd2ecb8d049c1b51b2c1e6d5fd02edd5d3c26e8,1214331647,405,,,,,"     bufline = null;",,,6461
2375,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/jute/compiler/generated/SimpleCharStream.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,406,cfd2ecb8d049c1b51b2c1e6d5fd02edd5d3c26e8,1214331647,406,,,,,"     bufcolumn = null;",,,6461
2376,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,767,82a9d1d0a24147dcb533542559d61783058f1a1b,1256944166,1037,,,,,"            sockKey = null;",,,6461
2377,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,526,ad482ad24cc864686f268b71896606091d92a00f,1222452565,572,,,,,"        return exists(path, watch ? defaultWatcher : null);",,,6461
2378,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,559,a399144537dfef4468a96971641bc372a3d8a76f,1228176830,630,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,-1,1222290326/1214327670,"        exists(path, watch ? defaultWatcher : null, cb, ctx);","      * @see #exists(String, boolean)
      */
     public void exists(String path, boolean watch, StatCallback cb, Object ctx) {
-        exists(path, watch ? defaultWatcher : null, cb, ctx);
+        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);
     }
 
     /**
",,6461
2379,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,622,c6639c9842973a7954c8baa412d6825cb833d51f,1232063304,674,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,-1,1222290326/1214327670,"        return getData(path, watch ? defaultWatcher : null, stat);","      */
     public byte[] getData(String path, boolean watch, Stat stat)
             throws KeeperException, InterruptedException {
-        return getData(path, watch ? defaultWatcher : null, stat);
+        return getData(path, watch ? watchManager.defaultWatcher : null, stat);
     }
 
     /**
",,6461
2380,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,653,a399144537dfef4468a96971641bc372a3d8a76f,1228176830,757,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,-1,1222290326/1214327670,"        getData(path, watch ? defaultWatcher : null, cb, ctx);","      * @see #getData(String, boolean, Stat)
      */
     public void getData(String path, boolean watch, DataCallback cb, Object ctx) {
-        getData(path, watch ? defaultWatcher : null, cb, ctx);
+        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);
     }
 
     /**
",,6461
2381,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,876,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,1258056155,935,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,-1,1222290326/1214327670,"        return getChildren(path, watch ? defaultWatcher : null);","      */
     public List<String> getChildren(String path, boolean watch)
             throws KeeperException, InterruptedException {
-        return getChildren(path, watch ? defaultWatcher : null);
+        return getChildren(path, watch ? watchManager.defaultWatcher : null);
     }
 
     /**
",,6461
2382,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,909,a399144537dfef4468a96971641bc372a3d8a76f,1228176830,1021,,,,,"        getChildren(path, watch ? defaultWatcher : null, cb, ctx);",,,6461
2383,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,220,e5b90d600c69107da88d1758c1e66eba7cc1abad,1233101733,374,,,,,"            node.parent = null;",,,6461
2384,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,554,82627a641750383bc7380c568291839bbea5c26e,1224202903,724,,,,,"        root = null;",,,6461
2385,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,696,9107bbaf5f94ea0c70bcaae458538c95aeb61454,1249601012,868,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,-1,1214334298/1214327670,"        sock = null;","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.zookeeper.server;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.CancelledKeyException;
-import java.nio.channels.Channel;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.ServerSocketChannel;
-import java.nio.channels.SocketChannel;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Set;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import org.apache.jute.BinaryInputArchive;
-import org.apache.jute.BinaryOutputArchive;
-import org.apache.jute.Record;
-import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.Version;
-import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZooDefs.OpCode;
-import org.apache.zookeeper.data.Id;
-import org.apache.zookeeper.proto.AuthPacket;
-import org.apache.zookeeper.proto.ConnectRequest;
-import org.apache.zookeeper.proto.ConnectResponse;
-import org.apache.zookeeper.proto.ReplyHeader;
-import org.apache.zookeeper.proto.RequestHeader;
-import org.apache.zookeeper.proto.WatcherEvent;
-import org.apache.zookeeper.server.auth.AuthenticationProvider;
-import org.apache.zookeeper.server.auth.ProviderRegistry;
-
-/**
- * This class handles communication with clients using NIO. There is one per
- * client, but only one thread doing the communication.
- */
-public class NIOServerCnxn implements Watcher, ServerCnxn {
-    private static final Logger LOG = Logger.getLogger(NIOServerCnxn.class);
-
-    static public class Factory extends Thread {
-        ZooKeeperServer zks;
-
-        ServerSocketChannel ss;
-
-        Selector selector = Selector.open();
-
-        /**
-         * We use this buffer to do efficient socket I/O. Since there is a single
-         * sender thread per NIOServerCnxn instance, we can use a member variable to
-         * only allocate it once.
-        */
-        ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);
-
-        HashSet<NIOServerCnxn> cnxns = new HashSet<NIOServerCnxn>();
-
-        int outstandingLimit = 1;
-
-        public Factory(int port) throws IOException {
-            super(""NIOServerCxn.Factory"");
-            setDaemon(true);
-            this.ss = ServerSocketChannel.open();
-            ss.socket().bind(new InetSocketAddress(port));
-            ss.configureBlocking(false);
-            ss.register(selector, SelectionKey.OP_ACCEPT);
-            start();
-        }
-
-        public void startup(ZooKeeperServer zks) throws IOException,
-                InterruptedException {
-            zks.startup();
-            setZooKeeperServer(zks);
-        }
-
-        public void setZooKeeperServer(ZooKeeperServer zks) {
-            this.zks = zks;
-            if (zks != null) {
-                this.outstandingLimit = zks.getGlobalOutstandingLimit();
-                zks.setServerCnxnFactory(this);
-            } else {
-                this.outstandingLimit = 1;
-            }
-        }
-
-        public InetSocketAddress getLocalAddress(){
-            return (InetSocketAddress)ss.socket().getLocalSocketAddress();
-        }
-
-        private void addCnxn(NIOServerCnxn cnxn) {
-            synchronized (cnxns) {
-                cnxns.add(cnxn);
-            }
-        }
-
-        protected NIOServerCnxn createConnection(SocketChannel sock,
-                SelectionKey sk) throws IOException {
-            return new NIOServerCnxn(zks, sock, sk, this);
-        }
-
-        public void run() {
-            while (!ss.socket().isClosed()) {
-                try {
-                    selector.select(1000);
-                    Set<SelectionKey> selected;
-                    synchronized (this) {
-                        selected = selector.selectedKeys();
-                    }
-                    ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(
-                            selected);
-                    Collections.shuffle(selectedList);
-                    for (SelectionKey k : selectedList) {
-                        if ((k.readyOps() & SelectionKey.OP_ACCEPT) != 0) {
-                            SocketChannel sc = ((ServerSocketChannel) k
-                                    .channel()).accept();
-                            sc.configureBlocking(false);
-                            SelectionKey sk = sc.register(selector,
-                                    SelectionKey.OP_READ);
-                            NIOServerCnxn cnxn = createConnection(sc, sk);
-                            sk.attach(cnxn);
-                            addCnxn(cnxn);
-                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
-                            NIOServerCnxn c = (NIOServerCnxn) k.attachment();
-                            c.doIO(k);
-                        }
-                    }
-                    selected.clear();
-                } catch (Exception e) {
-                    LOG.error(""FIXMSG"",e);
-                }
-            }
-            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""NIOServerCnxn factory exitedloop."");
-            clear();
-            LOG.error(""=====> Goodbye cruel world <======"");
-            // System.exit(0);
-        }
-
-        /**
-         * clear all the connections in the selector
-         *
-         */
-        synchronized public void clear() {
-            selector.wakeup();
-            synchronized (cnxns) {
-                // got to clear all the connections that we have in the selector
-                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
-                        .hasNext();) {
-                    NIOServerCnxn cnxn = it.next();
-                    it.remove();
-                    try {
-                        cnxn.close();
-                    } catch (Exception e) {
-                        // Do nothing.
-                    }
-                }
-            }
-
-        }
-
-        public void shutdown() {
-            try {
-                ss.close();
-                clear();
-                this.interrupt();
-                this.join();
-            } catch (InterruptedException e) {
-                LOG.warn(""Interrupted"",e);
-            } catch (Exception e) {
-                LOG.error(""Unexpected exception"", e);
-            }
-            if (zks != null) {
-                zks.shutdown();
-            }
-        }
-
-        synchronized void closeSession(long sessionId) {
-            selector.wakeup();
-            synchronized (cnxns) {
-                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
-                        .hasNext();) {
-                    NIOServerCnxn cnxn = it.next();
-                    if (cnxn.sessionId == sessionId) {
-                        it.remove();
-                        try {
-                            cnxn.close();
-                        } catch (Exception e) {
-                        }
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * The buffer will cause the connection to be close when we do a send.
-     */
-    static final ByteBuffer closeConn = ByteBuffer.allocate(0);
-
-    Factory factory;
-
-    ZooKeeperServer zk;
-
-    private SocketChannel sock;
-
-    private SelectionKey sk;
-
-    boolean initialized;
-
-    ByteBuffer lenBuffer = ByteBuffer.allocate(4);
-
-    ByteBuffer incomingBuffer = lenBuffer;
-
-    LinkedBlockingQueue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();
-
-    int sessionTimeout;
-
-    ArrayList<Id> authInfo = new ArrayList<Id>();
-
-    LinkedList<Request> outstanding = new LinkedList<Request>();
-
-    void sendBuffer(ByteBuffer bb) {
-        synchronized (factory) {
-            try {
-                sk.selector().wakeup();
-                // ZooLog.logTraceMessage(LOG,
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
-                // ""Add a buffer to outgoingBuffers"");
-                // ZooLog.logTraceMessage(LOG,
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
-                //""sk "" + sk + "" is valid: "" +
-                // sk.isValid(), );
-                outgoingBuffers.add(bb);
-                if (sk.isValid()) {
-                    sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
-                }
-            } catch (RuntimeException e) {
-                LOG.error(""FIXMSG"",e);
-                throw e;
-            }
-        }
-    }
-
-    void doIO(SelectionKey k) throws InterruptedException {
-        try {
-            if (sock == null) {
-                return;
-            }
-            if (k.isReadable()) {
-                int rc = sock.read(incomingBuffer);
-                if (rc < 0) {
-                    throw new IOException(""Read error"");
-                }
-                if (incomingBuffer.remaining() == 0) {
-                    incomingBuffer.flip();
-                    if (incomingBuffer == lenBuffer) {
-                        readLength(k);
-                    } else if (!initialized) {
-                        stats.packetsReceived++;
-                        ServerStats.getInstance().incrementPacketsReceived();
-                        readConnectRequest();
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                    } else {
-                        stats.packetsReceived++;
-                        ServerStats.getInstance().incrementPacketsReceived();
-                        readRequest();
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                    }
-                }
-            }
-            if (k.isWritable()) {
-                // ZooLog.logTraceMessage(LOG,
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK
-                // ""outgoingBuffers.size() = "" +
-                // outgoingBuffers.size());
-                if (outgoingBuffers.size() > 0) {
-                    // ZooLog.logTraceMessage(LOG,
-                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
-                    // ""sk "" + k + "" is valid: "" +
-                    // k.isValid());
-
-                    /*
-                     * This is going to reset the buffer position to 0 and the
-                     * limit to the size of the buffer, so that we can fill it
-                     * with data from the non-direct buffers that we need to
-                     * send.
-                     */
-                    ByteBuffer directBuffer = factory.directBuffer;
-                    directBuffer.clear();
-
-                    for (ByteBuffer b : outgoingBuffers) {
-                        if (directBuffer.remaining() < b.remaining()) {
-                            /*
-                             * When we call put later, if the directBuffer is to
-                             * small to hold everything, nothing will be copied,
-                             * so we've got to slice the buffer if it's too big.
-                             */
-                            b = (ByteBuffer) b.slice().limit(
-                                    directBuffer.remaining());
-                        }
-                        /*
-                         * put() is going to modify the positions of both
-                         * buffers, put we don't want to change the position of
-                         * the source buffers (we'll do that after the send, if
-                         * needed), so we save and reset the position after the
-                         * copy
-                         */
-                        int p = b.position();
-                        directBuffer.put(b);
-                        b.position(p);
-                        if (directBuffer.remaining() == 0) {
-                            break;
-                        }
-                    }
-                    /*
-                     * Do the flip: limit becomes position, position gets set to
-                     * 0. This sets us up for the write.
-                     */
-                    directBuffer.flip();
-
-                    int sent = sock.write(directBuffer);
-                    ByteBuffer bb;
-
-                    // Remove the buffers that we have sent
-                    while (outgoingBuffers.size() > 0) {
-                        bb = outgoingBuffers.peek();
-                        if (bb == closeConn) {
-                            throw new IOException(""closing"");
-                        }
-                        int left = bb.remaining() - sent;
-                        if (left > 0) {
-                            /*
-                             * We only partially sent this buffer, so we update
-                             * the position and exit the loop.
-                             */
-                            bb.position(bb.position() + sent);
-                            break;
-                        }
-                        stats.packetsSent++;
-                        /* We've sent the whole buffer, so drop the buffer */
-                        sent -= bb.remaining();
-                        ServerStats.getInstance().incrementPacketsSent();
-                        outgoingBuffers.remove();
-                    }
-                    // ZooLog.logTraceMessage(LOG,
-                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, ""after send,
-                    // outgoingBuffers.size() = "" + outgoingBuffers.size());
-                }
-                synchronized (this) {
-                    if (outgoingBuffers.size() == 0) {
-                        if (!initialized
-                                && (sk.interestOps() & SelectionKey.OP_READ) == 0) {
-                            throw new IOException(""Responded to info probe"");
-                        }
-                        sk.interestOps(sk.interestOps()
-                                & (~SelectionKey.OP_WRITE));
-                    } else {
-                        sk.interestOps(sk.interestOps()
-                                        | SelectionKey.OP_WRITE);
-                    }
-                }
-            }
-        } catch (CancelledKeyException e) {
-            close();
-        } catch (IOException e) {
-            // LOG.error(""FIXMSG"",e);
-            close();
-        }
-    }
-
-    private void readRequest() throws IOException {
-        // We have the request, now process and setup for next
-        InputStream bais = new ByteBufferInputStream(incomingBuffer);
-        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);
-        RequestHeader h = new RequestHeader();
-        h.deserialize(bia, ""header"");
-        // Through the magic of byte buffers, txn will not be
-        // pointing
-        // to the start of the txn
-        incomingBuffer = incomingBuffer.slice();
-        if (h.getType() == OpCode.auth) {
-            AuthPacket authPacket = new AuthPacket();
-            ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);
-            String scheme = authPacket.getScheme();
-            AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);
-            if (ap == null
-                    || ap.handleAuthentication(this, authPacket.getAuth()) != KeeperException.Code.Ok) {
-                if (ap == null)
-                    LOG.error(""No authentication provider for scheme: ""
-                            + scheme);
-                else
-                    LOG.error(""Authentication failed for scheme: ""
-                            + scheme);
-                // send a response...
-                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
-                        KeeperException.Code.AuthFailed);
-                sendResponse(rh, null, null);
-                // ... and close connection
-                sendBuffer(NIOServerCnxn.closeConn);
-                disableRecv();
-            } else {
-                LOG.error(""Authentication succeeded for scheme: ""
-                        + scheme);
-                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
-                        KeeperException.Code.Ok);
-                sendResponse(rh, null, null);
-            }
-            return;
-        } else {
-            zk.submitRequest(this, sessionId, h.getType(), h.getXid(),
-                    incomingBuffer, authInfo);
-        }
-        if (h.getXid() >= 0) {
-            synchronized (this) {
-                outstandingRequests++;
-                // check throttling
-                if (zk.getInProcess() > factory.outstandingLimit) {
-                    disableRecv();
-                    // following lines should not be needed since we are already
-                    // reading
-                    // } else {
-                    // enableRecv();
-                }
-            }
-        }
-    }
-
-    public void disableRecv() {
-        sk.interestOps(sk.interestOps() & (~SelectionKey.OP_READ));
-    }
-
-    public void enableRecv() {
-        if (sk.isValid()) {
-            int interest = sk.interestOps();
-            if ((interest & SelectionKey.OP_READ) == 0) {
-                sk.interestOps(interest | SelectionKey.OP_READ);
-            }
-        }
-    }
-
-    private void readConnectRequest() throws IOException, InterruptedException {
-        BinaryInputArchive bia = BinaryInputArchive
-                .getArchive(new ByteBufferInputStream(incomingBuffer));
-        ConnectRequest connReq = new ConnectRequest();
-        connReq.deserialize(bia, ""connect"");
-        LOG.warn(""Connected to "" + sock.socket().getRemoteSocketAddress()
-                + "" lastZxid "" + connReq.getLastZxidSeen());
-        if (zk == null) {
-            throw new IOException(""ZooKeeperServer not running"");
-        }
-        if (connReq.getLastZxidSeen() > zk.dataTree.lastProcessedZxid) {
-            LOG.error(""Client has seen ""
-                    + Long.toHexString(connReq.getLastZxidSeen())
-                    + "" our last zxid is ""
-                    + Long.toHexString(zk.dataTree.lastProcessedZxid));
-            throw new IOException(""We are out of date"");
-        }
-        sessionTimeout = connReq.getTimeOut();
-        byte passwd[] = connReq.getPasswd();
-        if (sessionTimeout < zk.tickTime * 2) {
-            sessionTimeout = zk.tickTime * 2;
-        }
-        if (sessionTimeout > zk.tickTime * 20) {
-            sessionTimeout = zk.tickTime * 20;
-        }
-        // We don't want to receive any packets until we are sure that the
-        // session is setup
-        disableRecv();
-        if (connReq.getSessionId() != 0) {
-            setSessionId(connReq.getSessionId());
-            zk.reopenSession(this, sessionId, passwd, sessionTimeout);
-            LOG.warn(""Renewing session "" + Long.toHexString(sessionId));
-        } else {
-            zk.createSession(this, passwd, sessionTimeout);
-            LOG.warn(""Creating new session ""
-                    + Long.toHexString(sessionId));
-        }
-        initialized = true;
-    }
-
-    private void readLength(SelectionKey k) throws IOException {
-        // Read the length, now get the buffer
-        int len = lenBuffer.getInt();
-        if (!initialized) {
-            // We take advantage of the limited size of the length to look
-            // for cmds. They are all 4-bytes which fits inside of an int
-            if (len == ruokCmd) {
-                sendBuffer(imok.duplicate());
-                sendBuffer(NIOServerCnxn.closeConn);
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == killCmd) {
-                System.exit(0);
-            } else if (len == getTraceMaskCmd) {
-                long traceMask = ZooTrace.getTextTraceLevel();
-                ByteBuffer resp = ByteBuffer.allocate(8);
-                resp.putLong(traceMask);
-                resp.flip();
-                sendBuffer(resp);
-                sendBuffer(NIOServerCnxn.closeConn);
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == setTraceMaskCmd) {
-                incomingBuffer = ByteBuffer.allocate(8);
-
-                int rc = sock.read(incomingBuffer);
-                if (rc < 0) {
-                    throw new IOException(""Read error"");
-                }
-                System.out.println(""rc="" + rc);
-                incomingBuffer.flip();
-                long traceMask = incomingBuffer.getLong();
-                ZooTrace.setTextTraceLevel(traceMask);
-                ByteBuffer resp = ByteBuffer.allocate(8);
-                resp.putLong(traceMask);
-                resp.flip();
-                sendBuffer(resp);
-                sendBuffer(NIOServerCnxn.closeConn);
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == dumpCmd) {
-                if (zk == null) {
-                    sendBuffer(ByteBuffer.wrap(""ZooKeeper not active \n""
-                            .getBytes()));
-                } else {
-                    StringBuffer sb = new StringBuffer();
-                    sb.append(""SessionTracker dump: \n"");
-                    sb.append(zk.sessionTracker.toString()).append(""\n"");
-                    sb.append(""ephemeral nodes dump:\n"");
-                    sb.append(zk.dataTree.dumpEphemerals()).append(""\n"");
-                    sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
-                }
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == reqsCmd) {
-                StringBuffer sb = new StringBuffer();
-                sb.append(""Requests:\n"");
-                synchronized (outstanding) {
-                    for (Request r : outstanding) {
-                        sb.append(r.toString());
-                        sb.append('\n');
-                    }
-                }
-                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            } else if (len == statCmd) {
-                StringBuffer sb = new StringBuffer();
-                if(zk!=null){
-                    sb.append(""Zookeeper version: "").append(Version.getFullVersion())
-                        .append(""\n"");
-                    sb.append(""Clients:\n"");
-                    synchronized(factory.cnxns){
-                        for(NIOServerCnxn c : factory.cnxns){
-                            sb.append(c.getStats().toString());
-                        }
-                    }
-                    sb.append(""\n"");
-                    sb.append(ServerStats.getInstance().toString());
-                    sb.append(""Node count: "").append(zk.dataTree.getNodeCount()).
-                        append(""\n"");
-                }else
-                    sb.append(""ZooKeeperServer not running\n"");
-
-                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
-                k.interestOps(SelectionKey.OP_WRITE);
-                return;
-            }
-        }
-        if (len < 0 || len > BinaryInputArchive.maxBuffer) {
-            throw new IOException(""Len error "" + len);
-        }
-        if (zk == null) {
-            throw new IOException(""ZooKeeperServer not running"");
-        }
-        incomingBuffer = ByteBuffer.allocate(len);
-    }
-
-    /**
-     * The number of requests that have been submitted but not yet responded to.
-     */
-    int outstandingRequests;
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()
-     */
-    public int getSessionTimeout() {
-        return sessionTimeout;
-    }
-
-    /**
-     * This is the id that uniquely identifies the session of a client. Once
-     * this session is no longer active, the ephemeral nodes will go away.
-     */
-    long sessionId;
-
-    static long nextSessionId = 1;
-
-    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock,
-            SelectionKey sk, Factory factory) throws IOException {
-        this.zk = zk;
-        this.sock = sock;
-        this.sk = sk;
-        this.factory = factory;
-        sock.socket().setTcpNoDelay(true);
-        sock.socket().setSoLinger(true, 2);
-        InetAddress addr = ((InetSocketAddress) sock.socket()
-                .getRemoteSocketAddress()).getAddress();
-        authInfo.add(new Id(""ip"", addr.getHostAddress()));
-        authInfo.add(new Id(""host"", addr.getCanonicalHostName()));
-        sk.interestOps(SelectionKey.OP_READ);
-    }
-
-    public String toString() {
-        return ""NIOServerCnxn object with sock = "" + sock + "" and sk = "" + sk;
-    }
-
-    boolean closed;
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.zookeeper.server.ServerCnxnIface#close()
-     */
-    public void close() {
-        if (closed) {
-            return;
-        }
-        closed = true;
-        synchronized (factory.cnxns) {
-            factory.cnxns.remove(this);
-        }
-        if (zk != null) {
-            zk.removeCnxn(this);
-        }
-
-        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
-                                 ""close  NIOServerCnxn: "" + sock);
-        try {
-            /*
-             * The following sequence of code is stupid! You would think that
-             * only sock.close() is needed, but alas, it doesn't work that way.
-             * If you just do sock.close() there are cases where the socket
-             * doesn't actually close...
-             */
-            sock.socket().shutdownOutput();
-        } catch (IOException e) {
-            // This is a relatively common exception that we can't avoid
-        }
-        try {
-            sock.socket().shutdownInput();
-        } catch (IOException e) {
-        }
-        try {
-            sock.socket().close();
-        } catch (IOException e) {
-            LOG.error(""FIXMSG"",e);
-        }
-        try {
-            sock.close();
-            // XXX The next line doesn't seem to be needed, but some posts
-            // to forums suggest that it is needed. Keep in mind if errors in
-            // this section arise.
-            // factory.selector.wakeup();
-        } catch (IOException e) {
-            LOG.error(""FIXMSG"",e);
-        }
-        sock = null;
-        if (sk != null) {
-            try {
-                // need to cancel this selection key from the selector
-                sk.cancel();
-            } catch (Exception e) {
-            }
-        }
-    }
-
-    private final static byte fourBytes[] = new byte[4];
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.zookeeper.server.ServerCnxnIface#sendResponse(org.apache.zookeeper.proto.ReplyHeader,
-     *      org.apache.jute.Record, java.lang.String)
-     */
-    synchronized public void sendResponse(ReplyHeader h, Record r, String tag) {
-        if (closed) {
-            return;
-        }
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        // Make space for length
-        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
-        try {
-            baos.write(fourBytes);
-            bos.writeRecord(h, ""header"");
-            if (r != null) {
-                bos.writeRecord(r, tag);
-            }
-            baos.close();
-        } catch (IOException e) {
-            LOG.error(""Error serializing response"");
-        }
-        byte b[] = baos.toByteArray();
-        ByteBuffer bb = ByteBuffer.wrap(b);
-        bb.putInt(b.length - 4).rewind();
-        sendBuffer(bb);
-        if (h.getXid() > 0) {
-            synchronized (this.factory) {
-                outstandingRequests--;
-                // check throttling
-                if (zk.getInProcess() < factory.outstandingLimit
-                        || outstandingRequests < 1) {
-                    sk.selector().wakeup();
-                    enableRecv();
-                }
-            }
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.zookeeper.server.ServerCnxnIface#process(org.apache.zookeeper.proto.WatcherEvent)
-     */
-    synchronized public void process(WatcherEvent event) {
-        ReplyHeader h = new ReplyHeader(-1, -1L, 0);
-        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,
-                                 ""Deliver event "" + event + "" to ""
-                                 + this.sessionId + "" through "" + this);
-        sendResponse(h, event, ""notification"");
-    }
-
-    public void finishSessionInit(boolean valid) {
-        try {
-            ConnectResponse rsp = new ConnectResponse(0, valid ? sessionTimeout
-                    : 0, valid ? sessionId : 0, // send 0 if session is no
-                    // longer valid
-                    valid ? zk.generatePasswd(sessionId) : new byte[16]);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
-            bos.writeInt(-1, ""len"");
-            rsp.serialize(bos, ""connect"");
-            baos.close();
-            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
-            bb.putInt(bb.remaining() - 4).rewind();
-            sendBuffer(bb);
-            LOG.warn(""Finished init of "" + Long.toHexString(sessionId)
-                    + "": "" + valid);
-            if (!valid) {
-                sendBuffer(closeConn);
-            }
-            // Now that the session is ready we can start receiving packets
-            synchronized (this.factory) {
-                sk.selector().wakeup();
-                enableRecv();
-            }
-        } catch (Exception e) {
-            LOG.error(""FIXMSG"",e);
-            close();
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionId()
-     */
-    public long getSessionId() {
-        return sessionId;
-    }
-
-    public void setSessionId(long sessionId) {
-        this.sessionId = sessionId;
-    }
-
-    public ArrayList<Id> getAuthInfo() {
-        return authInfo;
-    }
-
-    public InetSocketAddress getRemoteAddress() {
-        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
-    }
-
-    private class CnxnStats implements ServerCnxn.Stats{
-        long packetsReceived;
-        long packetsSent;
-
-        /**
-         * The number of requests that have been submitted but not yet responded to.
-         */
-        public long getOutstandingRequests() {
-            return outstandingRequests;
-        }
-        public long getPacketsReceived() {
-            return packetsReceived;
-        }
-        public long getPacketsSent() {
-            return packetsSent;
-        }
-        public String toString(){
-            StringBuilder sb=new StringBuilder();
-            Channel channel = sk.channel();
-            if (channel instanceof SocketChannel) {
-                sb.append("" "").append(((SocketChannel)channel).socket()
-                                .getRemoteSocketAddress())
-                  .append(""["").append(Integer.toHexString(sk.interestOps()))
-                  .append(""](queued="").append(getOutstandingRequests())
-                  .append("",recved="").append(getPacketsReceived())
-                  .append("",sent="").append(getPacketsSent()).append("")\n"");
-            }
-            return sb.toString();
-        }
-    }
-
-    private CnxnStats stats=new CnxnStats();
-    public Stats getStats() {
-        return stats;
-    }
-
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.CancelledKeyException;
+import java.nio.channels.Channel;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Set;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.Version;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.proto.AuthPacket;
+import org.apache.zookeeper.proto.ConnectRequest;
+import org.apache.zookeeper.proto.ConnectResponse;
+import org.apache.zookeeper.proto.ReplyHeader;
+import org.apache.zookeeper.proto.RequestHeader;
+import org.apache.zookeeper.proto.WatcherEvent;
+import org.apache.zookeeper.server.auth.AuthenticationProvider;
+import org.apache.zookeeper.server.auth.ProviderRegistry;
+
+/**
+ * This class handles communication with clients using NIO. There is one per
+ * client, but only one thread doing the communication.
+ */
+public class NIOServerCnxn implements Watcher, ServerCnxn {
+    private static final Logger LOG = Logger.getLogger(NIOServerCnxn.class);
+
+    static public class Factory extends Thread {
+        ZooKeeperServer zks;
+
+        ServerSocketChannel ss;
+
+        Selector selector = Selector.open();
+
+        /**
+         * We use this buffer to do efficient socket I/O. Since there is a single
+         * sender thread per NIOServerCnxn instance, we can use a member variable to
+         * only allocate it once.
+        */
+        ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);
+
+        HashSet<NIOServerCnxn> cnxns = new HashSet<NIOServerCnxn>();
+
+        int outstandingLimit = 1;
+
+        public Factory(int port) throws IOException {
+            super(""NIOServerCxn.Factory"");
+            setDaemon(true);
+            this.ss = ServerSocketChannel.open();
+            ss.socket().bind(new InetSocketAddress(port));
+            ss.configureBlocking(false);
+            ss.register(selector, SelectionKey.OP_ACCEPT);
+            start();
+        }
+
+        public void startup(ZooKeeperServer zks) throws IOException,
+                InterruptedException {
+            zks.startup();
+            setZooKeeperServer(zks);
+        }
+
+        public void setZooKeeperServer(ZooKeeperServer zks) {
+            this.zks = zks;
+            if (zks != null) {
+                this.outstandingLimit = zks.getGlobalOutstandingLimit();
+                zks.setServerCnxnFactory(this);
+            } else {
+                this.outstandingLimit = 1;
+            }
+        }
+
+        public InetSocketAddress getLocalAddress(){
+            return (InetSocketAddress)ss.socket().getLocalSocketAddress();
+        }
+
+        private void addCnxn(NIOServerCnxn cnxn) {
+            synchronized (cnxns) {
+                cnxns.add(cnxn);
+            }
+        }
+
+        protected NIOServerCnxn createConnection(SocketChannel sock,
+                SelectionKey sk) throws IOException {
+            return new NIOServerCnxn(zks, sock, sk, this);
+        }
+
+        public void run() {
+            while (!ss.socket().isClosed()) {
+                try {
+                    selector.select(1000);
+                    Set<SelectionKey> selected;
+                    synchronized (this) {
+                        selected = selector.selectedKeys();
+                    }
+                    ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(
+                            selected);
+                    Collections.shuffle(selectedList);
+                    for (SelectionKey k : selectedList) {
+                        if ((k.readyOps() & SelectionKey.OP_ACCEPT) != 0) {
+                            SocketChannel sc = ((ServerSocketChannel) k
+                                    .channel()).accept();
+                            sc.configureBlocking(false);
+                            SelectionKey sk = sc.register(selector,
+                                    SelectionKey.OP_READ);
+                            NIOServerCnxn cnxn = createConnection(sc, sk);
+                            sk.attach(cnxn);
+                            addCnxn(cnxn);
+                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
+                            NIOServerCnxn c = (NIOServerCnxn) k.attachment();
+                            c.doIO(k);
+                        }
+                    }
+                    selected.clear();
+                } catch (Exception e) {
+                    LOG.error(""FIXMSG"",e);
+                }
+            }
+            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""NIOServerCnxn factory exitedloop."");
+            clear();
+            LOG.error(""=====> Goodbye cruel world <======"");
+            // System.exit(0);
+        }
+
+        /**
+         * clear all the connections in the selector
+         *
+         */
+        synchronized public void clear() {
+            selector.wakeup();
+            synchronized (cnxns) {
+                // got to clear all the connections that we have in the selector
+                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
+                        .hasNext();) {
+                    NIOServerCnxn cnxn = it.next();
+                    it.remove();
+                    try {
+                        cnxn.close();
+                    } catch (Exception e) {
+                        // Do nothing.
+                    }
+                }
+            }
+
+        }
+
+        public void shutdown() {
+            try {
+                ss.close();
+                clear();
+                this.interrupt();
+                this.join();
+            } catch (InterruptedException e) {
+                LOG.warn(""Interrupted"",e);
+            } catch (Exception e) {
+                LOG.error(""Unexpected exception"", e);
+            }
+            if (zks != null) {
+                zks.shutdown();
+            }
+        }
+
+        synchronized void closeSession(long sessionId) {
+            selector.wakeup();
+            synchronized (cnxns) {
+                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
+                        .hasNext();) {
+                    NIOServerCnxn cnxn = it.next();
+                    if (cnxn.sessionId == sessionId) {
+                        it.remove();
+                        try {
+                            cnxn.close();
+                        } catch (Exception e) {
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * The buffer will cause the connection to be close when we do a send.
+     */
+    static final ByteBuffer closeConn = ByteBuffer.allocate(0);
+
+    Factory factory;
+
+    ZooKeeperServer zk;
+
+    private SocketChannel sock;
+
+    private SelectionKey sk;
+
+    boolean initialized;
+
+    ByteBuffer lenBuffer = ByteBuffer.allocate(4);
+
+    ByteBuffer incomingBuffer = lenBuffer;
+
+    LinkedBlockingQueue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();
+
+    int sessionTimeout;
+
+    ArrayList<Id> authInfo = new ArrayList<Id>();
+
+    LinkedList<Request> outstanding = new LinkedList<Request>();
+
+    void sendBuffer(ByteBuffer bb) {
+        synchronized (factory) {
+            try {
+                sk.selector().wakeup();
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                // ""Add a buffer to outgoingBuffers"");
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                //""sk "" + sk + "" is valid: "" +
+                // sk.isValid(), );
+                outgoingBuffers.add(bb);
+                if (sk.isValid()) {
+                    sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
+                }
+            } catch (RuntimeException e) {
+                LOG.error(""FIXMSG"",e);
+                throw e;
+            }
+        }
+    }
+
+    void doIO(SelectionKey k) throws InterruptedException {
+        try {
+            if (sock == null) {
+                return;
+            }
+            if (k.isReadable()) {
+                int rc = sock.read(incomingBuffer);
+                if (rc < 0) {
+                    throw new IOException(""Read error"");
+                }
+                if (incomingBuffer.remaining() == 0) {
+                    incomingBuffer.flip();
+                    if (incomingBuffer == lenBuffer) {
+                        readLength(k);
+                    } else if (!initialized) {
+                        stats.packetsReceived++;
+                        ServerStats.getInstance().incrementPacketsReceived();
+                        readConnectRequest();
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                    } else {
+                        stats.packetsReceived++;
+                        ServerStats.getInstance().incrementPacketsReceived();
+                        readRequest();
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                    }
+                }
+            }
+            if (k.isWritable()) {
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK
+                // ""outgoingBuffers.size() = "" +
+                // outgoingBuffers.size());
+                if (outgoingBuffers.size() > 0) {
+                    // ZooLog.logTraceMessage(LOG,
+                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                    // ""sk "" + k + "" is valid: "" +
+                    // k.isValid());
+
+                    /*
+                     * This is going to reset the buffer position to 0 and the
+                     * limit to the size of the buffer, so that we can fill it
+                     * with data from the non-direct buffers that we need to
+                     * send.
+                     */
+                    ByteBuffer directBuffer = factory.directBuffer;
+                    directBuffer.clear();
+
+                    for (ByteBuffer b : outgoingBuffers) {
+                        if (directBuffer.remaining() < b.remaining()) {
+                            /*
+                             * When we call put later, if the directBuffer is to
+                             * small to hold everything, nothing will be copied,
+                             * so we've got to slice the buffer if it's too big.
+                             */
+                            b = (ByteBuffer) b.slice().limit(
+                                    directBuffer.remaining());
+                        }
+                        /*
+                         * put() is going to modify the positions of both
+                         * buffers, put we don't want to change the position of
+                         * the source buffers (we'll do that after the send, if
+                         * needed), so we save and reset the position after the
+                         * copy
+                         */
+                        int p = b.position();
+                        directBuffer.put(b);
+                        b.position(p);
+                        if (directBuffer.remaining() == 0) {
+                            break;
+                        }
+                    }
+                    /*
+                     * Do the flip: limit becomes position, position gets set to
+                     * 0. This sets us up for the write.
+                     */
+                    directBuffer.flip();
+
+                    int sent = sock.write(directBuffer);
+                    ByteBuffer bb;
+
+                    // Remove the buffers that we have sent
+                    while (outgoingBuffers.size() > 0) {
+                        bb = outgoingBuffers.peek();
+                        if (bb == closeConn) {
+                            throw new IOException(""closing"");
+                        }
+                        int left = bb.remaining() - sent;
+                        if (left > 0) {
+                            /*
+                             * We only partially sent this buffer, so we update
+                             * the position and exit the loop.
+                             */
+                            bb.position(bb.position() + sent);
+                            break;
+                        }
+                        stats.packetsSent++;
+                        /* We've sent the whole buffer, so drop the buffer */
+                        sent -= bb.remaining();
+                        ServerStats.getInstance().incrementPacketsSent();
+                        outgoingBuffers.remove();
+                    }
+                    // ZooLog.logTraceMessage(LOG,
+                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, ""after send,
+                    // outgoingBuffers.size() = "" + outgoingBuffers.size());
+                }
+                synchronized (this) {
+                    if (outgoingBuffers.size() == 0) {
+                        if (!initialized
+                                && (sk.interestOps() & SelectionKey.OP_READ) == 0) {
+                            throw new IOException(""Responded to info probe"");
+                        }
+                        sk.interestOps(sk.interestOps()
+                                & (~SelectionKey.OP_WRITE));
+                    } else {
+                        sk.interestOps(sk.interestOps()
+                                        | SelectionKey.OP_WRITE);
+                    }
+                }
+            }
+        } catch (CancelledKeyException e) {
+            close();
+        } catch (IOException e) {
+            // LOG.error(""FIXMSG"",e);
+            close();
+        }
+    }
+
+    private void readRequest() throws IOException {
+        // We have the request, now process and setup for next
+        InputStream bais = new ByteBufferInputStream(incomingBuffer);
+        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);
+        RequestHeader h = new RequestHeader();
+        h.deserialize(bia, ""header"");
+        // Through the magic of byte buffers, txn will not be
+        // pointing
+        // to the start of the txn
+        incomingBuffer = incomingBuffer.slice();
+        if (h.getType() == OpCode.auth) {
+            AuthPacket authPacket = new AuthPacket();
+            ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);
+            String scheme = authPacket.getScheme();
+            AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);
+            if (ap == null
+                    || ap.handleAuthentication(this, authPacket.getAuth()) != KeeperException.Code.Ok) {
+                if (ap == null)
+                    LOG.error(""No authentication provider for scheme: ""
+                            + scheme);
+                else
+                    LOG.error(""Authentication failed for scheme: ""
+                            + scheme);
+                // send a response...
+                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
+                        KeeperException.Code.AuthFailed);
+                sendResponse(rh, null, null);
+                // ... and close connection
+                sendBuffer(NIOServerCnxn.closeConn);
+                disableRecv();
+            } else {
+                LOG.error(""Authentication succeeded for scheme: ""
+                        + scheme);
+                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
+                        KeeperException.Code.Ok);
+                sendResponse(rh, null, null);
+            }
+            return;
+        } else {
+            zk.submitRequest(this, sessionId, h.getType(), h.getXid(),
+                    incomingBuffer, authInfo);
+        }
+        if (h.getXid() >= 0) {
+            synchronized (this) {
+                outstandingRequests++;
+                // check throttling
+                if (zk.getInProcess() > factory.outstandingLimit) {
+                    disableRecv();
+                    // following lines should not be needed since we are already
+                    // reading
+                    // } else {
+                    // enableRecv();
+                }
+            }
+        }
+    }
+
+    public void disableRecv() {
+        sk.interestOps(sk.interestOps() & (~SelectionKey.OP_READ));
+    }
+
+    public void enableRecv() {
+        if (sk.isValid()) {
+            int interest = sk.interestOps();
+            if ((interest & SelectionKey.OP_READ) == 0) {
+                sk.interestOps(interest | SelectionKey.OP_READ);
+            }
+        }
+    }
+
+    private void readConnectRequest() throws IOException, InterruptedException {
+        BinaryInputArchive bia = BinaryInputArchive
+                .getArchive(new ByteBufferInputStream(incomingBuffer));
+        ConnectRequest connReq = new ConnectRequest();
+        connReq.deserialize(bia, ""connect"");
+        LOG.warn(""Connected to "" + sock.socket().getRemoteSocketAddress()
+                + "" lastZxid "" + connReq.getLastZxidSeen());
+        if (zk == null) {
+            throw new IOException(""ZooKeeperServer not running"");
+        }
+        if (connReq.getLastZxidSeen() > zk.dataTree.lastProcessedZxid) {
+            LOG.error(""Client has seen ""
+                    + Long.toHexString(connReq.getLastZxidSeen())
+                    + "" our last zxid is ""
+                    + Long.toHexString(zk.dataTree.lastProcessedZxid));
+            throw new IOException(""We are out of date"");
+        }
+        sessionTimeout = connReq.getTimeOut();
+        byte passwd[] = connReq.getPasswd();
+        if (sessionTimeout < zk.tickTime * 2) {
+            sessionTimeout = zk.tickTime * 2;
+        }
+        if (sessionTimeout > zk.tickTime * 20) {
+            sessionTimeout = zk.tickTime * 20;
+        }
+        // We don't want to receive any packets until we are sure that the
+        // session is setup
+        disableRecv();
+        if (connReq.getSessionId() != 0) {
+            setSessionId(connReq.getSessionId());
+            zk.reopenSession(this, sessionId, passwd, sessionTimeout);
+            LOG.warn(""Renewing session "" + Long.toHexString(sessionId));
+        } else {
+            zk.createSession(this, passwd, sessionTimeout);
+            LOG.warn(""Creating new session ""
+                    + Long.toHexString(sessionId));
+        }
+        initialized = true;
+    }
+
+    private void readLength(SelectionKey k) throws IOException {
+        // Read the length, now get the buffer
+        int len = lenBuffer.getInt();
+        if (!initialized) {
+            // We take advantage of the limited size of the length to look
+            // for cmds. They are all 4-bytes which fits inside of an int
+            if (len == ruokCmd) {
+                sendBuffer(imok.duplicate());
+                sendBuffer(NIOServerCnxn.closeConn);
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == killCmd) {
+                System.exit(0);
+            } else if (len == getTraceMaskCmd) {
+                long traceMask = ZooTrace.getTextTraceLevel();
+                ByteBuffer resp = ByteBuffer.allocate(8);
+                resp.putLong(traceMask);
+                resp.flip();
+                sendBuffer(resp);
+                sendBuffer(NIOServerCnxn.closeConn);
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == setTraceMaskCmd) {
+                incomingBuffer = ByteBuffer.allocate(8);
+
+                int rc = sock.read(incomingBuffer);
+                if (rc < 0) {
+                    throw new IOException(""Read error"");
+                }
+                System.out.println(""rc="" + rc);
+                incomingBuffer.flip();
+                long traceMask = incomingBuffer.getLong();
+                ZooTrace.setTextTraceLevel(traceMask);
+                ByteBuffer resp = ByteBuffer.allocate(8);
+                resp.putLong(traceMask);
+                resp.flip();
+                sendBuffer(resp);
+                sendBuffer(NIOServerCnxn.closeConn);
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == dumpCmd) {
+                if (zk == null) {
+                    sendBuffer(ByteBuffer.wrap(""ZooKeeper not active \n""
+                            .getBytes()));
+                } else {
+                    StringBuffer sb = new StringBuffer();
+                    sb.append(""SessionTracker dump: \n"");
+                    sb.append(zk.sessionTracker.toString()).append(""\n"");
+                    sb.append(""ephemeral nodes dump:\n"");
+                    sb.append(zk.dataTree.dumpEphemerals()).append(""\n"");
+                    sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
+                }
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == reqsCmd) {
+                StringBuffer sb = new StringBuffer();
+                sb.append(""Requests:\n"");
+                synchronized (outstanding) {
+                    for (Request r : outstanding) {
+                        sb.append(r.toString());
+                        sb.append('\n');
+                    }
+                }
+                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            } else if (len == statCmd) {
+                StringBuffer sb = new StringBuffer();
+                if(zk!=null){
+                    sb.append(""Zookeeper version: "").append(Version.getFullVersion())
+                        .append(""\n"");
+                    sb.append(""Clients:\n"");
+                    synchronized(factory.cnxns){
+                        for(NIOServerCnxn c : factory.cnxns){
+                            sb.append(c.getStats().toString());
+                        }
+                    }
+                    sb.append(""\n"");
+                    sb.append(ServerStats.getInstance().toString());
+                    sb.append(""Node count: "").append(zk.dataTree.getNodeCount()).
+                        append(""\n"");
+                }else
+                    sb.append(""ZooKeeperServer not running\n"");
+
+                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
+                k.interestOps(SelectionKey.OP_WRITE);
+                return;
+            }
+        }
+        if (len < 0 || len > BinaryInputArchive.maxBuffer) {
+            throw new IOException(""Len error "" + len);
+        }
+        if (zk == null) {
+            throw new IOException(""ZooKeeperServer not running"");
+        }
+        incomingBuffer = ByteBuffer.allocate(len);
+    }
+
+    /**
+     * The number of requests that have been submitted but not yet responded to.
+     */
+    int outstandingRequests;
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()
+     */
+    public int getSessionTimeout() {
+        return sessionTimeout;
+    }
+
+    /**
+     * This is the id that uniquely identifies the session of a client. Once
+     * this session is no longer active, the ephemeral nodes will go away.
+     */
+    long sessionId;
+
+    static long nextSessionId = 1;
+
+    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock,
+            SelectionKey sk, Factory factory) throws IOException {
+        this.zk = zk;
+        this.sock = sock;
+        this.sk = sk;
+        this.factory = factory;
+        sock.socket().setTcpNoDelay(true);
+        sock.socket().setSoLinger(true, 2);
+        InetAddress addr = ((InetSocketAddress) sock.socket()
+                .getRemoteSocketAddress()).getAddress();
+        authInfo.add(new Id(""ip"", addr.getHostAddress()));
+        authInfo.add(new Id(""host"", addr.getCanonicalHostName()));
+        sk.interestOps(SelectionKey.OP_READ);
+    }
+
+    public String toString() {
+        return ""NIOServerCnxn object with sock = "" + sock + "" and sk = "" + sk;
+    }
+
+    boolean closed;
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see org.apache.zookeeper.server.ServerCnxnIface#close()
+     */
+    public void close() {
+        if (closed) {
+            return;
+        }
+        closed = true;
+        synchronized (factory.cnxns) {
+            factory.cnxns.remove(this);
+        }
+        if (zk != null) {
+            zk.removeCnxn(this);
+        }
+
+        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
+                                 ""close  NIOServerCnxn: "" + sock);
+        try {
+            /*
+             * The following sequence of code is stupid! You would think that
+             * only sock.close() is needed, but alas, it doesn't work that way.
+             * If you just do sock.close() there are cases where the socket
+             * doesn't actually close...
+             */
+            sock.socket().shutdownOutput();
+        } catch (IOException e) {
+            // This is a relatively common exception that we can't avoid
+        }
+        try {
+            sock.socket().shutdownInput();
+        } catch (IOException e) {
+        }
+        try {
+            sock.socket().close();
+        } catch (IOException e) {
+            LOG.error(""FIXMSG"",e);
+        }
+        try {
+            sock.close();
+            // XXX The next line doesn't seem to be needed, but some posts
+            // to forums suggest that it is needed. Keep in mind if errors in
+            // this section arise.
+            // factory.selector.wakeup();
+        } catch (IOException e) {
+            LOG.error(""FIXMSG"",e);
+        }
+        sock = null;
+        if (sk != null) {
+            try {
+                // need to cancel this selection key from the selector
+                sk.cancel();
+            } catch (Exception e) {
+            }
+        }
+    }
+
+    private final static byte fourBytes[] = new byte[4];
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see org.apache.zookeeper.server.ServerCnxnIface#sendResponse(org.apache.zookeeper.proto.ReplyHeader,
+     *      org.apache.jute.Record, java.lang.String)
+     */
+    synchronized public void sendResponse(ReplyHeader h, Record r, String tag) {
+        if (closed) {
+            return;
+        }
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        // Make space for length
+        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
+        try {
+            baos.write(fourBytes);
+            bos.writeRecord(h, ""header"");
+            if (r != null) {
+                bos.writeRecord(r, tag);
+            }
+            baos.close();
+        } catch (IOException e) {
+            LOG.error(""Error serializing response"");
+        }
+        byte b[] = baos.toByteArray();
+        ByteBuffer bb = ByteBuffer.wrap(b);
+        bb.putInt(b.length - 4).rewind();
+        sendBuffer(bb);
+        if (h.getXid() > 0) {
+            synchronized (this.factory) {
+                outstandingRequests--;
+                // check throttling
+                if (zk.getInProcess() < factory.outstandingLimit
+                        || outstandingRequests < 1) {
+                    sk.selector().wakeup();
+                    enableRecv();
+                }
+            }
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see org.apache.zookeeper.server.ServerCnxnIface#process(org.apache.zookeeper.proto.WatcherEvent)
+     */
+    synchronized public void process(WatcherEvent event) {
+        ReplyHeader h = new ReplyHeader(-1, -1L, 0);
+        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,
+                                 ""Deliver event "" + event + "" to ""
+                                 + this.sessionId + "" through "" + this);
+        sendResponse(h, event, ""notification"");
+    }
+
+    public void finishSessionInit(boolean valid) {
+        try {
+            ConnectResponse rsp = new ConnectResponse(0, valid ? sessionTimeout
+                    : 0, valid ? sessionId : 0, // send 0 if session is no
+                    // longer valid
+                    valid ? zk.generatePasswd(sessionId) : new byte[16]);
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
+            bos.writeInt(-1, ""len"");
+            rsp.serialize(bos, ""connect"");
+            baos.close();
+            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
+            bb.putInt(bb.remaining() - 4).rewind();
+            sendBuffer(bb);
+            LOG.warn(""Finished init of "" + Long.toHexString(sessionId)
+                    + "": "" + valid);
+            if (!valid) {
+                sendBuffer(closeConn);
+            }
+            // Now that the session is ready we can start receiving packets
+            synchronized (this.factory) {
+                sk.selector().wakeup();
+                enableRecv();
+            }
+        } catch (Exception e) {
+            LOG.error(""FIXMSG"",e);
+            close();
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionId()
+     */
+    public long getSessionId() {
+        return sessionId;
+    }
+
+    public void setSessionId(long sessionId) {
+        this.sessionId = sessionId;
+    }
+
+    public ArrayList<Id> getAuthInfo() {
+        return authInfo;
+    }
+
+    public InetSocketAddress getRemoteAddress() {
+        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
+    }
+
+    private class CnxnStats implements ServerCnxn.Stats{
+        long packetsReceived;
+        long packetsSent;
+
+        /**
+         * The number of requests that have been submitted but not yet responded to.
+         */
+        public long getOutstandingRequests() {
+            return outstandingRequests;
+        }
+        public long getPacketsReceived() {
+            return packetsReceived;
+        }
+        public long getPacketsSent() {
+            return packetsSent;
+        }
+        public String toString(){
+            StringBuilder sb=new StringBuilder();
+            Channel channel = sk.channel();
+            if (channel instanceof SocketChannel) {
+                sb.append("" "").append(((SocketChannel)channel).socket()
+                                .getRemoteSocketAddress())
+                  .append(""["").append(Integer.toHexString(sk.interestOps()))
+                  .append(""](queued="").append(getOutstandingRequests())
+                  .append("",recved="").append(getPacketsReceived())
+                  .append("",sent="").append(getPacketsSent()).append("")\n"");
+            }
+            return sb.toString();
+        }
+    }
+
+    private CnxnStats stats=new CnxnStats();
+    public Stats getStats() {
+        return stats;
+    }
+
+}
",,6461
2386,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ServerStats.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,43,4cdb4305ad4acd8189b4f771b30f05d4cf68703e,1220547729,45,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,-1,1232060234/1214327670,"        instance=null;"," package org.apache.zookeeper.server;
 
 
+/**
+ * Basic Server Statistics
+ */
 public class ServerStats {
-    private static ServerStats instance=null;
     private long packetsSent;
     private long packetsReceived;
     private long maxLatency;
     private long minLatency = Long.MAX_VALUE;
     private long totalLatency = 0;
     private long count = 0;
-    
-    public interface Provider{
+
+    private final Provider provider;
+
+    public interface Provider {
         public long getOutstandingRequests();
         public long getLastProcessedZxid();
     }
-    private Provider provider=null;
-    private Object mutex=new Object();
     
-    static public ServerStats getInstance(){
-        return instance;
-    }
-    static public void registerAsConcrete() {
-        setInstance(new ServerStats());
-    }
-    static synchronized public void unregister() {
-        instance=null;
-    }
-    static synchronized protected void setInstance(ServerStats newInstance){
-        assert instance==null;
-        instance = newInstance;
-    }
-    protected ServerStats() {
-        // protected constructor
+    public ServerStats(Provider provider) {
+        this.provider = provider;
     }
     
     // getters
     synchronized public long getMinLatency() {
-        return (minLatency == Long.MAX_VALUE) ? 0 : minLatency;
+        return minLatency == Long.MAX_VALUE ? 0 : minLatency;
     }
 
     synchronized public long getAvgLatency() {
-        if(count!=0)
+        if (count != 0) {
             return totalLatency / count;
+        }
         return 0;
     }
 
",,6461
2387,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,192,4cdb4305ad4acd8189b4f771b30f05d4cf68703e,1220547729,212,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,-1,1214334298/1214327670,"                                logStream = null;","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.zookeeper.server;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import org.apache.jute.BinaryOutputArchive;
-import org.apache.jute.Record;
-import org.apache.zookeeper.server.util.Profiler;
-import org.apache.zookeeper.txn.TxnHeader;
-
-/**
- * This RequestProcessor logs requests to disk. It batches the requests to do
- * the io efficiently. The request is not passed to the next RequestProcessor
- * until its log has been synced to disk.
- */
-public class SyncRequestProcessor extends Thread implements RequestProcessor {
-    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
-
-    static final int PADDING_TIMEOUT=1000;
-    ZooKeeperServer zks;
-
-    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
-
-    static boolean forceSync;
-    static {
-        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
-                ""no"");
-    }
-
-    static long preAllocSize = 65536 * 1024;
-    static {
-        String size = System.getProperty(""zookeeper.preAllocSize"");
-        if (size != null) {
-            try {
-                preAllocSize = Long.parseLong(size) * 1024;
-            } catch (NumberFormatException e) {
-                LOG.warn(size + "" is not a valid value for preAllocSize"");
-            }
-        }
-    }
-
-    /**
-     * The number of log entries to log before starting a snapshot
-     */
-    static public int snapCount = ZooKeeperServer.getSnapCount();
-
-    Thread snapInProcess;
-
-    RequestProcessor nextProcessor;
-
-    boolean timeToDie = false;
-
-    public SyncRequestProcessor(ZooKeeperServer zks,
-            RequestProcessor nextProcessor) {
-        super(""SyncThread"");
-        this.zks = zks;
-        this.nextProcessor = nextProcessor;
-        start();
-    }
-
-    /**
-     * Transactions that have been written and are waiting to be flushed to
-     * disk. Basically this is the list of SyncItems whose callbacks will be
-     * invoked after flush returns successfully.
-     */
-    LinkedList<Request> toFlush = new LinkedList<Request>();
-
-    FileOutputStream logStream;
-
-    BinaryOutputArchive logArchive;
-
-    Random r = new Random(System.nanoTime());
-
-    int logCount = 0;
-
-    Request requestOfDeath = Request.requestOfDeath;
-
-    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
-
-    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
-
-    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
-        long position = fc.position();
-        // We pad the file in 1M chunks to avoid syncing to
-        // write the new filesize.
-        if (position + 4096 >= fileSize) {
-            fileSize = fileSize + preAllocSize;
-            fill.position(0);
-            fc.write(fill, fileSize);
-        }
-        return fileSize;
-    }
-
-    public void run() {
-        try {
-            long fileSize = 0;
-            long lastZxidSeen = -1;
-            FileChannel fc = null;
-            while (true) {
-                Request si = null;
-                if (toFlush.isEmpty()) {
-                    si = queuedRequests.take();
-                } else {
-                    si = queuedRequests.poll();
-                    if (si == null) {
-                        flush(toFlush);
-                        continue;
-                    }
-                }
-                if (si == requestOfDeath) {
-                    break;
-                }
-                if (si != null) {
-                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
-                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
-                    // Long.toHexString(si.zxid));
-                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
-                            'S', si, """");
-                    TxnHeader hdr = si.hdr;
-                    if (hdr != null) {
-                        if (hdr.getZxid() <= lastZxidSeen) {
-                            LOG.warn(""Current zxid "" + hdr.getZxid()
-                                    + "" is <= "" + lastZxidSeen + "" for ""
-                                    + hdr.getType());
-                        }
-                        Record txn = si.txn;
-                        if (logStream == null) {
-                            fileSize = 0;
-                            logStream = new FileOutputStream(new File(
-                                    zks.dataLogDir, ZooKeeperServer
-                                            .getLogName(hdr.getZxid())));
-                            synchronized (streamsToFlush) {
-                                streamsToFlush.add(logStream);
-                            }
-                            fc = logStream.getChannel();
-                            logArchive = BinaryOutputArchive
-                                    .getArchive(logStream);
-                        }
-                        final long fsize=fileSize;
-                        final FileChannel ffc=fc;
-                        fileSize = Profiler.profile(
-                            new Profiler.Operation<Long>() {
-                                public Long execute() throws Exception {
-                                    return SyncRequestProcessor.this
-                                            .padLogFile(ffc, fsize);
-                                }
-                            }, PADDING_TIMEOUT,
-                            ""Logfile padding exceeded time threshold""
-                        );
-                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                        BinaryOutputArchive boa = BinaryOutputArchive
-                                .getArchive(baos);
-                        hdr.serialize(boa, ""hdr"");
-                        if (txn != null) {
-                            txn.serialize(boa, ""txn"");
-                        }
-                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
-                        logArchive.writeByte((byte) 0x42, ""EOR"");
-                        logCount++;
-                        if (logCount > snapCount / 2
-                                && r.nextInt(snapCount / 2) == 0) {
-                            // We just want one snapshot going at a time
-                            if (snapInProcess != null
-                                    && snapInProcess.isAlive()) {
-                                LOG.warn(""Too busy to snap, skipping"");
-                            } else {
-                                logStream = null;
-                                logArchive = null;
-                                snapInProcess = new Thread() {
-                                    public void run() {
-                                        try {
-                                            zks.snapshot();
-                                        } catch (Exception e) {
-                                            LOG.warn(""Unexpected exception"",e);
-                                        }
-                                    }
-                                };
-                                snapInProcess.start();
-                            }
-                            logCount = 0;
-                        }
-                    }
-                    toFlush.add(si);
-                    if (toFlush.size() > 1000) {
-                        flush(toFlush);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            LOG.error(""Severe error, exiting"",e);
-            System.exit(11);
-        }
-        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""SyncRequestProcessor exiyed!"");
-    }
-
-    private void flush(LinkedList<Request> toFlush) throws IOException {
-        if (toFlush.size() == 0) {
-            return;
-        }
-
-        LinkedList<FileOutputStream> streamsToFlushNow;
-        synchronized (streamsToFlush) {
-            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
-                    .clone();
-        }
-        for (FileOutputStream fos : streamsToFlushNow) {
-            fos.flush();
-            if (forceSync) {
-                ((FileChannel) fos.getChannel()).force(false);
-            }
-        }
-        while (streamsToFlushNow.size() > 1) {
-            FileOutputStream fos = streamsToFlushNow.removeFirst();
-            fos.close();
-            synchronized (streamsToFlush) {
-                streamsToFlush.remove(fos);
-            }
-        }
-        while (toFlush.size() > 0) {
-            Request i = toFlush.remove();
-            nextProcessor.processRequest(i);
-        }
-    }
-
-    public void shutdown() {
-        timeToDie = true;
-        queuedRequests.add(requestOfDeath);
-        nextProcessor.shutdown();
-    }
-
-    public void processRequest(Request request) {
-        // request.addRQRec("">sync"");
-        queuedRequests.add(request);
-    }
-
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.util.Profiler;
+import org.apache.zookeeper.txn.TxnHeader;
+
+/**
+ * This RequestProcessor logs requests to disk. It batches the requests to do
+ * the io efficiently. The request is not passed to the next RequestProcessor
+ * until its log has been synced to disk.
+ */
+public class SyncRequestProcessor extends Thread implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
+
+    static final int PADDING_TIMEOUT=1000;
+    ZooKeeperServer zks;
+
+    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
+
+    static boolean forceSync;
+    static {
+        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
+                ""no"");
+    }
+
+    static long preAllocSize = 65536 * 1024;
+    static {
+        String size = System.getProperty(""zookeeper.preAllocSize"");
+        if (size != null) {
+            try {
+                preAllocSize = Long.parseLong(size) * 1024;
+            } catch (NumberFormatException e) {
+                LOG.warn(size + "" is not a valid value for preAllocSize"");
+            }
+        }
+    }
+
+    /**
+     * The number of log entries to log before starting a snapshot
+     */
+    static public int snapCount = ZooKeeperServer.getSnapCount();
+
+    Thread snapInProcess;
+
+    RequestProcessor nextProcessor;
+
+    boolean timeToDie = false;
+
+    public SyncRequestProcessor(ZooKeeperServer zks,
+            RequestProcessor nextProcessor) {
+        super(""SyncThread"");
+        this.zks = zks;
+        this.nextProcessor = nextProcessor;
+        start();
+    }
+
+    /**
+     * Transactions that have been written and are waiting to be flushed to
+     * disk. Basically this is the list of SyncItems whose callbacks will be
+     * invoked after flush returns successfully.
+     */
+    LinkedList<Request> toFlush = new LinkedList<Request>();
+
+    FileOutputStream logStream;
+
+    BinaryOutputArchive logArchive;
+
+    Random r = new Random(System.nanoTime());
+
+    int logCount = 0;
+
+    Request requestOfDeath = Request.requestOfDeath;
+
+    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
+
+    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
+
+    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
+        long position = fc.position();
+        // We pad the file in 1M chunks to avoid syncing to
+        // write the new filesize.
+        if (position + 4096 >= fileSize) {
+            fileSize = fileSize + preAllocSize;
+            fill.position(0);
+            fc.write(fill, fileSize);
+        }
+        return fileSize;
+    }
+
+    public void run() {
+        try {
+            long fileSize = 0;
+            long lastZxidSeen = -1;
+            FileChannel fc = null;
+            while (true) {
+                Request si = null;
+                if (toFlush.isEmpty()) {
+                    si = queuedRequests.take();
+                } else {
+                    si = queuedRequests.poll();
+                    if (si == null) {
+                        flush(toFlush);
+                        continue;
+                    }
+                }
+                if (si == requestOfDeath) {
+                    break;
+                }
+                if (si != null) {
+                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
+                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
+                    // Long.toHexString(si.zxid));
+                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
+                            'S', si, """");
+                    TxnHeader hdr = si.hdr;
+                    if (hdr != null) {
+                        if (hdr.getZxid() <= lastZxidSeen) {
+                            LOG.warn(""Current zxid "" + hdr.getZxid()
+                                    + "" is <= "" + lastZxidSeen + "" for ""
+                                    + hdr.getType());
+                        }
+                        Record txn = si.txn;
+                        if (logStream == null) {
+                            fileSize = 0;
+                            logStream = new FileOutputStream(new File(
+                                    zks.dataLogDir, ZooKeeperServer
+                                            .getLogName(hdr.getZxid())));
+                            synchronized (streamsToFlush) {
+                                streamsToFlush.add(logStream);
+                            }
+                            fc = logStream.getChannel();
+                            logArchive = BinaryOutputArchive
+                                    .getArchive(logStream);
+                        }
+                        final long fsize=fileSize;
+                        final FileChannel ffc=fc;
+                        fileSize = Profiler.profile(
+                            new Profiler.Operation<Long>() {
+                                public Long execute() throws Exception {
+                                    return SyncRequestProcessor.this
+                                            .padLogFile(ffc, fsize);
+                                }
+                            }, PADDING_TIMEOUT,
+                            ""Logfile padding exceeded time threshold""
+                        );
+                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                        BinaryOutputArchive boa = BinaryOutputArchive
+                                .getArchive(baos);
+                        hdr.serialize(boa, ""hdr"");
+                        if (txn != null) {
+                            txn.serialize(boa, ""txn"");
+                        }
+                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
+                        logArchive.writeByte((byte) 0x42, ""EOR"");
+                        logCount++;
+                        if (logCount > snapCount / 2
+                                && r.nextInt(snapCount / 2) == 0) {
+                            // We just want one snapshot going at a time
+                            if (snapInProcess != null
+                                    && snapInProcess.isAlive()) {
+                                LOG.warn(""Too busy to snap, skipping"");
+                            } else {
+                                logStream = null;
+                                logArchive = null;
+                                snapInProcess = new Thread() {
+                                    public void run() {
+                                        try {
+                                            zks.snapshot();
+                                        } catch (Exception e) {
+                                            LOG.warn(""Unexpected exception"",e);
+                                        }
+                                    }
+                                };
+                                snapInProcess.start();
+                            }
+                            logCount = 0;
+                        }
+                    }
+                    toFlush.add(si);
+                    if (toFlush.size() > 1000) {
+                        flush(toFlush);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            LOG.error(""Severe error, exiting"",e);
+            System.exit(11);
+        }
+        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""SyncRequestProcessor exiyed!"");
+    }
+
+    private void flush(LinkedList<Request> toFlush) throws IOException {
+        if (toFlush.size() == 0) {
+            return;
+        }
+
+        LinkedList<FileOutputStream> streamsToFlushNow;
+        synchronized (streamsToFlush) {
+            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
+                    .clone();
+        }
+        for (FileOutputStream fos : streamsToFlushNow) {
+            fos.flush();
+            if (forceSync) {
+                ((FileChannel) fos.getChannel()).force(false);
+            }
+        }
+        while (streamsToFlushNow.size() > 1) {
+            FileOutputStream fos = streamsToFlushNow.removeFirst();
+            fos.close();
+            synchronized (streamsToFlush) {
+                streamsToFlush.remove(fos);
+            }
+        }
+        while (toFlush.size() > 0) {
+            Request i = toFlush.remove();
+            nextProcessor.processRequest(i);
+        }
+    }
+
+    public void shutdown() {
+        timeToDie = true;
+        queuedRequests.add(requestOfDeath);
+        nextProcessor.shutdown();
+    }
+
+    public void processRequest(Request request) {
+        // request.addRQRec("">sync"");
+        queuedRequests.add(request);
+    }
+
+}
",,6461
2388,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,193,4cdb4305ad4acd8189b4f771b30f05d4cf68703e,1220547729,213,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,-1,1214334298/1214327670,"                                logArchive = null;","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.zookeeper.server;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import org.apache.jute.BinaryOutputArchive;
-import org.apache.jute.Record;
-import org.apache.zookeeper.server.util.Profiler;
-import org.apache.zookeeper.txn.TxnHeader;
-
-/**
- * This RequestProcessor logs requests to disk. It batches the requests to do
- * the io efficiently. The request is not passed to the next RequestProcessor
- * until its log has been synced to disk.
- */
-public class SyncRequestProcessor extends Thread implements RequestProcessor {
-    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
-
-    static final int PADDING_TIMEOUT=1000;
-    ZooKeeperServer zks;
-
-    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
-
-    static boolean forceSync;
-    static {
-        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
-                ""no"");
-    }
-
-    static long preAllocSize = 65536 * 1024;
-    static {
-        String size = System.getProperty(""zookeeper.preAllocSize"");
-        if (size != null) {
-            try {
-                preAllocSize = Long.parseLong(size) * 1024;
-            } catch (NumberFormatException e) {
-                LOG.warn(size + "" is not a valid value for preAllocSize"");
-            }
-        }
-    }
-
-    /**
-     * The number of log entries to log before starting a snapshot
-     */
-    static public int snapCount = ZooKeeperServer.getSnapCount();
-
-    Thread snapInProcess;
-
-    RequestProcessor nextProcessor;
-
-    boolean timeToDie = false;
-
-    public SyncRequestProcessor(ZooKeeperServer zks,
-            RequestProcessor nextProcessor) {
-        super(""SyncThread"");
-        this.zks = zks;
-        this.nextProcessor = nextProcessor;
-        start();
-    }
-
-    /**
-     * Transactions that have been written and are waiting to be flushed to
-     * disk. Basically this is the list of SyncItems whose callbacks will be
-     * invoked after flush returns successfully.
-     */
-    LinkedList<Request> toFlush = new LinkedList<Request>();
-
-    FileOutputStream logStream;
-
-    BinaryOutputArchive logArchive;
-
-    Random r = new Random(System.nanoTime());
-
-    int logCount = 0;
-
-    Request requestOfDeath = Request.requestOfDeath;
-
-    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
-
-    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
-
-    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
-        long position = fc.position();
-        // We pad the file in 1M chunks to avoid syncing to
-        // write the new filesize.
-        if (position + 4096 >= fileSize) {
-            fileSize = fileSize + preAllocSize;
-            fill.position(0);
-            fc.write(fill, fileSize);
-        }
-        return fileSize;
-    }
-
-    public void run() {
-        try {
-            long fileSize = 0;
-            long lastZxidSeen = -1;
-            FileChannel fc = null;
-            while (true) {
-                Request si = null;
-                if (toFlush.isEmpty()) {
-                    si = queuedRequests.take();
-                } else {
-                    si = queuedRequests.poll();
-                    if (si == null) {
-                        flush(toFlush);
-                        continue;
-                    }
-                }
-                if (si == requestOfDeath) {
-                    break;
-                }
-                if (si != null) {
-                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
-                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
-                    // Long.toHexString(si.zxid));
-                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
-                            'S', si, """");
-                    TxnHeader hdr = si.hdr;
-                    if (hdr != null) {
-                        if (hdr.getZxid() <= lastZxidSeen) {
-                            LOG.warn(""Current zxid "" + hdr.getZxid()
-                                    + "" is <= "" + lastZxidSeen + "" for ""
-                                    + hdr.getType());
-                        }
-                        Record txn = si.txn;
-                        if (logStream == null) {
-                            fileSize = 0;
-                            logStream = new FileOutputStream(new File(
-                                    zks.dataLogDir, ZooKeeperServer
-                                            .getLogName(hdr.getZxid())));
-                            synchronized (streamsToFlush) {
-                                streamsToFlush.add(logStream);
-                            }
-                            fc = logStream.getChannel();
-                            logArchive = BinaryOutputArchive
-                                    .getArchive(logStream);
-                        }
-                        final long fsize=fileSize;
-                        final FileChannel ffc=fc;
-                        fileSize = Profiler.profile(
-                            new Profiler.Operation<Long>() {
-                                public Long execute() throws Exception {
-                                    return SyncRequestProcessor.this
-                                            .padLogFile(ffc, fsize);
-                                }
-                            }, PADDING_TIMEOUT,
-                            ""Logfile padding exceeded time threshold""
-                        );
-                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                        BinaryOutputArchive boa = BinaryOutputArchive
-                                .getArchive(baos);
-                        hdr.serialize(boa, ""hdr"");
-                        if (txn != null) {
-                            txn.serialize(boa, ""txn"");
-                        }
-                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
-                        logArchive.writeByte((byte) 0x42, ""EOR"");
-                        logCount++;
-                        if (logCount > snapCount / 2
-                                && r.nextInt(snapCount / 2) == 0) {
-                            // We just want one snapshot going at a time
-                            if (snapInProcess != null
-                                    && snapInProcess.isAlive()) {
-                                LOG.warn(""Too busy to snap, skipping"");
-                            } else {
-                                logStream = null;
-                                logArchive = null;
-                                snapInProcess = new Thread() {
-                                    public void run() {
-                                        try {
-                                            zks.snapshot();
-                                        } catch (Exception e) {
-                                            LOG.warn(""Unexpected exception"",e);
-                                        }
-                                    }
-                                };
-                                snapInProcess.start();
-                            }
-                            logCount = 0;
-                        }
-                    }
-                    toFlush.add(si);
-                    if (toFlush.size() > 1000) {
-                        flush(toFlush);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            LOG.error(""Severe error, exiting"",e);
-            System.exit(11);
-        }
-        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     ""SyncRequestProcessor exiyed!"");
-    }
-
-    private void flush(LinkedList<Request> toFlush) throws IOException {
-        if (toFlush.size() == 0) {
-            return;
-        }
-
-        LinkedList<FileOutputStream> streamsToFlushNow;
-        synchronized (streamsToFlush) {
-            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
-                    .clone();
-        }
-        for (FileOutputStream fos : streamsToFlushNow) {
-            fos.flush();
-            if (forceSync) {
-                ((FileChannel) fos.getChannel()).force(false);
-            }
-        }
-        while (streamsToFlushNow.size() > 1) {
-            FileOutputStream fos = streamsToFlushNow.removeFirst();
-            fos.close();
-            synchronized (streamsToFlush) {
-                streamsToFlush.remove(fos);
-            }
-        }
-        while (toFlush.size() > 0) {
-            Request i = toFlush.remove();
-            nextProcessor.processRequest(i);
-        }
-    }
-
-    public void shutdown() {
-        timeToDie = true;
-        queuedRequests.add(requestOfDeath);
-        nextProcessor.shutdown();
-    }
-
-    public void processRequest(Request request) {
-        // request.addRQRec("">sync"");
-        queuedRequests.add(request);
-    }
-
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.util.Profiler;
+import org.apache.zookeeper.txn.TxnHeader;
+
+/**
+ * This RequestProcessor logs requests to disk. It batches the requests to do
+ * the io efficiently. The request is not passed to the next RequestProcessor
+ * until its log has been synced to disk.
+ */
+public class SyncRequestProcessor extends Thread implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
+
+    static final int PADDING_TIMEOUT=1000;
+    ZooKeeperServer zks;
+
+    LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
+
+    static boolean forceSync;
+    static {
+        forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(
+                ""no"");
+    }
+
+    static long preAllocSize = 65536 * 1024;
+    static {
+        String size = System.getProperty(""zookeeper.preAllocSize"");
+        if (size != null) {
+            try {
+                preAllocSize = Long.parseLong(size) * 1024;
+            } catch (NumberFormatException e) {
+                LOG.warn(size + "" is not a valid value for preAllocSize"");
+            }
+        }
+    }
+
+    /**
+     * The number of log entries to log before starting a snapshot
+     */
+    static public int snapCount = ZooKeeperServer.getSnapCount();
+
+    Thread snapInProcess;
+
+    RequestProcessor nextProcessor;
+
+    boolean timeToDie = false;
+
+    public SyncRequestProcessor(ZooKeeperServer zks,
+            RequestProcessor nextProcessor) {
+        super(""SyncThread"");
+        this.zks = zks;
+        this.nextProcessor = nextProcessor;
+        start();
+    }
+
+    /**
+     * Transactions that have been written and are waiting to be flushed to
+     * disk. Basically this is the list of SyncItems whose callbacks will be
+     * invoked after flush returns successfully.
+     */
+    LinkedList<Request> toFlush = new LinkedList<Request>();
+
+    FileOutputStream logStream;
+
+    BinaryOutputArchive logArchive;
+
+    Random r = new Random(System.nanoTime());
+
+    int logCount = 0;
+
+    Request requestOfDeath = Request.requestOfDeath;
+
+    private static ByteBuffer fill = ByteBuffer.allocateDirect(1024);
+
+    LinkedList<FileOutputStream> streamsToFlush = new LinkedList<FileOutputStream>();
+
+    private long padLogFile(FileChannel fc,long fileSize) throws IOException{
+        long position = fc.position();
+        // We pad the file in 1M chunks to avoid syncing to
+        // write the new filesize.
+        if (position + 4096 >= fileSize) {
+            fileSize = fileSize + preAllocSize;
+            fill.position(0);
+            fc.write(fill, fileSize);
+        }
+        return fileSize;
+    }
+
+    public void run() {
+        try {
+            long fileSize = 0;
+            long lastZxidSeen = -1;
+            FileChannel fc = null;
+            while (true) {
+                Request si = null;
+                if (toFlush.isEmpty()) {
+                    si = queuedRequests.take();
+                } else {
+                    si = queuedRequests.poll();
+                    if (si == null) {
+                        flush(toFlush);
+                        continue;
+                    }
+                }
+                if (si == requestOfDeath) {
+                    break;
+                }
+                if (si != null) {
+                    // LOG.warn(""Sync>>> cxid = "" + si.cxid + "" type = "" +
+                    // si.type + "" id = "" + si.sessionId + "" zxid = "" +
+                    // Long.toHexString(si.zxid));
+                    ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,
+                            'S', si, """");
+                    TxnHeader hdr = si.hdr;
+                    if (hdr != null) {
+                        if (hdr.getZxid() <= lastZxidSeen) {
+                            LOG.warn(""Current zxid "" + hdr.getZxid()
+                                    + "" is <= "" + lastZxidSeen + "" for ""
+                                    + hdr.getType());
+                        }
+                        Record txn = si.txn;
+                        if (logStream == null) {
+                            fileSize = 0;
+                            logStream = new FileOutputStream(new File(
+                                    zks.dataLogDir, ZooKeeperServer
+                                            .getLogName(hdr.getZxid())));
+                            synchronized (streamsToFlush) {
+                                streamsToFlush.add(logStream);
+                            }
+                            fc = logStream.getChannel();
+                            logArchive = BinaryOutputArchive
+                                    .getArchive(logStream);
+                        }
+                        final long fsize=fileSize;
+                        final FileChannel ffc=fc;
+                        fileSize = Profiler.profile(
+                            new Profiler.Operation<Long>() {
+                                public Long execute() throws Exception {
+                                    return SyncRequestProcessor.this
+                                            .padLogFile(ffc, fsize);
+                                }
+                            }, PADDING_TIMEOUT,
+                            ""Logfile padding exceeded time threshold""
+                        );
+                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                        BinaryOutputArchive boa = BinaryOutputArchive
+                                .getArchive(baos);
+                        hdr.serialize(boa, ""hdr"");
+                        if (txn != null) {
+                            txn.serialize(boa, ""txn"");
+                        }
+                        logArchive.writeBuffer(baos.toByteArray(), ""txnEntry"");
+                        logArchive.writeByte((byte) 0x42, ""EOR"");
+                        logCount++;
+                        if (logCount > snapCount / 2
+                                && r.nextInt(snapCount / 2) == 0) {
+                            // We just want one snapshot going at a time
+                            if (snapInProcess != null
+                                    && snapInProcess.isAlive()) {
+                                LOG.warn(""Too busy to snap, skipping"");
+                            } else {
+                                logStream = null;
+                                logArchive = null;
+                                snapInProcess = new Thread() {
+                                    public void run() {
+                                        try {
+                                            zks.snapshot();
+                                        } catch (Exception e) {
+                                            LOG.warn(""Unexpected exception"",e);
+                                        }
+                                    }
+                                };
+                                snapInProcess.start();
+                            }
+                            logCount = 0;
+                        }
+                    }
+                    toFlush.add(si);
+                    if (toFlush.size() > 1000) {
+                        flush(toFlush);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            LOG.error(""Severe error, exiting"",e);
+            System.exit(11);
+        }
+        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     ""SyncRequestProcessor exiyed!"");
+    }
+
+    private void flush(LinkedList<Request> toFlush) throws IOException {
+        if (toFlush.size() == 0) {
+            return;
+        }
+
+        LinkedList<FileOutputStream> streamsToFlushNow;
+        synchronized (streamsToFlush) {
+            streamsToFlushNow = (LinkedList<FileOutputStream>) streamsToFlush
+                    .clone();
+        }
+        for (FileOutputStream fos : streamsToFlushNow) {
+            fos.flush();
+            if (forceSync) {
+                ((FileChannel) fos.getChannel()).force(false);
+            }
+        }
+        while (streamsToFlushNow.size() > 1) {
+            FileOutputStream fos = streamsToFlushNow.removeFirst();
+            fos.close();
+            synchronized (streamsToFlush) {
+                streamsToFlush.remove(fos);
+            }
+        }
+        while (toFlush.size() > 0) {
+            Request i = toFlush.remove();
+            nextProcessor.processRequest(i);
+        }
+    }
+
+    public void shutdown() {
+        timeToDie = true;
+        queuedRequests.add(requestOfDeath);
+        nextProcessor.shutdown();
+    }
+
+    public void processRequest(Request request) {
+        // request.addRQRec("">sync"");
+        queuedRequests.add(request);
+    }
+
+}
",,6461
2389,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,98,4ae2225de1a170f00d0ea961baa36e783a9f3741,1319819863,99,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,-1,1214334298/1214327670,"                            nextPending = null;","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.zookeeper.server.quorum;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-
-import org.apache.log4j.Logger;
-
-import org.apache.zookeeper.ZooDefs.OpCode;
-import org.apache.zookeeper.server.Request;
-import org.apache.zookeeper.server.RequestProcessor;
-import org.apache.zookeeper.server.ZooTrace;
-
-/**
- * This RequestProcessor matches the incoming committed requests with the
- * locally submitted requests. The trick is that locally submitted requests that
- * change the state of the system will come back as incoming committed requests,
- * so we need to match them up.
- */
-public class CommitProcessor extends Thread implements RequestProcessor {
-    private static final Logger LOG = Logger.getLogger(CommitProcessor.class);
-
-    /**
-     * Requests that we are holding until the commit comes in.
-     */
-    LinkedList<Request> queuedRequests = new LinkedList<Request>();
-
-    /**
-     * Requests that have been committed.
-     */
-    LinkedList<Request> committedRequests = new LinkedList<Request>();
-
-    /*
-     * Pending sync requests
-     */
-    LinkedList<Request> pendingSyncs = new LinkedList<Request>();
-
-    RequestProcessor nextProcessor;
-
-    public CommitProcessor(RequestProcessor nextProcessor) {
-        this.nextProcessor = nextProcessor;
-        start();
-    }
-
-    boolean finished = false;
-
-    public void run() {
-        try {
-            Request nextPending = null;
-            ArrayList<Request> toProcess = new ArrayList<Request>();
-            while (!finished) {
-                int len = toProcess.size();
-                for (int i = 0; i < len; i++) {
-                    nextProcessor.processRequest(toProcess.get(i));
-                }
-                toProcess.clear();
-                synchronized (this) {
-                    if ((queuedRequests.size() == 0 || nextPending != null)
-                            && committedRequests.size() == 0) {
-                        wait();
-                        continue;
-                    }
-                    // First check and see if the commit came in for the pending
-                    // request
-                    if ((queuedRequests.size() == 0 || nextPending != null)
-                            && committedRequests.size() > 0) {
-                        Request r = committedRequests.remove();
-                        /*
-                         * We match with nextPending so that we can move to the
-                         * next request when it is committed. We also want to
-                         * use nextPending because it has the cnxn member set
-                         * properly.
-                         */
-                        if (nextPending != null
-                                && nextPending.sessionId == r.sessionId
-                                && nextPending.cxid == r.cxid) {
-                            // we want to send our version of the request.
-                            // the pointer to the connection in the request
-                            nextPending.hdr = r.hdr;
-                            nextPending.txn = r.txn;
-                            nextPending.zxid = r.zxid;
-                            toProcess.add(nextPending);
-                            nextPending = null;
-                        } else {
-                            // this request came from someone else so just
-                            // send the commit packet
-                            toProcess.add(r);
-                        }
-                    }
-                }
-
-                // We haven't matched the pending requests, so go back to
-                // waiting
-                if (nextPending != null) {
-                    continue;
-                }
-
-                synchronized (this) {
-                    // Process the next requests in the queuedRequests
-                    while (nextPending == null && queuedRequests.size() > 0) {
-                        Request request = queuedRequests.remove();
-                        switch (request.type) {
-                        case OpCode.create:
-                        case OpCode.delete:
-                        case OpCode.setData:
-                        case OpCode.setACL:
-                        case OpCode.createSession:
-                        case OpCode.closeSession:
-                            nextPending = request;
-                            break;
-                        case OpCode.sync:
-                            nextPending = request;
-                            pendingSyncs.add(request);
-                            break;
-                        default:
-                            toProcess.add(request);
-                        }
-                    }
-                }
-            }
-        } catch (Exception e) {
-            LOG.error(""FIXMSG"",e);
-        }
-        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                 ""CommitProcessor exited loop!"");
-    }
-
-    synchronized public void commit(Request request) {
-        if (!finished) {
-            if (request == null) {
-                LOG.warn(""Committed a null!"",
-                         new Exception(""committing a null! ""));
-                return;
-            }
-            committedRequests.add(request);
-            notifyAll();
-        }
-    }
-
-    synchronized public void processRequest(Request request) {
-        // request.addRQRec("">commit"");
-        // LOG.info(""Zoo processReq>>> cxid = "" + request.cxid + "" type =
-        // "" + request.type + "" id = "" + request.sessionId + "" cnxn "" +
-        // request.cnxn);
-        if (!finished) {
-            queuedRequests.add(request);
-            notifyAll();
-        }
-    }
-
-    public void shutdown() {
-        finished = true;
-        queuedRequests.clear();
-        synchronized (this) {
-            notifyAll();
-        }
-        nextProcessor.shutdown();
-    }
-
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+
+import org.apache.log4j.Logger;
+
+import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.RequestProcessor;
+import org.apache.zookeeper.server.ZooTrace;
+
+/**
+ * This RequestProcessor matches the incoming committed requests with the
+ * locally submitted requests. The trick is that locally submitted requests that
+ * change the state of the system will come back as incoming committed requests,
+ * so we need to match them up.
+ */
+public class CommitProcessor extends Thread implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(CommitProcessor.class);
+
+    /**
+     * Requests that we are holding until the commit comes in.
+     */
+    LinkedList<Request> queuedRequests = new LinkedList<Request>();
+
+    /**
+     * Requests that have been committed.
+     */
+    LinkedList<Request> committedRequests = new LinkedList<Request>();
+
+    /*
+     * Pending sync requests
+     */
+    LinkedList<Request> pendingSyncs = new LinkedList<Request>();
+
+    RequestProcessor nextProcessor;
+
+    public CommitProcessor(RequestProcessor nextProcessor) {
+        this.nextProcessor = nextProcessor;
+        start();
+    }
+
+    boolean finished = false;
+
+    public void run() {
+        try {
+            Request nextPending = null;
+            ArrayList<Request> toProcess = new ArrayList<Request>();
+            while (!finished) {
+                int len = toProcess.size();
+                for (int i = 0; i < len; i++) {
+                    nextProcessor.processRequest(toProcess.get(i));
+                }
+                toProcess.clear();
+                synchronized (this) {
+                    if ((queuedRequests.size() == 0 || nextPending != null)
+                            && committedRequests.size() == 0) {
+                        wait();
+                        continue;
+                    }
+                    // First check and see if the commit came in for the pending
+                    // request
+                    if ((queuedRequests.size() == 0 || nextPending != null)
+                            && committedRequests.size() > 0) {
+                        Request r = committedRequests.remove();
+                        /*
+                         * We match with nextPending so that we can move to the
+                         * next request when it is committed. We also want to
+                         * use nextPending because it has the cnxn member set
+                         * properly.
+                         */
+                        if (nextPending != null
+                                && nextPending.sessionId == r.sessionId
+                                && nextPending.cxid == r.cxid) {
+                            // we want to send our version of the request.
+                            // the pointer to the connection in the request
+                            nextPending.hdr = r.hdr;
+                            nextPending.txn = r.txn;
+                            nextPending.zxid = r.zxid;
+                            toProcess.add(nextPending);
+                            nextPending = null;
+                        } else {
+                            // this request came from someone else so just
+                            // send the commit packet
+                            toProcess.add(r);
+                        }
+                    }
+                }
+
+                // We haven't matched the pending requests, so go back to
+                // waiting
+                if (nextPending != null) {
+                    continue;
+                }
+
+                synchronized (this) {
+                    // Process the next requests in the queuedRequests
+                    while (nextPending == null && queuedRequests.size() > 0) {
+                        Request request = queuedRequests.remove();
+                        switch (request.type) {
+                        case OpCode.create:
+                        case OpCode.delete:
+                        case OpCode.setData:
+                        case OpCode.setACL:
+                        case OpCode.createSession:
+                        case OpCode.closeSession:
+                            nextPending = request;
+                            break;
+                        case OpCode.sync:
+                            nextPending = request;
+                            pendingSyncs.add(request);
+                            break;
+                        default:
+                            toProcess.add(request);
+                        }
+                    }
+                }
+            }
+        } catch (Exception e) {
+            LOG.error(""FIXMSG"",e);
+        }
+        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                 ""CommitProcessor exited loop!"");
+    }
+
+    synchronized public void commit(Request request) {
+        if (!finished) {
+            if (request == null) {
+                LOG.warn(""Committed a null!"",
+                         new Exception(""committing a null! ""));
+                return;
+            }
+            committedRequests.add(request);
+            notifyAll();
+        }
+    }
+
+    synchronized public void processRequest(Request request) {
+        // request.addRQRec("">commit"");
+        // LOG.info(""Zoo processReq>>> cxid = "" + request.cxid + "" type =
+        // "" + request.type + "" id = "" + request.sessionId + "" cnxn "" +
+        // request.cnxn);
+        if (!finished) {
+            queuedRequests.add(request);
+            notifyAll();
+        }
+    }
+
+    public void shutdown() {
+        finished = true;
+        queuedRequests.clear();
+        synchronized (this) {
+            notifyAll();
+        }
+        nextProcessor.shutdown();
+    }
+
+}
",,6461
2390,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,493,51dd9c039f70da96b4a5755f372ffcdc8009824b,1287527529,522,,,,,"            recvWorker = null;",,,6461
2391,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,67c653cf38015db23940c4229ea66509cbd2b2be,1214327670,543,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,504,,,,,"                        recvWorker = null;",,,6461
2392,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/com/apache/zookeeper/test/AsyncTest.java,94ea75adeca9109d127735fd00138e530770552c,1214327720,58,,,,,,,,"        clientConnected=null;",,,6461
2393,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/com/apache/zookeeper/test/ClientTest.java,94ea75adeca9109d127735fd00138e530770552c,1214327720,40,,,,,,,,"        clientConnected = null;",,,6461
2394,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/com/apache/zookeeper/test/DataTreeTest.java,94ea75adeca9109d127735fd00138e530770552c,1214327720,38,,,,,,,,"        dt=null;",,,6461
2395,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncTest.java,f1e02be300aee5e0174419526c697b5bdf7da4eb,1214327761,58,31d99a300ad9b0c66905333c7775321a58345ed6,1216165771,76,435bc0ff5db851d341c373bc515f6a618691e6c4,1218837748,-1,1218837748/1214327761,"        clientConnected=null;"," import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.proto.WatcherEvent;
-import org.apache.zookeeper.server.NIOServerCnxn;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
-public class AsyncTest extends TestCase implements Watcher, StringCallback, VoidCallback, DataCallback {
+public class AsyncTest extends TestCase
+    implements Watcher, StringCallback, VoidCallback, DataCallback
+{
     private static final Logger LOG = Logger.getLogger(AsyncTest.class);
 
-    private static final int CONNECTION_TIMEOUT=30000;
-    protected static String hostPort = ""127.0.0.1:33221"";
-    LinkedBlockingQueue<WatcherEvent> events = new LinkedBlockingQueue<WatcherEvent>();
-    static File baseTest = new File(System.getProperty(""build.test.dir"", ""build""));
-    NIOServerCnxn.Factory f = null;
-    QuorumTest qt = new QuorumTest();
+    private QuorumTest quorumTest = new QuorumTest();
     private CountDownLatch clientConnected;
 
+    private volatile boolean bang;
+
     @Before
+    @Override
     protected void setUp() throws Exception {
-        qt.setUp();
-        hostPort = ClientTest.hostPort;
+        LOG.info(""STARTING "" + getName());
+        
+        ClientBase.setupTestEnv();
+
+        quorumTest.setUp();
     }
 
     protected void restart() throws Exception {
-        qt.startServers();
+        quorumTest.startServers();
     }
 
     @After
+    @Override
     protected void tearDown() throws Exception {
-        qt.tearDown();
-        LOG.error(""Client test shutdown"");
-        if (f != null) {
-            f.shutdown();
-        }
-        clientConnected=null;
-        LOG.error(""Client test shutdown finished"");
+        LOG.info(""Test clients shutting down"");
+        clientConnected = null;
+        quorumTest.tearDown();
+        LOG.info(""FINISHED "" + getName());
     }
 
-    private ZooKeeper createClient() throws IOException,InterruptedException{
-        clientConnected=new CountDownLatch(1);
-        ZooKeeper zk = new ZooKeeper(hostPort, 30000, this);
+    private ZooKeeper createClient() throws IOException,InterruptedException {
+        return createClient(quorumTest.hostPort);
+    }
+
+    private ZooKeeper createClient(String hp)
+        throws IOException, InterruptedException
+    {
+        clientConnected = new CountDownLatch(1);
+        ZooKeeper zk = new ZooKeeper(hp, 30000, this);
         if(!clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)){
             fail(""Unable to connect to server"");
         }
         return zk;
     }
 
-    boolean bang;
+    /**
+     * Create /test- sequence nodes asynchronously, max 30 outstanding
+     */
+    class HammerThread extends Thread
+        implements Watcher, StringCallback, VoidCallback
+    {
+        private static final int MAX_OUTSTANDING = 30;
 
-    class HammerThread extends Thread implements Watcher, StringCallback, VoidCallback {
-        ZooKeeper zk;
+        private ZooKeeper zk;
+        private int outstanding;
+
+        public HammerThread(String name) {
+            super(name);
+        }
+
         public void run() {
-        try {
-            zk = new ZooKeeper(hostPort, 30000, this);
-            while(bang) {
-                zk.create(""/test-"", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateFlags.SEQUENCE, this, null);
-                incOut();
+            try {
+                zk = new ZooKeeper(quorumTest.hostPort, 30000, this);
+                while(bang) {
+                    incOutstanding(); // before create otw race
+                    zk.create(""/test-"", new byte[0], Ids.OPEN_ACL_UNSAFE,
+                            CreateFlags.SEQUENCE, this, null);
+                }
+            } catch (InterruptedException e) {
+                if (bang) {
+                    LOG.error(""sanity check failed!!!""); // sanity check
+                    return;
+                }
+            } catch (Exception e) {
+                LOG.error(""Client create operation failed"", e);
+                return;
+            } finally {
+                if (zk != null) {
+                    try {
+                        zk.close();
+                    } catch (InterruptedException e) {
+                        LOG.warn(""Unexpected"", e);
+                    }
+                }
             }
-        } catch (Exception e) {
-            e.printStackTrace();
         }
-        }
-        int outstanding;
-        synchronized void incOut() throws InterruptedException {
+
+        private synchronized void incOutstanding() throws InterruptedException {
             outstanding++;
-            while(outstanding > 30) {
+            while(outstanding > MAX_OUTSTANDING) {
                 wait();
             }
         }
-        synchronized void decOut() {
+
+        private synchronized void decOutstanding() {
             outstanding--;
+            assertTrue(""outstanding >= 0"", outstanding >= 0);
             notifyAll();
         }
 
         public void process(WatcherEvent event) {
+            // ignore for purposes of this test
         }
 
         public void processResult(int rc, String path, Object ctx, String name) {
             try {
-                decOut();
+                decOutstanding();
                 zk.delete(path, -1, this, null);
             } catch (Exception e) {
-                e.printStackTrace();
+                LOG.error(""Client delete failed"", e);
             }
         }
 
         public void processResult(int rc, String path, Object ctx) {
+            // ignore for purposes of this test
         }
     }
 
     @Test
     public void testHammer() throws Exception {
-        Thread.sleep(1000);
         bang = true;
-        for (int i = 0; i < 100; i++) {
-            new HammerThread().start();
+        Thread[] hammers = new Thread[100];
+        for (int i = 0; i < hammers.length; i++) {
+            hammers[i] = new HammerThread(""HammerThread-"" + i);
+            hammers[i].start();
         }
-        Thread.sleep(5000);
-        tearDown();
+        Thread.sleep(5000); // allow the clients to run for max 5sec
         bang = false;
-        restart();
-        Thread.sleep(5000);
-        String parts[] = hostPort.split("","");
-        String prevList[] = null;
-        for (String hp : parts) {
-            ZooKeeper zk = createClient();
-            String list[] = zk.getChildren(""/"", false).toArray(new String[0]);
-            if (prevList != null) {
-                assertEquals(prevList.length, list.length);
-                for (int i = 0; i < list.length; i++) {
-                    assertEquals(prevList[i], list[i]);
-                }
-            }
-            prevList = list;
+        for (int i = 0; i < hammers.length; i++) {
+            hammers[i].interrupt();
+            verifyThreadTerminated(hammers[i], 60000);
         }
+        // before restart
+        quorumTest.verifyRootOfAllServersMatch(quorumTest.hostPort);
+        tearDown();
+
+        restart();
+
+        // after restart
+        quorumTest.verifyRootOfAllServersMatch(quorumTest.hostPort);
     }
 
     LinkedList<Integer> results = new LinkedList<Integer>();
     @Test
-    public void testAsync() throws IOException,
-            InterruptedException, KeeperException {
+    public void testAsync()
+        throws IOException, InterruptedException, KeeperException
+    {
         ZooKeeper zk = null;
         zk = createClient();
-        zk.addAuthInfo(""digest"", ""ben:passwd"".getBytes());
-        zk.create(""/ben"", new byte[0], Ids.READ_ACL_UNSAFE, 0, this, results);
-        zk.create(""/ben/2"", new byte[0], Ids.CREATOR_ALL_ACL, 0, this, results);
-        zk.delete(""/ben"", -1, this, results);
-        zk.create(""/ben2"", new byte[0], Ids.CREATOR_ALL_ACL, 0, this, results);
-        zk.getData(""/ben2"", false, this, results);
-        synchronized (results) {
-            while (results.size() < 5) {
-                results.wait();
-            }
-        }
-        assertEquals(0, (int) results.get(0));
-        assertEquals(Code.NoAuth, (int) results.get(1));
-        assertEquals(0, (int) results.get(2));
-        assertEquals(0, (int) results.get(3));
-        assertEquals(0, (int) results.get(4));
-        zk.close();
-
-        zk =createClient();
-        zk.addAuthInfo(""digest"", ""ben:passwd2"".getBytes());
         try {
-            zk.getData(""/ben2"", false, new Stat());
-            fail(""Should have received a permission error"");
-        } catch (KeeperException e) {
-            assertEquals(Code.NoAuth, e.getCode());
+            zk.addAuthInfo(""digest"", ""ben:passwd"".getBytes());
+            zk.create(""/ben"", new byte[0], Ids.READ_ACL_UNSAFE, 0, this, results);
+            zk.create(""/ben/2"", new byte[0], Ids.CREATOR_ALL_ACL, 0, this, results);
+            zk.delete(""/ben"", -1, this, results);
+            zk.create(""/ben2"", new byte[0], Ids.CREATOR_ALL_ACL, 0, this, results);
+            zk.getData(""/ben2"", false, this, results);
+            synchronized (results) {
+                while (results.size() < 5) {
+                    results.wait();
+                }
+            }
+            assertEquals(0, (int) results.get(0));
+            assertEquals(Code.NoAuth, (int) results.get(1));
+            assertEquals(0, (int) results.get(2));
+            assertEquals(0, (int) results.get(3));
+            assertEquals(0, (int) results.get(4));
+        } finally {
+            zk.close();
         }
-        zk.close();
 
-        zk =createClient();
-        zk.addAuthInfo(""digest"", ""ben:passwd"".getBytes());
-        zk.getData(""/ben2"", false, new Stat());
-        zk.close();
+        zk = createClient();
+        try {
+            zk.addAuthInfo(""digest"", ""ben:passwd2"".getBytes());
+            try {
+                zk.getData(""/ben2"", false, new Stat());
+                fail(""Should have received a permission error"");
+            } catch (KeeperException e) {
+                assertEquals(Code.NoAuth, e.getCode());
+            }
+        } finally {
+            zk.close();
+        }
+
+        zk = createClient();
+        try {
+            zk.addAuthInfo(""digest"", ""ben:passwd"".getBytes());
+            zk.getData(""/ben2"", false, new Stat());
+        } finally {
+            zk.close();
+        }
     }
 
     public void process(WatcherEvent event) {
",,6461
2396,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientTest.java,f1e02be300aee5e0174419526c697b5bdf7da4eb,1214327761,40,435bc0ff5db851d341c373bc515f6a618691e6c4,1218837748,72,e3e0db789177a2e77882545dbdd9eed9a23eb392,1219880200,-1,1219880200/1214327761,"        clientConnected = null;"," import org.apache.zookeeper.proto.WatcherEvent;
 import org.junit.Test;
 
-public class ClientTest extends ClientBase implements Watcher {
+public class ClientTest extends ClientBase {
     protected static final Logger LOG = Logger.getLogger(ClientTest.class);
 
     LinkedBlockingQueue<WatcherEvent> events =
         new LinkedBlockingQueue<WatcherEvent>();
-    protected volatile CountDownLatch clientConnected;
-
-    protected ZooKeeper createClient(Watcher watcher)
-        throws IOException, InterruptedException
-    {
-        return createClient(watcher, hostPort);
-    }
-
-    protected ZooKeeper createClient(Watcher watcher, String hp)
-        throws IOException, InterruptedException
-    {
-        clientConnected = new CountDownLatch(1);
-        ZooKeeper zk = new ZooKeeper(hp, 20000, watcher);
-        if (!clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {
-            fail(""Unable to connect to server"");
-        }
-        return zk;
-    }
 
     @Override
     protected void tearDown() throws Exception {
-        clientConnected = null;
         super.tearDown();
         LOG.info(""FINISHED "" + getName());
     }
",,6461
2397,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/DataTreeTest.java,f1e02be300aee5e0174419526c697b5bdf7da4eb,1214327761,38,62dcea67c7a3d12bdb5fa014936f465fadb1e3df,1378417808,54,,,,,"        dt=null;",,,6461
2398,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,1da34580995bbce1cc56d2a7f822aa55e169670c,1214328912,91,,,,,,,,"            svrBean=null;",,,6461
2399,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,1da34580995bbce1cc56d2a7f822aa55e169670c,1214328912,98,,,,,,,,"            leBean=null;",,,6461
2400,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,1da34580995bbce1cc56d2a7f822aa55e169670c,1214328912,114,,,,,,,,"            svrBean=null;",,,6461
2401,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,1da34580995bbce1cc56d2a7f822aa55e169670c,1214328912,121,,,,,,,,"            leBean=null;",,,6461
2402,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/com/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,1da34580995bbce1cc56d2a7f822aa55e169670c,1214328912,180,,,,,,,,"            dataTreeBean=null;",,,6461
2403,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/org/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,98b153609b00157bb02ba75814f49a9bd46dc26d,1214328931,91,0c6294e6cab2befc330b8a5c05ceeb156550c2fe,1222850402,96,,,,,"            svrBean=null;",,,6461
2404,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/org/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,98b153609b00157bb02ba75814f49a9bd46dc26d,1214328931,98,0c6294e6cab2befc330b8a5c05ceeb156550c2fe,1222850402,103,,,,,"            leBean=null;",,,6461
2405,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/org/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,98b153609b00157bb02ba75814f49a9bd46dc26d,1214328931,114,0c6294e6cab2befc330b8a5c05ceeb156550c2fe,1222850402,119,,,,,"            svrBean=null;",,,6461
2406,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/org/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,98b153609b00157bb02ba75814f49a9bd46dc26d,1214328931,121,0c6294e6cab2befc330b8a5c05ceeb156550c2fe,1222850402,126,,,,,"            leBean=null;",,,6461
2407,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/jmx/org/apache/zookeeper/server/quorum/ManagedQuorumPeer.java,98b153609b00157bb02ba75814f49a9bd46dc26d,1214328931,180,0c6294e6cab2befc330b8a5c05ceeb156550c2fe,1222850402,185,,,,,"            dataTreeBean=null;",,,6461
2408,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,698,,,,,,,,"        sock = null;",,,6461
2409,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,194,,,,,,,,"                                logStream = null;",,,6461
2410,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,195,,,,,,,,"                                logArchive = null;",,,6461
2411,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java,0a81c16c4c921ef52179b943dd046fc72022ccc6,1214334298,100,,,,,,,,"                            nextPending = null;",,,6461
2412,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/DataTreeTest.java,31d99a300ad9b0c66905333c7775321a58345ed6,1216165771,41,,,,,,,,"        dt=null;",,,6461
2413,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncTest.java,435bc0ff5db851d341c373bc515f6a618691e6c4,1218837748,75,,,,e3e0db789177a2e77882545dbdd9eed9a23eb392,1219880200,-1,1219880200/1218837748,"        clientConnected = null;","     @Override
     protected void tearDown() throws Exception {
         LOG.info(""Test clients shutting down"");
-        clientConnected = null;
         quorumTest.tearDown();
         LOG.info(""FINISHED "" + getName());
     }
 
+    private static class CountdownWatcher implements Watcher {
+        volatile CountDownLatch clientConnected = new CountDownLatch(1);
+
+        public void process(WatcherEvent event) {
+            if (event.getState() == Event.KeeperStateSyncConnected) {
+                clientConnected.countDown();
+            }
+        }
+    }
+    
     private ZooKeeper createClient() throws IOException,InterruptedException {
         return createClient(quorumTest.hostPort);
     }
",,6461
2414,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,ada5b36e3683aadd061a9e3578c9b693f0b050ab,1220646020,176,71989813100ed91620ec18989cd2d0b1b7c8a9df,1395608611,162,,,,,"            name = null;",,,6461
2415,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,ada5b36e3683aadd061a9e3578c9b693f0b050ab,1220646020,358,97a8c5be83c4468cd67fa412b715cbb4f312885e,1355941010,484,,,,,"            data = null;",,,6461
2416,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,ada5b36e3683aadd061a9e3578c9b693f0b050ab,1220646020,359,71989813100ed91620ec18989cd2d0b1b7c8a9df,1395608611,487,,,,,"            stat = null;",,,6461
2417,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,ada5b36e3683aadd061a9e3578c9b693f0b050ab,1220646020,407,97a8c5be83c4468cd67fa412b715cbb4f312885e,1355941010,533,,,,,"            stat = null;",,,6461
2418,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,ada5b36e3683aadd061a9e3578c9b693f0b050ab,1220646020,422,97a8c5be83c4468cd67fa412b715cbb4f312885e,1355941010,552,,,,,"            stat = null;",,,6461
2419,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,ada5b36e3683aadd061a9e3578c9b693f0b050ab,1220646020,436,97a8c5be83c4468cd67fa412b715cbb4f312885e,1355941010,566,,,,,"            stat = null;",,,6461
2420,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,571,ad482ad24cc864686f268b71896606091d92a00f,1222452565,606,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2421,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,635,9398146ee65f798983a9938fb515620fdeb7da1b,1222378559,636,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2422,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,667,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2423,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,1222290326,897,ad482ad24cc864686f268b71896606091d92a00f,1222452565,934,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2424,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,0254f868ca34105308ac3524c73111d8d770091e,1222842407,108,9f7759d73f44901226873cdf2da685877fa06f62,1228946121,109,83cf0a93c37759334fab885c2010fa0b7d953f52,1235089420,-1,1235089420/1222842407,"        this.logStream = null;"," 
     /**
      * rollover the current log file to a new one.
+     * @throws IOException 
      */
-    public void rollLog() {
-        this.logStream = null;
-        oa = null;
+    public void rollLog() throws IOException {
+        if (logStream != null) {
+            this.logStream.flush();
+            this.logStream = null;
+            oa = null;
+        }
     }
 
     /**
",,6461
2425,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,0254f868ca34105308ac3524c73111d8d770091e,1222842407,109,9f7759d73f44901226873cdf2da685877fa06f62,1228946121,110,,,,,"        oa = null;",,,6461
2426,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,0254f868ca34105308ac3524c73111d8d770091e,1222842407,443,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,602,,,,,"                inputStream = null;",,,6461
2427,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/DataTreeUnitTest.java,0254f868ca34105308ac3524c73111d8d770091e,1222842407,36,eb51de49f723542a17e722fa817d81605a04c74c,1308844907,40,,,,,"        dt=null;",,,6461
2428,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,0c6294e6cab2befc330b8a5c05ceeb156550c2fe,1222850402,431,,,,,,,,"            recvWorker = null;",,,6461
2429,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,e99350dc11fb37dc17c92ffb95113a3a607d84b6,1224018586,94,257a00aa97cd21c967ad620c3119a86295f1b794,1330310507,105,,,,,"            this.electionAddr = null;",,,6461
2430,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/upgrade/DataTreeV1.java,82627a641750383bc7380c568291839bbea5c26e,1224202903,249,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,247,,,,,"            node.parent = null;",,,6461
2431,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/upgrade/DataTreeV1.java,82627a641750383bc7380c568291839bbea5c26e,1224202903,576,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,576,,,,,"        root = null;",,,6461
2432,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java,82627a641750383bc7380c568291839bbea5c26e,1224202903,280,eb51de49f723542a17e722fa817d81605a04c74c,1308844907,289,,,,,"            parent = null;",,,6461
2433,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,30c3c0eb55026bf73c6c6a87fe662ba458f67233,1224632985,653,a399144537dfef4468a96971641bc372a3d8a76f,1228176830,663,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2434,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,30c3c0eb55026bf73c6c6a87fe662ba458f67233,1224632985,716,a399144537dfef4468a96971641bc372a3d8a76f,1228176830,726,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2435,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,30c3c0eb55026bf73c6c6a87fe662ba458f67233,1224632985,978,a399144537dfef4468a96971641bc372a3d8a76f,1228176830,988,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2436,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,30c3c0eb55026bf73c6c6a87fe662ba458f67233,1224632985,735,82a9d1d0a24147dcb533542559d61783058f1a1b,1256944166,1052,,,,,"        root = null;",,,6461
2437,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,30c3c0eb55026bf73c6c6a87fe662ba458f67233,1224632985,304,b37b8d6713c630901e46f0191b205061c0273133,1246325531,333,,,,,"        serverFactory = null;",,,6461
2438,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,9f7759d73f44901226873cdf2da685877fa06f62,1228946121,450,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,603,,,,,"                ia = null;",,,6461
2439,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,e08ffda1b82a1f2e6232c6140fe38976c291e2fb,1229113290,448,c9e8662617ac5d99cc08f858c21dc9c4ba175881,1238796078,451,,,,,"            recvWorker = null;",,,6461
2440,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,e08ffda1b82a1f2e6232c6140fe38976c291e2fb,1229113290,501,,,,,,,,"                        recvWorker = null;",,,6461
2441,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,b833f9d0431ed1629ce018e0c29c03cf3c94b618,1229128042,640,c6639c9842973a7954c8baa412d6825cb833d51f,1232063304,641,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2442,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,b833f9d0431ed1629ce018e0c29c03cf3c94b618,1229128042,736,c6639c9842973a7954c8baa412d6825cb833d51f,1232063304,737,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2443,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,b833f9d0431ed1629ce018e0c29c03cf3c94b618,1229128042,767,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,880,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2444,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,b833f9d0431ed1629ce018e0c29c03cf3c94b618,1229128042,998,c6639c9842973a7954c8baa412d6825cb833d51f,1232063304,999,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2445,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,b833f9d0431ed1629ce018e0c29c03cf3c94b618,1229128042,1031,c6639c9842973a7954c8baa412d6825cb833d51f,1232063304,1032,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2446,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,720,cff0aedb1891cc1595cb19e28533f2b5c7a3e6a0,1242845280,764,,,,,"        jmxConnectionBean = null;",,,6461
2447,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,412,bb857582bab316abea48588375df98de51df9115,1359076658,435,,,,,"        jmxServerBean = null;",,,6461
2448,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,413,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,442,,,,,"        jmxDataTreeBean = null;",,,6461
2449,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,198,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,207,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2450,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,217,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,229,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,-1,1256919553/1232060234,"        jmxDataTreeBean = null;","                     e);
         }
     }
-
-
-    @Override
-    protected void registerJMX() {
-        // register with JMX
-        try {
-            jmxDataTreeBean = new DataTreeBean(dataTree);
-            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
-        } catch (Exception e) {
-            LOG.warn(""Failed to register with JMX"", e);
-            jmxDataTreeBean = null;
-        }
-    }
-
-    public void registerJMX(FollowerBean followerBean,
-            LocalPeerBean localPeerBean)
-    {
-        // register with JMX
-        if (self.jmxLeaderElectionBean != null) {
-            try {
-                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
-            } catch (Exception e) {
-                LOG.warn(""Failed to register with JMX"", e);
-            }
-            self.jmxLeaderElectionBean = null;
-        }
-
-        try {
-            jmxServerBean = followerBean;
-            MBeanRegistry.getInstance().register(followerBean, localPeerBean);
-        } catch (Exception e) {
-            LOG.warn(""Failed to register with JMX"", e);
-            jmxServerBean = null;
-        }
-    }
-
-    @Override
-    protected void unregisterJMX() {
-        // unregister from JMX
-        try {
-            if (jmxDataTreeBean != null) {
-                MBeanRegistry.getInstance().unregister(jmxDataTreeBean);
-            }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxDataTreeBean = null;
-    }
-
-    protected void unregisterJMX(Follower follower) {
-        // unregister from JMX
-        try {
-            if (jmxServerBean != null) {
-                MBeanRegistry.getInstance().unregister(jmxServerBean);
-            }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxServerBean = null;
-    }
     
     @Override
     public String getState() {
         return ""follower"";
     }
+
+    @Override
+    public Learner getLearner() {
+        return getFollower();
+    }
 }
",,6461
2451,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,229,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,241,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,-1,1256919553/1232060234,"        jmxServerBean = null;","                     e);
         }
     }
-
-
-    @Override
-    protected void registerJMX() {
-        // register with JMX
-        try {
-            jmxDataTreeBean = new DataTreeBean(dataTree);
-            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
-        } catch (Exception e) {
-            LOG.warn(""Failed to register with JMX"", e);
-            jmxDataTreeBean = null;
-        }
-    }
-
-    public void registerJMX(FollowerBean followerBean,
-            LocalPeerBean localPeerBean)
-    {
-        // register with JMX
-        if (self.jmxLeaderElectionBean != null) {
-            try {
-                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
-            } catch (Exception e) {
-                LOG.warn(""Failed to register with JMX"", e);
-            }
-            self.jmxLeaderElectionBean = null;
-        }
-
-        try {
-            jmxServerBean = followerBean;
-            MBeanRegistry.getInstance().register(followerBean, localPeerBean);
-        } catch (Exception e) {
-            LOG.warn(""Failed to register with JMX"", e);
-            jmxServerBean = null;
-        }
-    }
-
-    @Override
-    protected void unregisterJMX() {
-        // unregister from JMX
-        try {
-            if (jmxDataTreeBean != null) {
-                MBeanRegistry.getInstance().unregister(jmxDataTreeBean);
-            }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxDataTreeBean = null;
-    }
-
-    protected void unregisterJMX(Follower follower) {
-        // unregister from JMX
-        try {
-            if (jmxServerBean != null) {
-                MBeanRegistry.getInstance().unregister(jmxServerBean);
-            }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxServerBean = null;
-    }
     
     @Override
     public String getState() {
         return ""follower"";
     }
+
+    @Override
+    public Learner getLearner() {
+        return getFollower();
+    }
 }
",,6461
2452,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,108,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,144,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2453,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,127,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,166,,,,,"        jmxDataTreeBean = null;",,,6461
2454,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,139,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,178,,,,,"        jmxServerBean = null;",,,6461
2455,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,472,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,476,,,,,"            jmxQuorumBean = null;",,,6461
2456,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,da1e988798fd0336a893e16e94d699e6b156c941,1232060234,473,7d8d199a4662ab710c8f3a12745b86dbdb4c7520,1233270662,473,,,,,"            jmxLocalPeerBean = null;",,,6461
2457,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,c6639c9842973a7954c8baa412d6825cb833d51f,1232063304,496,,,,,,,,"                        recvWorker = null;",,,6461
2458,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8ad773d7da9f1802e2868207772b1ce1226d9a36,1233102114,657,,,,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2459,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8ad773d7da9f1802e2868207772b1ce1226d9a36,1233102114,690,,,,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2460,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8ad773d7da9f1802e2868207772b1ce1226d9a36,1233102114,753,,,,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2461,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8ad773d7da9f1802e2868207772b1ce1226d9a36,1233102114,784,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2462,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8ad773d7da9f1802e2868207772b1ce1226d9a36,1233102114,1015,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2463,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8ad773d7da9f1802e2868207772b1ce1226d9a36,1233102114,1048,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2464,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookKeeper.java,a1ac465be361ff478f9b66147731e588fef64ff3,1233343827,346,9bdd8cf6378245a36531d071f68cf58898e5cca6,1240003710,349,e1a1ee81f1aa930cae20fa3fc76485e45a95f066,1264547805,-1,1264547805/1233343827,"        stat = null;","  * 
  */
 
-
 import java.io.IOException;
-import java.net.ConnectException;
-import java.nio.ByteBuffer;
-import java.nio.channels.UnresolvedAddressException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.HashMap;
-import java.util.Random;
-import java.net.InetSocketAddress;
-
+import java.util.concurrent.Executors;
 import org.apache.bookkeeper.client.BKException;
-import org.apache.bookkeeper.client.BookieHandle;
-import org.apache.bookkeeper.client.LedgerSequence;
 import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;
 import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;
 import org.apache.bookkeeper.client.BKException.Code;
-import org.apache.bookkeeper.client.LedgerHandle.QMode;
-import org.apache.bookkeeper.client.LedgerManagementProcessor.CreateLedgerOp;
-import org.apache.bookkeeper.client.LedgerManagementProcessor.OpenLedgerOp;
+import org.apache.bookkeeper.client.SyncCounter;
+import org.apache.bookkeeper.proto.BookieClient;
+import org.apache.bookkeeper.util.OrderedSafeExecutor;
 import org.apache.log4j.Logger;
 
-import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.CreateMode;
-import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.WatchedEvent;
-
+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
 
 /**
- * BookKeeper client. We assume there is one single writer 
- * to a ledger at any time. 
+ * BookKeeper client. We assume there is one single writer to a ledger at any
+ * time.
  * 
- * There are three possible operations: start a new ledger, 
- * write to a ledger, and read from a ledger.
+ * There are three possible operations: start a new ledger, write to a ledger,
+ * and read from a ledger.
  * 
- * For the ZooKeeper layout, please refer to BKDefs.java.
+ * The exceptions resulting from synchronous calls and error code resulting from
+ * asynchronous calls can be found in the class {@link BKException}.
+ * 
  * 
  */
 
-public class BookKeeper 
-implements Watcher {
- 
-    Logger LOG = Logger.getLogger(BookKeeper.class);
-    
-    ZooKeeper zk = null;
-    
+public class BookKeeper implements OpenCallback, CreateCallback {
+
+  static final Logger LOG = Logger.getLogger(BookKeeper.class);
+
+  ZooKeeper zk = null;
+  // whether the zk handle is one we created, or is owned by whoever
+  // instantiated us
+  boolean ownZKHandle = false;
+
+  ClientSocketChannelFactory channelFactory;
+  // whether the socket factory is one we created, or is owned by whoever
+  // instantiated us
+  boolean ownChannelFactory = false;
+
+  BookieClient bookieClient;
+  BookieWatcher bookieWatcher;
+
+  OrderedSafeExecutor callbackWorker = new OrderedSafeExecutor(Runtime
+      .getRuntime().availableProcessors());
+  OrderedSafeExecutor mainWorkerPool = new OrderedSafeExecutor(Runtime
+      .getRuntime().availableProcessors());
+
+  /**
+   * Create a bookkeeper client. A zookeeper client and a client socket factory
+   * will be instantiated as part of this constructor.
+   * 
+   * @param servers
+   *          A list of one of more servers on which zookeeper is running. The
+   *          client assumes that the running bookies have been registered with
+   *          zookeeper under the path
+   *          {@link BookieWatcher#BOOKIE_REGISTRATION_PATH}
+   * @throws IOException
+   * @throws InterruptedException
+   * @throws KeeperException
+   */
+  public BookKeeper(String servers) throws IOException, InterruptedException,
+      KeeperException {
+    this(new ZooKeeper(servers, 10000, new Watcher() {
+      @Override
+      public void process(WatchedEvent event) {
+        // TODO: handle session disconnects and expires
+        if (LOG.isDebugEnabled()) {
+          LOG.debug(""Process: "" + event.getType() + "" "" + event.getPath());
+        }
+      }
+    }), new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),
+        Executors.newCachedThreadPool()));
+
+    ownZKHandle = true;
+    ownChannelFactory = true;
+  }
+
+  /**
+   * Create a bookkeeper client but use the passed in zookeeper client instead
+   * of instantiating one.
+   * 
+   * @param zk
+   *          Zookeeper client instance connected to the zookeeper with which
+   *          the bookies have registered
+   * @throws InterruptedException
+   * @throws KeeperException
+   */
+  public BookKeeper(ZooKeeper zk) throws InterruptedException, KeeperException {
+    this(zk, new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),
+        Executors.newCachedThreadPool()));
+    ownChannelFactory = true;
+  }
+
+  /**
+   * Create a bookkeeper client but use the passed in zookeeper client and
+   * client socket channel factory instead of instantiating those.
+   * 
+   * @param zk
+   *          Zookeeper client instance connected to the zookeeper with which
+   *          the bookies have registered
+   * @param channelFactory
+   *          A factory that will be used to create connections to the bookies
+   * @throws InterruptedException
+   * @throws KeeperException
+   */
+  public BookKeeper(ZooKeeper zk, ClientSocketChannelFactory channelFactory)
+      throws InterruptedException, KeeperException {
+    if (zk == null || channelFactory == null) {
+      throw new NullPointerException();
+    }
+    this.zk = zk;
+    this.channelFactory = channelFactory;
+    bookieWatcher = new BookieWatcher(this);
+    bookieWatcher.readBookiesBlocking();
+    bookieClient = new BookieClient(channelFactory, mainWorkerPool);
+  }
+
+  /**
+   * There are 2 digest types that can be used for verification. The CRC32 is
+   * cheap to compute but does not protect against byzantine bookies (i.e., a
+   * bookie might report fake bytes and a matching CRC32). The MAC code is more
+   * expensive to compute, but is protected by a password, i.e., a bookie can't
+   * report fake bytes with a mathching MAC unless it knows the password
+   */
+  public enum DigestType {
+    MAC, CRC32
+  };
+
+  public ZooKeeper getZkHandle() {
+    return zk;
+  }
+
+  /**
+   * Creates a new ledger asynchronously. To create a ledger, we need to specify
+   * the ensemble size, the quorum size, the digest type, a password, a callback
+   * implementation, and an optional control object. The ensemble size is how
+   * many bookies the entries should be striped among and the quorum size is the
+   * degree of replication of each entry. The digest type is either a MAC or a
+   * CRC. Note that the CRC option is not able to protect a client against a
+   * bookie that replaces an entry. The password is used not only to
+   * authenticate access to a ledger, but also to verify entries in ledgers.
+   * 
+   * @param ensSize
+   *          ensemble size
+   * @param qSize
+   *          quorum size
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @param cb
+   *          createCallback implementation
+   * @param ctx
+   *          optional control object
+   */
+  public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType,
+      byte[] passwd, CreateCallback cb, Object ctx) {
+
+    new LedgerCreateOp(this, ensSize, qSize, digestType, passwd, cb, ctx)
+        .initiate();
+
+  }
+
+  /**
+   * Create callback implementation for synchronous create call.
+   * 
+   * @param rc
+   *          return code
+   * @param lh
+   *          ledger handle object
+   * @param ctx
+   *          optional control object
+   */
+  public void createComplete(int rc, LedgerHandle lh, Object ctx) {
+    SyncCounter counter = (SyncCounter) ctx;
+    counter.setLh(lh);
+    counter.setrc(rc);
+    counter.dec();
+  }
+
+  /**
+   * Creates a new ledger. Default of 3 servers, and quorum of 2 servers.
+   * 
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @return
+   * @throws KeeperException
+   * @throws InterruptedException
+   * @throws BKException
+   */
+  public LedgerHandle createLedger(DigestType digestType, byte passwd[])
+      throws KeeperException, BKException, InterruptedException, IOException {
+    return createLedger(3, 2, digestType, passwd);
+  }
+
+  /**
+   * Synchronous call to create ledger. Parameters match those of
+   * {@link #asyncCreateLedger(int, int, DigestType, byte[], CreateCallback, Object)}
+   * 
+   * @param ensSize
+   * @param qSize
+   * @param digestType
+   * @param passwd
+   * @return
+   * @throws KeeperException
+   * @throws InterruptedException
+   * @throws IOException
+   * @throws BKException
+   */
+  public LedgerHandle createLedger(int ensSize, int qSize,
+      DigestType digestType, byte passwd[]) throws KeeperException,
+      InterruptedException, IOException, BKException {
+    SyncCounter counter = new SyncCounter();
+    counter.inc();
     /*
-     * The ledgerMngProcessor is a thread that processes
-     * asynchronously requests that handle ledgers, such
-     * as create, open, and close.
+     * Calls asynchronous version
      */
-    private static LedgerManagementProcessor ledgerMngProcessor;
-    
+    asyncCreateLedger(ensSize, qSize, digestType, passwd, this, counter);
+
     /*
-     * Blacklist of bookies
+     * Wait
      */
-    HashSet<InetSocketAddress> bookieBlackList;
-    
-    LedgerSequence responseRead;
-    Long responseLong;
-    
-    public BookKeeper(String servers) 
-    throws KeeperException, IOException{
-    	LOG.debug(""Creating BookKeeper for servers "" + servers);
-        //Create ZooKeeper object
-        this.zk = new ZooKeeper(servers, 10000, this);
-        
-        //List to enable clients to blacklist bookies
-        this.bookieBlackList = new HashSet<InetSocketAddress>();
-    }
-    
-    /**
-     * Watcher method. 
-     */
-    synchronized public void process(WatchedEvent event) {
-        LOG.debug(""Process: "" + event.getType() + "" "" + event.getPath());
-    }
-    
-    /**
-     * Formats ledger ID according to ZooKeeper rules
-     * 
-     * @param id	znode id
-     */
-    String getZKStringId(long id){
-        return String.format(""%010d"", id);        
-    }
-    
-    /**
-     * return the zookeeper instance
-     * @return return the zookeeper instance
-     */
-    ZooKeeper getZooKeeper() {
-        return zk;
-    }
-    
-    LedgerManagementProcessor getMngProcessor(){
-        if (ledgerMngProcessor == null){
-            ledgerMngProcessor = new LedgerManagementProcessor(this);
-            ledgerMngProcessor.start();
-        }
-        return ledgerMngProcessor;
-    }
-    
-    /**
-     * Creates a new ledger. To create a ledger, we need to specify the ensemble
-     * size, the quorum size, the operation mode, and a password. The ensemble size
-     * and the quorum size depend upon the operation mode. The operation mode can be
-     * GENERIC, VERIFIABLE, or FREEFORM (debugging). The password is used not only
-     * to authenticate access to a ledger, but also to verify entries in verifiable
-     * ledgers.
-     * 
-     * @param ensSize   ensemble size
-     * @param qSize     quorum size
-     * @param mode      quorum mode: VERIFIABLE (default), GENERIC, or FREEFORM
-     * @param passwd    password
-     */
-    public LedgerHandle createLedger(int ensSize, int qSize, QMode mode,  byte passwd[])
-        throws KeeperException, InterruptedException, 
-        IOException, BKException {
-        // Check that quorum size follows the minimum
-        long t;
-        LedgerHandle lh = null;
-        
-        switch(mode){
-        case VERIFIABLE:
-            t = java.lang.Math.round(java.lang.Math.floor((ensSize - 1)/2));
-            if(t == 0){
-                LOG.error(""Tolerates 0 bookie failures""); 
-                throw BKException.create(Code.QuorumException);
-            }
-            break;
-        case GENERIC:
-            t = java.lang.Math.round(java.lang.Math.floor((ensSize - 1)/3));
-            if(t == 0){
-                LOG.error(""Tolerates 0 bookie failures""); 
-                throw BKException.create(Code.QuorumException);
-            }
-            break;
-        case FREEFORM:
-            break;
-        }
-        /*
-         * Create ledger node on ZK.
-         * We get the id from the sequence number on the node.
-         */
-        String path = zk.create(BKDefs.prefix, new byte[0], 
-                Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);
-        /* 
-         * Extract ledger id.
-         */
-        String parts[] = path.split(""/"");
-        String subparts[] = parts[2].split(""L"");
-        try{
-            long lId = Long.parseLong(subparts[1]);
-       
-            /* 
-             * Get children from ""/ledgers/available"" on zk
-             */
-            List<String> list = 
-                zk.getChildren(""/ledgers/available"", false);
-            ArrayList<InetSocketAddress> lBookies = new ArrayList<InetSocketAddress>();
-            /* 
-             * Select ensSize servers to form the ensemble
-             */
-            path = zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble, new byte[0], 
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-         
-            /* 
-             * Add quorum size to ZK metadata
-             */
-            ByteBuffer bb = ByteBuffer.allocate(4);
-            bb.putInt(qSize);
-            zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumSize, bb.array(), 
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-            /* 
-             * Quorum mode
-             */
-            bb = ByteBuffer.allocate(4);
-            bb.putInt(mode.ordinal());
-            zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumMode, bb.array(), 
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-            /* 
-             * Create QuorumEngine
-             */
-            lh = new LedgerHandle(this, lId, 0, qSize, mode, passwd);
-            
-            /*
-             * Adding bookies to ledger handle
-             */
-            Random r = new Random();
-        
-            for(int i = 0; i < ensSize; i++){
-                int index = 0;
-                if(list.size() > 1) 
-                    index = r.nextInt(list.size() - 1);
-                else if(list.size() == 1)
-                    index = 0;
-                else {
-                    LOG.error(""Not enough bookies available"");
-        	    
-                    return null;
-                }
-            
-                try{
-                    String bookie = list.remove(index);
-                    LOG.info(""Bookie: "" + bookie);
-                    InetSocketAddress tAddr = parseAddr(bookie);
-                    int bindex = lh.addBookieForWriting(tAddr); 
-                    ByteBuffer bindexBuf = ByteBuffer.allocate(4);
-                    bindexBuf.putInt(bindex);
-        	    
-                    String pBookie = ""/"" + bookie;
-                    zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble + pBookie, bindexBuf.array(), 
-                            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-                } catch (IOException e) {
-                    LOG.error(e);
-                    i--;
-                } 
-            }
-            LOG.debug(""Created new ledger"");
-        } catch (NumberFormatException e) {
-            LOG.error(""Error when parsing the ledger identifier"", e);
-        }
-        // Return ledger handler
-        return lh; 
+    counter.block(0);
+    if (counter.getLh() == null) {
+      LOG.error(""ZooKeeper error: "" + counter.getrc());
+      throw BKException.create(Code.ZKException);
     }
 
-    /**
-     * Creates a new ledger. Default of 3 servers, and quorum of 2 servers,
-     * verifiable ledger.
-     * 
-     * @param passwd	password
-     */
-    public LedgerHandle createLedger(byte passwd[])
-    throws KeeperException, BKException, 
-    InterruptedException, IOException {
-        return createLedger(3, 2, QMode.VERIFIABLE, passwd);
-    }
+    return counter.getLh();
+  }
 
-    /**
-     * Asychronous call to create ledger
-     * 
-     * @param ensSize
-     * @param qSize
-     * @param mode
-     * @param passwd
-     * @param cb
-     * @param ctx
-     * @throws KeeperException
-     * @throws InterruptedException
-     * @throws IOException
-     * @throws BKException
-     */
-    public void asyncCreateLedger(int ensSize, 
-            int qSize, 
-            QMode mode,  
-            byte passwd[],
-            CreateCallback cb,
-            Object ctx
-            )
-    throws KeeperException, InterruptedException, 
-    IOException, BKException {
-        CreateLedgerOp op = new CreateLedgerOp(ensSize, 
-                qSize, 
-                mode, 
-                passwd, 
-                cb, 
-                ctx);
-        LedgerManagementProcessor lmp = getMngProcessor();
-        lmp.addOp(op);
-        
-    }
-    
-    /**
-     * Open existing ledger for reading. Default for quorum size is 2.
-     * 
-     * @param long  the long corresponding to the ledger id
-     * @param byte[]    byte array corresponding to the password to access a ledger
-     * @param int   the quorum size, it has to be at least ceil(n+1/2)
-     */
-    public LedgerHandle openLedger(long lId, byte passwd[])
-    throws KeeperException, InterruptedException, IOException, BKException {
-        
-        Stat stat = null;
-        
-        /*
-         * Check if ledger exists
-         */
-        if(zk.exists(BKDefs.prefix + getZKStringId(lId), false) == null){
-            LOG.error(""Ledger "" + getZKStringId(lId) + "" doesn't exist."");
-            throw BKException.create(Code.NoSuchLedgerExistsException);
-        }
-        
-        /*
-         * Get quorum size.
-         */
-        ByteBuffer bb = ByteBuffer.wrap(zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumSize, false, stat));
-        int qSize = bb.getInt();
-         
-        /*
-         * Get last entry written from ZK 
-         */
-        
-        long last = 0;
-        LOG.debug(""Close path: "" + BKDefs.prefix + getZKStringId(lId) + BKDefs.close);
-        if(zk.exists(BKDefs.prefix + getZKStringId(lId) + BKDefs.close, false) == null){
-            recoverLedger(lId, passwd);
-        }
-            
-        stat = null;
-        byte[] data = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.close, false, stat);
-        ByteBuffer buf = ByteBuffer.wrap(data);
-        last = buf.getLong();
-        //zk.delete(BKDefs.prefix + getZKStringId(lId) + BKDefs.close, -1);
-        
-        /*
-         * Quorum mode 
-         */
-        data = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumMode, false, stat);
-        buf = ByteBuffer.wrap(data);
-        
-        QMode qMode;
-        switch(buf.getInt()){
-        case 1:
-            qMode = QMode.GENERIC;
-            LOG.info(""Generic ledger"");
-            break;
-        case 2:
-            qMode = QMode.FREEFORM;
-            break;
-        default:
-            qMode = QMode.VERIFIABLE;
-            LOG.info(""Verifiable ledger"");
-        }
-        
-        /*
-         *  Create QuorumEngine
-         */
-        LedgerHandle lh = new LedgerHandle(this, lId, last, qSize, qMode, passwd);
-        
-        /*
-         * Get children of ""/ledgers/id/ensemble"" 
-         */
-        
-        List<String> list = 
-            zk.getChildren(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble, false);
-        
-        LOG.debug(""Length of list of bookies: "" + list.size());
-        for(int i = 0 ; i < list.size() ; i++){
-            for(String s : list){
-                LOG.debug(""Extracting bookie: "" + s);
-                byte[] bindex = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble + ""/"" + s, false, stat);
-                ByteBuffer bindexBuf = ByteBuffer.wrap(bindex);
-                if(bindexBuf.getInt() == i){                      
-                    try{
-                        lh.addBookieForReading(parseAddr(s));
-                    } catch (IOException e){
-                        LOG.error(e);
-                    }
-                }
-            }
-        }
-        
-        /*
-         * Read changes to quorum over time. To determine if there has been changes during
-         * writes to the ledger, check if there is a znode called quorumEvolution.
-         */
-        if(zk.exists(BKDefs.prefix + 
-                getZKStringId(lh.getId()) +  
-                BKDefs.quorumEvolution, false) != null){
-                    String path = BKDefs.prefix + 
-                    getZKStringId(lh.getId()) +  
-                    BKDefs.quorumEvolution;
-                    
-                    List<String> faultList = zk.getChildren(path, false);
-                    try{
-                        for(String s : faultList){
-                            LOG.debug(""Faulty list child: "" + s);
-                            long entry = Long.parseLong(s);
-                            String addresses = new String(zk.getData(path + ""/"" + s, false, stat));
-                            String parts[] = addresses.split("" "");
+  /**
+   * Open existing ledger asynchronously for reading.
+   * 
+   * @param lId
+   *          ledger identifier
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @param ctx
+   *          optional control object
+   */
+  public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],
+      OpenCallback cb, Object ctx) {
 
-                            ArrayList<BookieHandle> newBookieSet = new ArrayList<BookieHandle>();
-                            for(int i = 0 ; i < parts.length ; i++){
-                                LOG.debug(""Address: "" + parts[i]);
-                                InetSocketAddress faultyBookie =  
-                                    parseAddr(parts[i].substring(1));                           
-                        
-                                newBookieSet.add(lh.getBookieHandleDup(faultyBookie));
-                            }
-                            lh.setNewBookieConfig(entry, newBookieSet);
-                            LOG.debug(""NewBookieSet size: "" + newBookieSet.size());
-                        }
+    new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiate();
 
-                        lh.prepareEntryChange();
-                    } catch (NumberFormatException e) {
-                        LOG.error(""Error when parsing the ledger identifier"", e);
-                    }
-                }
-      
-        /*
-         *  Return ledger handler
-         */
-        return lh;
-    }    
-    
-    public void asyncOpenLedger(long lId, byte passwd[], OpenCallback cb, Object ctx)
-    throws InterruptedException{
-        OpenLedgerOp op = new OpenLedgerOp(lId, 
-                passwd,  
-                cb, 
-                ctx);
-        LedgerManagementProcessor lmp = getMngProcessor();
-        lmp.addOp(op);
-    }
-    
-    /**
-     * Parses address into IP and port.
-     * 
-     *  @param addr	String
+  }
+
+  /**
+   * Callback method for synchronous open operation
+   * 
+   * @param rc
+   *          return code
+   * @param lh
+   *          ledger handle
+   * @param ctx
+   *          optional control object
+   */
+  public void openComplete(int rc, LedgerHandle lh, Object ctx) {
+    SyncCounter counter = (SyncCounter) ctx;
+    counter.setLh(lh);
+
+    LOG.debug(""Open complete: "" + rc);
+
+    counter.setrc(rc);
+    counter.dec();
+  }
+
+  /**
+   * Synchronous open ledger call
+   * 
+   * @param lId
+   *          ledger identifier
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @return
+   * @throws InterruptedException
+   * @throws BKException
+   */
+
+  public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])
+      throws BKException, InterruptedException {
+    SyncCounter counter = new SyncCounter();
+    counter.inc();
+
+    /*
+     * Calls async open ledger
      */
-    
-    InetSocketAddress parseAddr(String s){
-        String parts[] = s.split("":"");
-        if (parts.length != 2) {
-            System.out.println(s
-                    + "" does not have the form host:port"");
-        }
-        InetSocketAddress addr = new InetSocketAddress(parts[0],
-                Integer.parseInt(parts[1]));
-        return addr;
-    }
-    
- 
-    /**
-     * Check if close node exists. 
-     * 
-     * @param ledgerId	id of the ledger to check
+    asyncOpenLedger(lId, digestType, passwd, this, counter);
+
+    /*
+     * Wait
      */
-    public boolean hasClosed(long ledgerId)
-    throws KeeperException, InterruptedException{
-        String closePath = BKDefs.prefix + getZKStringId(ledgerId) + BKDefs.close;
-        if(zk.exists(closePath, false) == null) return false;
-        else return true;
+    counter.block(0);
+    if (counter.getrc() != BKException.Code.OK)
+      throw BKException.create(counter.getrc());
+
+    return counter.getLh();
+  }
+
+  /**
+   * Shuts down client.
+   * 
+   */
+  public void halt() throws InterruptedException {
+    bookieClient.close();
+    bookieWatcher.halt();
+    if (ownChannelFactory) {
+      channelFactory.releaseExternalResources();
     }
-    
-    /**
-     * Recover a ledger that was not closed properly.
-     * 
-     * @param lId	ledger identifier
-     * @param passwd	password
-     */
-    
-    boolean recoverLedger(long lId, byte passwd[])
-    throws KeeperException, InterruptedException, IOException, BKException {
-        
-        Stat stat = null;
-       
-        LOG.info(""Recovering ledger"");
-        
-        /*
-         * Get quorum size.
-         */
-        ByteBuffer bb = ByteBuffer.wrap(zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumSize, false, stat));
-        int qSize = bb.getInt();
-                
-        
-        /*
-         * Get children of ""/ledgers/id/ensemble"" 
-         */
-        
-        List<String> list = 
-            zk.getChildren(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble, false);
-        
-        ArrayList<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();
-        for(String s : list){
-            addresses.add(parseAddr(s));
-        }
-        
-        /*
-         * Quorum mode 
-         */
-        byte[] data = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumMode, false, stat);
-        ByteBuffer buf = ByteBuffer.wrap(data);
-        //int ordinal = buf.getInt();
-            
-        QMode qMode = QMode.VERIFIABLE;
-        switch(buf.getInt()){
-        case 0:
-            qMode = QMode.VERIFIABLE;
-            break;
-        case 1:
-            qMode = QMode.GENERIC;
-            break;
-        case 2:
-            qMode = QMode.FREEFORM;
-            break;
-        }
-        
-        /*
-         * Create ledger recovery monitor object
-         */
-        
-        LedgerRecoveryMonitor lrm = new LedgerRecoveryMonitor(this, lId, qSize, addresses, qMode);
-        
-        return lrm.recover(passwd);
+    if (ownZKHandle) {
+      zk.close();
     }
-    
-    /**
-     * Get new bookies
-     * 
-     * @param addrList	list of bookies to replace
-     */
-    InetSocketAddress getNewBookie(ArrayList<InetSocketAddress> addrList)
-    throws InterruptedException {
-        try{
-            // Get children from ""/ledgers/available"" on zk
-            List<String> list = 
-                zk.getChildren(""/ledgers/available"", false);
-            ArrayList<InetSocketAddress> lBookies = new ArrayList<InetSocketAddress>();
-    
-            for(String addr : list){
-                InetSocketAddress nAddr = parseAddr(addr); 
-                if(!addrList.contains(nAddr) &&
-                        !bookieBlackList.contains(nAddr))
-                    return nAddr;
-            }
-        } catch (KeeperException e){
-            LOG.error(""Problem accessing ZooKeeper: "" + e);
-        }
-        
-        return null;
-    }
-    
-    HashMap<InetSocketAddress, BookieHandle> bhMap = 
-    	new HashMap<InetSocketAddress, BookieHandle>();
-    
-    /**
-     *  Keeps a list of available BookieHandle objects and returns
-     *  the corresponding object given an address.
-     *  
-     *  @param	a	InetSocketAddress
-     */
-    
-    synchronized BookieHandle getBookieHandle(LedgerHandle lh, InetSocketAddress a)
-    throws ConnectException, IOException {
-    	if(!bhMap.containsKey(a)){
-    	    BookieHandle bh = new BookieHandle(a, true); 
-    		bhMap.put(a, bh);
-    		bh.start();
-    	}
-    	bhMap.get(a).incRefCount(lh);
-    	
-    	return bhMap.get(a);
-    }
-    
-    /**
-     * When there are no more references to a BookieHandle,
-     * remove it from the list. 
-     */
-    
-    synchronized void haltBookieHandles(LedgerHandle lh, ArrayList<BookieHandle> bookies){
-        while(bookies.size() > 0){
-            BookieHandle bh = bookies.remove(0);
-            if(bh.halt(lh) <= 0)
-                bhMap.remove(bh.addr);
-        }
-    }
-    
-    /**
-     * Blacklists bookies.
-     * 
-     * @param addr 	address of bookie
-     */
-    void blackListBookie(InetSocketAddress addr){
-        bookieBlackList.add(addr);
-    }
-    
-    /**
-     * Halts all bookie handles
-     * 
-     */
-    public void halt() throws InterruptedException{
-        
-        for(BookieHandle bh: bhMap.values()){
-            bh.shutdown();
-        }
-        zk.close();
-    }
+    callbackWorker.shutdown();
+    mainWorkerPool.shutdown();
+  }
 }
",,6461
2465,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/ClientCBWorker.java,a1ac465be361ff478f9b66147731e588fef64ff3,1233343827,71,e0316743684e9ef208cfe68efc28929ecfad5e67,1245820043,91,c41bd3f83e6ad99f03261ba21295eed5151eadda,1241599788,-1,1241599788/1233343827,"        instance = null;","      * 
      */
     synchronized void shutdown(){
-        stop = true;
-        instance = null;
-        LOG.debug(""Shutting down"");
+        if((--instanceCounter) == 0){
+            stop = true;
+            instance = null;
+            LOG.debug(""Shutting down"");
+        }
     }
     
     
",,6461
2466,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java,a1ac465be361ff478f9b66147731e588fef64ff3,1233343827,424,575c53253bf9f548f342c3371d05bc00d2c2363d,1298051688,417,,,,,"            sock = null;",,,6461
2467,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/ServerStats.java,a1ac465be361ff478f9b66147731e588fef64ff3,1233343827,41,,,,e1a1ee81f1aa930cae20fa3fc76485e45a95f066,1264547805,-1,1264547805/1233343827,"        instance=null;"," 
 package org.apache.bookkeeper.proto;
 
-
 public class ServerStats {
-    private static ServerStats instance= new ServerStats();
+    private static ServerStats instance = new ServerStats();
     private long packetsSent;
     private long packetsReceived;
     private long maxLatency;
     private long minLatency = Long.MAX_VALUE;
     private long totalLatency = 0;
     private long count = 0;
-    
-    public interface Provider{
+
+    public interface Provider {
         public long getOutstandingRequests();
+
         public long getLastProcessedZxid();
     }
-    private Provider provider=null;
-    private Object mutex=new Object();
-    
-    static public ServerStats getInstance(){
+
+    private Provider provider = null;
+    private Object mutex = new Object();
+
+    static public ServerStats getInstance() {
         return instance;
     }
+
     static public void registerAsConcrete() {
         setInstance(new ServerStats());
     }
+
     static synchronized public void unregister() {
-        instance=null;
+        instance = null;
     }
-    static synchronized protected void setInstance(ServerStats newInstance){
-        assert instance==null;
+
+    static synchronized protected void setInstance(ServerStats newInstance) {
+        assert instance == null;
         instance = newInstance;
     }
-    protected ServerStats(){}
-    
+
+    protected ServerStats() {
+    }
+
     // getters
     synchronized public long getMinLatency() {
         return (minLatency == Long.MAX_VALUE) ? 0 : minLatency;
     }
 
     synchronized public long getAvgLatency() {
-        if(count!=0)
+        if (count != 0)
             return totalLatency / count;
         return 0;
     }
",,6461
2468,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,1233356493,736,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,677,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2469,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,1233356493,771,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,712,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2470,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,1233356493,837,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,779,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2471,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,1233356493,870,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,812,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2472,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,1233356493,1119,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,1065,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2473,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,1233356493,1154,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,1100,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2474,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/InstanceContainer.java,892b0941c13f3680a5e3cfc32d51694ac4861289,1233363852,140,9ac5756b18d377774f49064e6e1de3f39d059b87,1319522994,136,,,,,"                lastException = null;",,,6461
2475,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/InstanceContainer.java,892b0941c13f3680a5e3cfc32d51694ac4861289,1233363852,271,9ac5756b18d377774f49064e6e1de3f39d059b87,1319522994,266,,,,,"                        conf = null;",,,6461
2476,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/InstanceManager.java,892b0941c13f3680a5e3cfc32d51694ac4861289,1233363852,90,9ac5756b18d377774f49064e6e1de3f39d059b87,1319522994,101,,,,,"                lastException = null;",,,6461
2477,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/InstanceManager.java,892b0941c13f3680a5e3cfc32d51694ac4861289,1233363852,267,8173d34f1bb7c59fa401c3db1c0e42264fc48924,1233613563,267,,,,,"                lastException = null;",,,6461
2478,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/InstanceManager.java,892b0941c13f3680a5e3cfc32d51694ac4861289,1233363852,291,8173d34f1bb7c59fa401c3db1c0e42264fc48924,1233613563,291,,,,,"                lastException = null;",,,6461
2479,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java,892b0941c13f3680a5e3cfc32d51694ac4861289,1233363852,114,5fdd70ac49c7a5334bdcae309719ac4ada352dde,1531222160,142,,,,,"                peer = null;",,,6461
2480,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,a4c675afff3b26171efd78ced4916e2f5fb25eb4,1233638627,497,360fc24572f0ba75362253450fea50dd48d2ea13,1245287332,502,,,,,"            node.parent = null;",,,6461
2481,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,864,9107bbaf5f94ea0c70bcaae458538c95aeb61454,1249601012,948,,,,,"            jmxConnectionBean = null;",,,6461
2482,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,343,bb857582bab316abea48588375df98de51df9115,1359076658,341,,,,,"                jmxDataTreeBean = null;",,,6461
2483,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,347,bb857582bab316abea48588375df98de51df9115,1359076658,345,,,,,"            jmxServerBean = null;",,,6461
2484,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,190,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,193,,,,,"            jmxDataTreeBean = null;",,,6461
2485,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,212,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,215,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,-1,1256919553/1233955143,"            jmxServerBean = null;","                     e);
         }
     }
-
-
-    @Override
-    protected void registerJMX() {
-        // register with JMX
-        try {
-            jmxDataTreeBean = new DataTreeBean(dataTree);
-            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
-        } catch (Exception e) {
-            LOG.warn(""Failed to register with JMX"", e);
-            jmxDataTreeBean = null;
-        }
-    }
-
-    public void registerJMX(FollowerBean followerBean,
-            LocalPeerBean localPeerBean)
-    {
-        // register with JMX
-        if (self.jmxLeaderElectionBean != null) {
-            try {
-                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
-            } catch (Exception e) {
-                LOG.warn(""Failed to register with JMX"", e);
-            }
-            self.jmxLeaderElectionBean = null;
-        }
-
-        try {
-            jmxServerBean = followerBean;
-            MBeanRegistry.getInstance().register(followerBean, localPeerBean);
-        } catch (Exception e) {
-            LOG.warn(""Failed to register with JMX"", e);
-            jmxServerBean = null;
-        }
-    }
-
-    @Override
-    protected void unregisterJMX() {
-        // unregister from JMX
-        try {
-            if (jmxDataTreeBean != null) {
-                MBeanRegistry.getInstance().unregister(jmxDataTreeBean);
-            }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxDataTreeBean = null;
-    }
-
-    protected void unregisterJMX(Follower follower) {
-        // unregister from JMX
-        try {
-            if (jmxServerBean != null) {
-                MBeanRegistry.getInstance().unregister(jmxServerBean);
-            }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxServerBean = null;
-    }
     
     @Override
     public String getState() {
         return ""follower"";
     }
+
+    @Override
+    public Learner getLearner() {
+        return getFollower();
+    }
 }
",,6461
2486,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,99,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,130,,,,,"            jmxDataTreeBean = null;",,,6461
2487,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,121,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,152,,,,,"            jmxServerBean = null;",,,6461
2488,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,375,,,,f6521f7c29b1d330617aed3764ecc25ff73e2da1,1239922789,-1,1239922789/1233955143,"            jmxLeaderElectionBean = null;","     }
 
     protected Election makeLEStrategy(){
-        LOG.debug(""Running leader election protocol..."");
-        try {
-            jmxLeaderElectionBean = new LeaderElectionBean();
-            MBeanRegistry.getInstance().register(jmxLeaderElectionBean, jmxLocalPeerBean);        
-        } catch (Exception e) {
-            LOG.warn(""Failed to register with JMX"", e);
-            jmxLeaderElectionBean = null;
-        }
+        LOG.debug(""Initializing leader election protocol..."");
 
         if(electionAlg==null)
             return new LeaderElection(this);
",,6461
2489,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,415,cff0aedb1891cc1595cb19e28533f2b5c7a3e6a0,1242845280,452,,,,,"                        jmxLocalPeerBean = null;",,,6461
2490,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,428,cff0aedb1891cc1595cb19e28533f2b5c7a3e6a0,1242845280,465,,,,,"            jmxQuorumBean = null;",,,6461
2491,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,484,cff0aedb1891cc1595cb19e28533f2b5c7a3e6a0,1242845280,521,,,,,"            jmxQuorumBean = null;",,,6461
2492,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c5d28b03b72253f2ca6d9142a17487b253317ec6,1233955143,485,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,532,,,,,"            jmxLocalPeerBean = null;",,,6461
2493,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,83cf0a93c37759334fab885c2010fa0b7d953f52,1235089420,115,0b65e3d4cbb7647ea692bfea59c02e5b24bf821c,1536189061,165,,,,,"            this.logStream = null;",,,6461
2494,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,83cf0a93c37759334fab885c2010fa0b7d953f52,1235089420,116,8ec4c58eb37880a812bb2e23e8b3ec2a5e3b7f32,1498428426,165,,,,,"            oa = null;",,,6461
2495,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,47b16b9612ece90d959f1966f387b91ee4d9b7ed,1239224982,419,c472d685e02ced4448054b3d8a83a1b669dee58e,1256678040,484,,,,,"            recvWorker = null;",,,6461
2496,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,47b16b9612ece90d959f1966f387b91ee4d9b7ed,1239224982,472,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,479,8d2ae28491342663d9290114b8ecb182d6aa903e,1246394829,-1,1246394829/1239224982,"                        recvWorker = null;","                      * message back to the beginning of the queue and leave.
                      */
                     LOG.warn(""Exception when using channel: "" + sid, e);
-                    running = false;
-                    synchronized (senderWorkerMap) {
-                        recvWorker.finish();
-                        recvWorker = null;
+                    finish();
+                    recvWorker.finish();
+                    recvWorker = null;
                     
-                        senderWorkerMap.remove(sid);
-                        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
-                        if(bq != null){
-                            if (bq.size() == 0) {
-                                boolean ret = bq.offer(b);
-                                if (!ret) {
-                                    // to appease findbugs
-                                    LOG.error(""Not able to add to a quue of size 0"");
-                                }
+                    ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
+                    if(bq != null){
+                        if (bq.size() == 0) {
+                            boolean ret = bq.offer(b);
+                            if (!ret) {
+                                // to appease findbugs
+                                LOG.error(""Not able to add to a quue of size 0"");
                             }
-                        } else LOG.error(""No queue for server "" + sid);
-                    }
+                        }
+                    } else LOG.error(""No queue for server "" + sid);
                 }
             }
             LOG.warn(""Send worker leaving thread"");
",,6461
2497,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java,f6521f7c29b1d330617aed3764ecc25ff73e2da1,1239922789,817,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,1395544376,836,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2498,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java,f6521f7c29b1d330617aed3764ecc25ff73e2da1,1239922789,956,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,1395544376,972,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2499,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,f6521f7c29b1d330617aed3764ecc25ff73e2da1,1239922789,520,358f5122485b7ffa9dcc2e46e0751e88711f2ad9,1249409476,531,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2500,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,f6521f7c29b1d330617aed3764ecc25ff73e2da1,1239922789,690,472c93adc6e4dfc7dbb7b5a95d211dce09cc154f,1273091553,834,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2501,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java,f6521f7c29b1d330617aed3764ecc25ff73e2da1,1239922789,120,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,151,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2502,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java,f6521f7c29b1d330617aed3764ecc25ff73e2da1,1239922789,227,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,290,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2503,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/recipes/lock/src/java/org/apache/zookeeper/recipes/lock/WriteLock.java,579ad8454500a307b1ec07efc4eeed55d643f124,1240522869,138,53a3d5530bd337625374396199ab985e115025ed,1302592447,139,,,,,"                id = null;",,,6461
2504,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/recipes/lock/src/java/org/apache/zookeeper/recipes/lock/WriteLock.java,579ad8454500a307b1ec07efc4eeed55d643f124,1240522869,219,53a3d5530bd337625374396199ab985e115025ed,1302592447,220,,,,,"                        id = null;",,,6461
2505,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookKeeper.java,c41bd3f83e6ad99f03261ba21295eed5151eadda,1241599788,287,e0316743684e9ef208cfe68efc28929ecfad5e67,1245820043,336,e1a1ee81f1aa930cae20fa3fc76485e45a95f066,1264547805,-1,1264547805/1241599788,"        stat = null;","  * 
  */
 
-
 import java.io.IOException;
-import java.net.ConnectException;
-import java.nio.ByteBuffer;
-import java.nio.channels.UnresolvedAddressException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.HashMap;
-import java.util.Random;
-import java.net.InetSocketAddress;
-
+import java.util.concurrent.Executors;
 import org.apache.bookkeeper.client.BKException;
-import org.apache.bookkeeper.client.BookieHandle;
-import org.apache.bookkeeper.client.LedgerSequence;
 import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;
 import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;
 import org.apache.bookkeeper.client.BKException.Code;
-import org.apache.bookkeeper.client.LedgerHandle.QMode;
-import org.apache.bookkeeper.client.LedgerManagementProcessor.CreateLedgerOp;
-import org.apache.bookkeeper.client.LedgerManagementProcessor.OpenLedgerOp;
+import org.apache.bookkeeper.client.SyncCounter;
+import org.apache.bookkeeper.proto.BookieClient;
+import org.apache.bookkeeper.util.OrderedSafeExecutor;
 import org.apache.log4j.Logger;
 
-import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.CreateMode;
-import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.WatchedEvent;
-
+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
 
 /**
- * BookKeeper client. We assume there is one single writer 
- * to a ledger at any time. 
+ * BookKeeper client. We assume there is one single writer to a ledger at any
+ * time.
  * 
- * There are three possible operations: start a new ledger, 
- * write to a ledger, and read from a ledger.
+ * There are three possible operations: start a new ledger, write to a ledger,
+ * and read from a ledger.
  * 
- * For the ZooKeeper layout, please refer to BKDefs.java.
+ * The exceptions resulting from synchronous calls and error code resulting from
+ * asynchronous calls can be found in the class {@link BKException}.
+ * 
  * 
  */
 
-public class BookKeeper 
-implements Watcher {
- 
-    Logger LOG = Logger.getLogger(BookKeeper.class);
-    
-    ZooKeeper zk = null;
-    
+public class BookKeeper implements OpenCallback, CreateCallback {
+
+  static final Logger LOG = Logger.getLogger(BookKeeper.class);
+
+  ZooKeeper zk = null;
+  // whether the zk handle is one we created, or is owned by whoever
+  // instantiated us
+  boolean ownZKHandle = false;
+
+  ClientSocketChannelFactory channelFactory;
+  // whether the socket factory is one we created, or is owned by whoever
+  // instantiated us
+  boolean ownChannelFactory = false;
+
+  BookieClient bookieClient;
+  BookieWatcher bookieWatcher;
+
+  OrderedSafeExecutor callbackWorker = new OrderedSafeExecutor(Runtime
+      .getRuntime().availableProcessors());
+  OrderedSafeExecutor mainWorkerPool = new OrderedSafeExecutor(Runtime
+      .getRuntime().availableProcessors());
+
+  /**
+   * Create a bookkeeper client. A zookeeper client and a client socket factory
+   * will be instantiated as part of this constructor.
+   * 
+   * @param servers
+   *          A list of one of more servers on which zookeeper is running. The
+   *          client assumes that the running bookies have been registered with
+   *          zookeeper under the path
+   *          {@link BookieWatcher#BOOKIE_REGISTRATION_PATH}
+   * @throws IOException
+   * @throws InterruptedException
+   * @throws KeeperException
+   */
+  public BookKeeper(String servers) throws IOException, InterruptedException,
+      KeeperException {
+    this(new ZooKeeper(servers, 10000, new Watcher() {
+      @Override
+      public void process(WatchedEvent event) {
+        // TODO: handle session disconnects and expires
+        if (LOG.isDebugEnabled()) {
+          LOG.debug(""Process: "" + event.getType() + "" "" + event.getPath());
+        }
+      }
+    }), new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),
+        Executors.newCachedThreadPool()));
+
+    ownZKHandle = true;
+    ownChannelFactory = true;
+  }
+
+  /**
+   * Create a bookkeeper client but use the passed in zookeeper client instead
+   * of instantiating one.
+   * 
+   * @param zk
+   *          Zookeeper client instance connected to the zookeeper with which
+   *          the bookies have registered
+   * @throws InterruptedException
+   * @throws KeeperException
+   */
+  public BookKeeper(ZooKeeper zk) throws InterruptedException, KeeperException {
+    this(zk, new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),
+        Executors.newCachedThreadPool()));
+    ownChannelFactory = true;
+  }
+
+  /**
+   * Create a bookkeeper client but use the passed in zookeeper client and
+   * client socket channel factory instead of instantiating those.
+   * 
+   * @param zk
+   *          Zookeeper client instance connected to the zookeeper with which
+   *          the bookies have registered
+   * @param channelFactory
+   *          A factory that will be used to create connections to the bookies
+   * @throws InterruptedException
+   * @throws KeeperException
+   */
+  public BookKeeper(ZooKeeper zk, ClientSocketChannelFactory channelFactory)
+      throws InterruptedException, KeeperException {
+    if (zk == null || channelFactory == null) {
+      throw new NullPointerException();
+    }
+    this.zk = zk;
+    this.channelFactory = channelFactory;
+    bookieWatcher = new BookieWatcher(this);
+    bookieWatcher.readBookiesBlocking();
+    bookieClient = new BookieClient(channelFactory, mainWorkerPool);
+  }
+
+  /**
+   * There are 2 digest types that can be used for verification. The CRC32 is
+   * cheap to compute but does not protect against byzantine bookies (i.e., a
+   * bookie might report fake bytes and a matching CRC32). The MAC code is more
+   * expensive to compute, but is protected by a password, i.e., a bookie can't
+   * report fake bytes with a mathching MAC unless it knows the password
+   */
+  public enum DigestType {
+    MAC, CRC32
+  };
+
+  public ZooKeeper getZkHandle() {
+    return zk;
+  }
+
+  /**
+   * Creates a new ledger asynchronously. To create a ledger, we need to specify
+   * the ensemble size, the quorum size, the digest type, a password, a callback
+   * implementation, and an optional control object. The ensemble size is how
+   * many bookies the entries should be striped among and the quorum size is the
+   * degree of replication of each entry. The digest type is either a MAC or a
+   * CRC. Note that the CRC option is not able to protect a client against a
+   * bookie that replaces an entry. The password is used not only to
+   * authenticate access to a ledger, but also to verify entries in ledgers.
+   * 
+   * @param ensSize
+   *          ensemble size
+   * @param qSize
+   *          quorum size
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @param cb
+   *          createCallback implementation
+   * @param ctx
+   *          optional control object
+   */
+  public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType,
+      byte[] passwd, CreateCallback cb, Object ctx) {
+
+    new LedgerCreateOp(this, ensSize, qSize, digestType, passwd, cb, ctx)
+        .initiate();
+
+  }
+
+  /**
+   * Create callback implementation for synchronous create call.
+   * 
+   * @param rc
+   *          return code
+   * @param lh
+   *          ledger handle object
+   * @param ctx
+   *          optional control object
+   */
+  public void createComplete(int rc, LedgerHandle lh, Object ctx) {
+    SyncCounter counter = (SyncCounter) ctx;
+    counter.setLh(lh);
+    counter.setrc(rc);
+    counter.dec();
+  }
+
+  /**
+   * Creates a new ledger. Default of 3 servers, and quorum of 2 servers.
+   * 
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @return
+   * @throws KeeperException
+   * @throws InterruptedException
+   * @throws BKException
+   */
+  public LedgerHandle createLedger(DigestType digestType, byte passwd[])
+      throws KeeperException, BKException, InterruptedException, IOException {
+    return createLedger(3, 2, digestType, passwd);
+  }
+
+  /**
+   * Synchronous call to create ledger. Parameters match those of
+   * {@link #asyncCreateLedger(int, int, DigestType, byte[], CreateCallback, Object)}
+   * 
+   * @param ensSize
+   * @param qSize
+   * @param digestType
+   * @param passwd
+   * @return
+   * @throws KeeperException
+   * @throws InterruptedException
+   * @throws IOException
+   * @throws BKException
+   */
+  public LedgerHandle createLedger(int ensSize, int qSize,
+      DigestType digestType, byte passwd[]) throws KeeperException,
+      InterruptedException, IOException, BKException {
+    SyncCounter counter = new SyncCounter();
+    counter.inc();
     /*
-     * The ledgerMngProcessor is a thread that processes
-     * asynchronously requests that handle ledgers, such
-     * as create, open, and close.
+     * Calls asynchronous version
      */
-    private static LedgerManagementProcessor ledgerMngProcessor;
-    
+    asyncCreateLedger(ensSize, qSize, digestType, passwd, this, counter);
+
     /*
-     * Blacklist of bookies
+     * Wait
      */
-    HashSet<InetSocketAddress> bookieBlackList;
-    
-    LedgerSequence responseRead;
-    Long responseLong;
-    
-    public BookKeeper(String servers) 
-    throws KeeperException, IOException{
-    	LOG.debug(""Creating BookKeeper for servers "" + servers);
-        //Create ZooKeeper object
-        this.zk = new ZooKeeper(servers, 10000, this);
-        
-        //List to enable clients to blacklist bookies
-        this.bookieBlackList = new HashSet<InetSocketAddress>();
-    }
-    
-    /**
-     * Watcher method. 
-     */
-    synchronized public void process(WatchedEvent event) {
-        LOG.debug(""Process: "" + event.getType() + "" "" + event.getPath());
-    }
-    
-    /**
-     * Formats ledger ID according to ZooKeeper rules
-     * 
-     * @param id	znode id
-     */
-    String getZKStringId(long id){
-        return String.format(""%010d"", id);        
-    }
-    
-    /**
-     * return the zookeeper instance
-     * @return return the zookeeper instance
-     */
-    ZooKeeper getZooKeeper() {
-        return zk;
-    }
-    
-    LedgerManagementProcessor getMngProcessor(){
-        if (ledgerMngProcessor == null){
-            ledgerMngProcessor = new LedgerManagementProcessor(this);
-            ledgerMngProcessor.start();
-        }
-        return ledgerMngProcessor;
-    }
-    
-    /**
-     * Creates a new ledger. To create a ledger, we need to specify the ensemble
-     * size, the quorum size, the operation mode, and a password. The ensemble size
-     * and the quorum size depend upon the operation mode. The operation mode can be
-     * GENERIC, VERIFIABLE, or FREEFORM (debugging). The password is used not only
-     * to authenticate access to a ledger, but also to verify entries in verifiable
-     * ledgers.
-     * 
-     * @param ensSize   ensemble size
-     * @param qSize     quorum size
-     * @param mode      quorum mode: VERIFIABLE (default), GENERIC, or FREEFORM
-     * @param passwd    password
-     */
-    public LedgerHandle createLedger(int ensSize, int qSize, QMode mode,  byte passwd[])
-        throws KeeperException, InterruptedException, 
-        IOException, BKException {
-        // Check that quorum size follows the minimum
-        long t;
-        LedgerHandle lh = null;
-        
-        switch(mode){
-        case VERIFIABLE:
-            t = java.lang.Math.round(java.lang.Math.floor((ensSize - 1)/2));
-            if(t == 0){
-                LOG.error(""Tolerates 0 bookie failures""); 
-                throw BKException.create(Code.QuorumException);
-            }
-            break;
-        case GENERIC:
-            t = java.lang.Math.round(java.lang.Math.floor((ensSize - 1)/3));
-            if(t == 0){
-                LOG.error(""Tolerates 0 bookie failures""); 
-                throw BKException.create(Code.QuorumException);
-            }
-            break;
-        case FREEFORM:
-            break;
-        }
-        /*
-         * Create ledger node on ZK.
-         * We get the id from the sequence number on the node.
-         */
-        String path = zk.create(BKDefs.prefix, new byte[0], 
-                Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);
-        /* 
-         * Extract ledger id.
-         */
-        String parts[] = path.split(""/"");
-        String subparts[] = parts[2].split(""L"");
-        try{
-            long lId = Long.parseLong(subparts[1]);
-       
-            /* 
-             * Get children from ""/ledgers/available"" on zk
-             */
-            List<String> list = 
-                zk.getChildren(""/ledgers/available"", false);
-            ArrayList<InetSocketAddress> lBookies = new ArrayList<InetSocketAddress>();
-            /* 
-             * Select ensSize servers to form the ensemble
-             */
-            path = zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble, new byte[0], 
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-         
-            /* 
-             * Add quorum size to ZK metadata
-             */
-            ByteBuffer bb = ByteBuffer.allocate(4);
-            bb.putInt(qSize);
-            zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumSize, bb.array(), 
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-            /* 
-             * Quorum mode
-             */
-            bb = ByteBuffer.allocate(4);
-            bb.putInt(mode.ordinal());
-            zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumMode, bb.array(), 
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-            /* 
-             * Create QuorumEngine
-             */
-            lh = new LedgerHandle(this, lId, 0, qSize, mode, passwd);
-            
-            /*
-             * Adding bookies to ledger handle
-             */
-            Random r = new Random();
-        
-            for(int i = 0; i < ensSize; i++){
-                int index = 0;
-                if(list.size() > 1) 
-                    index = r.nextInt(list.size() - 1);
-                else if(list.size() == 1)
-                    index = 0;
-                else {
-                    LOG.error(""Not enough bookies available"");
-        	    
-                    return null;
-                }
-            
-                try{
-                    String bookie = list.remove(index);
-                    LOG.info(""Bookie: "" + bookie);
-                    InetSocketAddress tAddr = parseAddr(bookie);
-                    int bindex = lh.addBookieForWriting(tAddr); 
-                    ByteBuffer bindexBuf = ByteBuffer.allocate(4);
-                    bindexBuf.putInt(bindex);
-        	    
-                    String pBookie = ""/"" + bookie;
-                    zk.create(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble + pBookie, bindexBuf.array(), 
-                            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-                } catch (IOException e) {
-                    LOG.error(e);
-                    i--;
-                } 
-            }
-            LOG.debug(""Created new ledger"");
-        } catch (NumberFormatException e) {
-            LOG.error(""Error when parsing the ledger identifier"", e);
-        }
-        // Return ledger handler
-        return lh; 
+    counter.block(0);
+    if (counter.getLh() == null) {
+      LOG.error(""ZooKeeper error: "" + counter.getrc());
+      throw BKException.create(Code.ZKException);
     }
 
-    /**
-     * Creates a new ledger. Default of 3 servers, and quorum of 2 servers,
-     * verifiable ledger.
-     * 
-     * @param passwd	password
-     */
-    public LedgerHandle createLedger(byte passwd[])
-    throws KeeperException, BKException, 
-    InterruptedException, IOException {
-        return createLedger(3, 2, QMode.VERIFIABLE, passwd);
-    }
+    return counter.getLh();
+  }
 
-    /**
-     * Asychronous call to create ledger
-     * 
-     * @param ensSize
-     * @param qSize
-     * @param mode
-     * @param passwd
-     * @param cb
-     * @param ctx
-     * @throws KeeperException
-     * @throws InterruptedException
-     * @throws IOException
-     * @throws BKException
-     */
-    public void asyncCreateLedger(int ensSize, 
-            int qSize, 
-            QMode mode,  
-            byte passwd[],
-            CreateCallback cb,
-            Object ctx
-            )
-    throws KeeperException, InterruptedException, 
-    IOException, BKException {
-        CreateLedgerOp op = new CreateLedgerOp(ensSize, 
-                qSize, 
-                mode, 
-                passwd, 
-                cb, 
-                ctx);
-        LedgerManagementProcessor lmp = getMngProcessor();
-        lmp.addOp(op);
-        
-    }
-    
-    /**
-     * Open existing ledger for reading. Default for quorum size is 2.
-     * 
-     * @param long  the long corresponding to the ledger id
-     * @param byte[]    byte array corresponding to the password to access a ledger
-     * @param int   the quorum size, it has to be at least ceil(n+1/2)
-     */
-    public LedgerHandle openLedger(long lId, byte passwd[])
-    throws KeeperException, InterruptedException, IOException, BKException {
-        
-        Stat stat = null;
-        
-        /*
-         * Check if ledger exists
-         */
-        if(zk.exists(BKDefs.prefix + getZKStringId(lId), false) == null){
-            LOG.error(""Ledger "" + getZKStringId(lId) + "" doesn't exist."");
-            throw BKException.create(Code.NoSuchLedgerExistsException);
-        }
-        
-        /*
-         * Get quorum size.
-         */
-        ByteBuffer bb = ByteBuffer.wrap(zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumSize, false, stat));
-        int qSize = bb.getInt();
-         
-        /*
-         * Get last entry written from ZK 
-         */
-        
-        long last = 0;
-        LOG.debug(""Close path: "" + BKDefs.prefix + getZKStringId(lId) + BKDefs.close);
-        if(zk.exists(BKDefs.prefix + getZKStringId(lId) + BKDefs.close, false) == null){
-            recoverLedger(lId, passwd);
-        }
-            
-        stat = null;
-        byte[] data = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.close, false, stat);
-        ByteBuffer buf = ByteBuffer.wrap(data);
-        last = buf.getLong();
-        //zk.delete(BKDefs.prefix + getZKStringId(lId) + BKDefs.close, -1);
-        
-        /*
-         * Quorum mode 
-         */
-        data = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumMode, false, stat);
-        buf = ByteBuffer.wrap(data);
-        
-        QMode qMode;
-        switch(buf.getInt()){
-        case 1:
-            qMode = QMode.GENERIC;
-            LOG.info(""Generic ledger"");
-            break;
-        case 2:
-            qMode = QMode.FREEFORM;
-            break;
-        default:
-            qMode = QMode.VERIFIABLE;
-            LOG.info(""Verifiable ledger"");
-        }
-        
-        /*
-         *  Create QuorumEngine
-         */
-        LedgerHandle lh = new LedgerHandle(this, lId, last, qSize, qMode, passwd);
-        
-        /*
-         * Get children of ""/ledgers/id/ensemble"" 
-         */
-        
-        List<String> list = 
-            zk.getChildren(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble, false);
-        
-        LOG.debug(""Length of list of bookies: "" + list.size());
-        for(int i = 0 ; i < list.size() ; i++){
-            for(String s : list){
-                LOG.debug(""Extracting bookie: "" + s);
-                byte[] bindex = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble + ""/"" + s, false, stat);
-                ByteBuffer bindexBuf = ByteBuffer.wrap(bindex);
-                if(bindexBuf.getInt() == i){                      
-                    try{
-                        lh.addBookieForReading(parseAddr(s));
-                    } catch (IOException e){
-                        LOG.error(e);
-                    }
-                }
-            }
-        }
-        
-        /*
-         * Read changes to quorum over time. To determine if there has been changes during
-         * writes to the ledger, check if there is a znode called quorumEvolution.
-         */
-        if(zk.exists(BKDefs.prefix + 
-                getZKStringId(lh.getId()) +  
-                BKDefs.quorumEvolution, false) != null){
-                    String path = BKDefs.prefix + 
-                    getZKStringId(lh.getId()) +  
-                    BKDefs.quorumEvolution;
-                    
-                    List<String> faultList = zk.getChildren(path, false);
-                    try{
-                        for(String s : faultList){
-                            LOG.debug(""Faulty list child: "" + s);
-                            long entry = Long.parseLong(s);
-                            String addresses = new String(zk.getData(path + ""/"" + s, false, stat));
-                            String parts[] = addresses.split("" "");
+  /**
+   * Open existing ledger asynchronously for reading.
+   * 
+   * @param lId
+   *          ledger identifier
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @param ctx
+   *          optional control object
+   */
+  public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],
+      OpenCallback cb, Object ctx) {
 
-                            ArrayList<BookieHandle> newBookieSet = new ArrayList<BookieHandle>();
-                            for(int i = 0 ; i < parts.length ; i++){
-                                LOG.debug(""Address: "" + parts[i]);
-                                InetSocketAddress faultyBookie =  
-                                    parseAddr(parts[i].substring(1));                           
-                        
-                                newBookieSet.add(lh.getBookieHandleDup(faultyBookie));
-                            }
-                            lh.setNewBookieConfig(entry, newBookieSet);
-                            LOG.debug(""NewBookieSet size: "" + newBookieSet.size());
-                        }
+    new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiate();
 
-                        lh.prepareEntryChange();
-                    } catch (NumberFormatException e) {
-                        LOG.error(""Error when parsing the ledger identifier"", e);
-                    }
-                }
-      
-        /*
-         *  Return ledger handler
-         */
-        return lh;
-    }    
-    
-    public void asyncOpenLedger(long lId, byte passwd[], OpenCallback cb, Object ctx)
-    throws InterruptedException{
-        OpenLedgerOp op = new OpenLedgerOp(lId, 
-                passwd,  
-                cb, 
-                ctx);
-        LedgerManagementProcessor lmp = getMngProcessor();
-        lmp.addOp(op);
-    }
-    
-    /**
-     * Parses address into IP and port.
-     * 
-     *  @param addr	String
+  }
+
+  /**
+   * Callback method for synchronous open operation
+   * 
+   * @param rc
+   *          return code
+   * @param lh
+   *          ledger handle
+   * @param ctx
+   *          optional control object
+   */
+  public void openComplete(int rc, LedgerHandle lh, Object ctx) {
+    SyncCounter counter = (SyncCounter) ctx;
+    counter.setLh(lh);
+
+    LOG.debug(""Open complete: "" + rc);
+
+    counter.setrc(rc);
+    counter.dec();
+  }
+
+  /**
+   * Synchronous open ledger call
+   * 
+   * @param lId
+   *          ledger identifier
+   * @param digestType
+   *          digest type, either MAC or CRC32
+   * @param passwd
+   *          password
+   * @return
+   * @throws InterruptedException
+   * @throws BKException
+   */
+
+  public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])
+      throws BKException, InterruptedException {
+    SyncCounter counter = new SyncCounter();
+    counter.inc();
+
+    /*
+     * Calls async open ledger
      */
-    
-    InetSocketAddress parseAddr(String s){
-        String parts[] = s.split("":"");
-        if (parts.length != 2) {
-            System.out.println(s
-                    + "" does not have the form host:port"");
-        }
-        InetSocketAddress addr = new InetSocketAddress(parts[0],
-                Integer.parseInt(parts[1]));
-        return addr;
-    }
-    
- 
-    /**
-     * Check if close node exists. 
-     * 
-     * @param ledgerId	id of the ledger to check
+    asyncOpenLedger(lId, digestType, passwd, this, counter);
+
+    /*
+     * Wait
      */
-    public boolean hasClosed(long ledgerId)
-    throws KeeperException, InterruptedException{
-        String closePath = BKDefs.prefix + getZKStringId(ledgerId) + BKDefs.close;
-        if(zk.exists(closePath, false) == null) return false;
-        else return true;
+    counter.block(0);
+    if (counter.getrc() != BKException.Code.OK)
+      throw BKException.create(counter.getrc());
+
+    return counter.getLh();
+  }
+
+  /**
+   * Shuts down client.
+   * 
+   */
+  public void halt() throws InterruptedException {
+    bookieClient.close();
+    bookieWatcher.halt();
+    if (ownChannelFactory) {
+      channelFactory.releaseExternalResources();
     }
-    
-    /**
-     * Recover a ledger that was not closed properly.
-     * 
-     * @param lId	ledger identifier
-     * @param passwd	password
-     */
-    
-    boolean recoverLedger(long lId, byte passwd[])
-    throws KeeperException, InterruptedException, IOException, BKException {
-        
-        Stat stat = null;
-       
-        LOG.info(""Recovering ledger"");
-        
-        /*
-         * Get quorum size.
-         */
-        ByteBuffer bb = ByteBuffer.wrap(zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumSize, false, stat));
-        int qSize = bb.getInt();
-                
-        
-        /*
-         * Get children of ""/ledgers/id/ensemble"" 
-         */
-        
-        List<String> list = 
-            zk.getChildren(BKDefs.prefix + getZKStringId(lId) + BKDefs.ensemble, false);
-        
-        ArrayList<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();
-        for(String s : list){
-            addresses.add(parseAddr(s));
-        }
-        
-        /*
-         * Quorum mode 
-         */
-        byte[] data = zk.getData(BKDefs.prefix + getZKStringId(lId) + BKDefs.quorumMode, false, stat);
-        ByteBuffer buf = ByteBuffer.wrap(data);
-        //int ordinal = buf.getInt();
-            
-        QMode qMode = QMode.VERIFIABLE;
-        switch(buf.getInt()){
-        case 0:
-            qMode = QMode.VERIFIABLE;
-            break;
-        case 1:
-            qMode = QMode.GENERIC;
-            break;
-        case 2:
-            qMode = QMode.FREEFORM;
-            break;
-        }
-        
-        /*
-         * Create ledger recovery monitor object
-         */
-        
-        LedgerRecoveryMonitor lrm = new LedgerRecoveryMonitor(this, lId, qSize, addresses, qMode);
-        
-        return lrm.recover(passwd);
+    if (ownZKHandle) {
+      zk.close();
     }
-    
-    /**
-     * Get new bookies
-     * 
-     * @param addrList	list of bookies to replace
-     */
-    InetSocketAddress getNewBookie(ArrayList<InetSocketAddress> addrList)
-    throws InterruptedException {
-        try{
-            // Get children from ""/ledgers/available"" on zk
-            List<String> list = 
-                zk.getChildren(""/ledgers/available"", false);
-            ArrayList<InetSocketAddress> lBookies = new ArrayList<InetSocketAddress>();
-    
-            for(String addr : list){
-                InetSocketAddress nAddr = parseAddr(addr); 
-                if(!addrList.contains(nAddr) &&
-                        !bookieBlackList.contains(nAddr))
-                    return nAddr;
-            }
-        } catch (KeeperException e){
-            LOG.error(""Problem accessing ZooKeeper: "" + e);
-        }
-        
-        return null;
-    }
-    
-    HashMap<InetSocketAddress, BookieHandle> bhMap = 
-    	new HashMap<InetSocketAddress, BookieHandle>();
-    
-    /**
-     *  Keeps a list of available BookieHandle objects and returns
-     *  the corresponding object given an address.
-     *  
-     *  @param	a	InetSocketAddress
-     */
-    
-    synchronized BookieHandle getBookieHandle(LedgerHandle lh, InetSocketAddress a)
-    throws ConnectException, IOException {
-    	if(!bhMap.containsKey(a)){
-    	    BookieHandle bh = new BookieHandle(a, true); 
-    		bhMap.put(a, bh);
-    		bh.start();
-    	}
-    	bhMap.get(a).incRefCount(lh);
-    	
-    	return bhMap.get(a);
-    }
-    
-    /**
-     * When there are no more references to a BookieHandle,
-     * remove it from the list. 
-     */
-    
-    synchronized void haltBookieHandles(LedgerHandle lh, ArrayList<BookieHandle> bookies){
-        while(bookies.size() > 0){
-            BookieHandle bh = bookies.remove(0);
-            if(bh.halt(lh) <= 0)
-                bhMap.remove(bh.addr);
-        }
-    }
-    
-    /**
-     * Blacklists bookies.
-     * 
-     * @param addr 	address of bookie
-     */
-    void blackListBookie(InetSocketAddress addr){
-        bookieBlackList.add(addr);
-    }
-    
-    /**
-     * Halts all bookie handles
-     * 
-     */
-    public void halt() throws InterruptedException{
-        
-        for(BookieHandle bh: bhMap.values()){
-            bh.shutdown();
-        }
-        zk.close();
-    }
+    callbackWorker.shutdown();
+    mainWorkerPool.shutdown();
+  }
 }
",,6461
2506,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/ClientCBWorker.java,c41bd3f83e6ad99f03261ba21295eed5151eadda,1241599788,90,ba65c32347b12607cfa8160088b442e2f56a837e,1243486840,90,,,,,"            instance = null;",,,6461
2507,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeperMain.java,b7091d6cda358a4fe5dac9c27d402e82dba1e424,1241735676,148,76e038779ec1e22225d0ca69f5a1284ce3a46f32,1245363764,153,0a1f589b1ce96c09eb71b5492ece6bc99bfeec13,1249072322,-1,1249072322/1241735676,"            options = null; command = null;","      */
     static private class MyCommandOptions {
 
-        private Map<String,String> options = null;
+        private Map<String,String> options = new HashMap<String,String>();
         private List<String> cmdArgs = null;
         private String command = null;
 
         public MyCommandOptions() {
-            options = null; command = null;
+          options.put(""server"", ""localhost:2181"");
+          options.put(""timeout"", ""30000"");
         }
 
         public String getOption(String opt) {
",,6461
2508,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeperMain.java,b7091d6cda358a4fe5dac9c27d402e82dba1e424,1241735676,148,,,,0a1f589b1ce96c09eb71b5492ece6bc99bfeec13,1249072322,-1,1249072322/1241735676,"            options = null; command = null;","      */
     static private class MyCommandOptions {
 
-        private Map<String,String> options = null;
+        private Map<String,String> options = new HashMap<String,String>();
         private List<String> cmdArgs = null;
         private String command = null;
 
         public MyCommandOptions() {
-            options = null; command = null;
+          options.put(""server"", ""localhost:2181"");
+          options.put(""timeout"", ""30000"");
         }
 
         public String getOption(String opt) {
",,6461
2509,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,147,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,178,,,,,"                data64 = null;",,,6461
2510,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,148,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,179,,,,,"                dataUtf8 = null;",,,6461
2511,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,151,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,182,,,,,"                dataUtf8 = null;",,,6461
2512,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,153,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,184,,,,,"                data64 = null;",,,6461
2513,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,211,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,240,,,,,"            data = null;",,,6461
2514,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,251,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,277,,,,,"            data = null;",,,6461
2515,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,282,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,314,,,,,"            data = null;",,,6461
2516,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,1cd080633bff3e8668f62149316d416698582b35,1241760420,324,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,365,,,,,"            data = null;",,,6461
2517,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/JMXEnv.java,382cce4d71475d3101cdd2caa57ccdae1064ee7c,1242332106,67,7a929407de4704f6ed27958075caddc6cb3f6508,1401912443,68,,,,,"        cc = null;",,,6461
2518,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/JMXEnv.java,382cce4d71475d3101cdd2caa57ccdae1064ee7c,1242332106,74,7a929407de4704f6ed27958075caddc6cb3f6508,1401912443,75,,,,,"        cs = null;",,,6461
2519,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,459,2be6b4dc25b55d86d15a68519a8b19630feaa4de,1304093564,609,,,,,"                        jmxLocalPeerBean = null;",,,6461
2520,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,472,,,,,,,,"            jmxQuorumBean = null;",,,6461
2521,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,e936eceb9e75aee9f2cd245b9cc7709a2e7b4ded,1242850593,529,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,533,,,,,"            jmxLocalPeerBean = null;",,,6461
2522,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,0959e89f8bfd67735be718542872582ec1ce792d,1244006056,522,016f8c2ab755536ccc5daf953108978e9e0e9513,1244007179,497,,,,,"            node.parent = null;",,,6461
2523,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,320fd3b0c9eddec2e6336f557e675b28ed33fffe,1244523876,808,9107bbaf5f94ea0c70bcaae458538c95aeb61454,1249601012,816,,,,,"        jmxConnectionBean = null;",,,6461
2524,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,3402537c1f8d8301b6e16e6cebc8c1e655aa14bf,1245343069,527,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,539,,,,,"            node.parent = null;",,,6461
2525,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java,e0316743684e9ef208cfe68efc28929ecfad5e67,1245820043,95,,,,,,,,"            this.client = null;",,,6461
2526,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,302,d43038a0c8b8881fb4624ef20a7b30b8511e6b24,1287621845,362,,,,,"                this.chrootPath = null;",,,6461
2527,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,309,d43038a0c8b8881fb4624ef20a7b30b8511e6b24,1287621845,369,,,,,"            this.chrootPath = null;",,,6461
2528,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,767,,,,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2529,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,807,,,,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2530,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,920,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2531,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,1201,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2532,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,e3650bf5dd0bc427fc8000821ae70e69c563863f,1245884374,1242,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,1258056155,1256,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2533,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,8d2ae28491342663d9290114b8ecb182d6aa903e,1246394829,493,,,,,,,,"                    recvWorker = null;",,,6461
2534,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,a44fae6243a6363d0e07f3ba1275f8ecd3f5deb5,1247782180,354,28573d112600863f6918a963cb3583a09d69aa1e,1449433807,492,,,,,"        serverFactory = null;",,,6461
2535,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,a44fae6243a6363d0e07f3ba1275f8ecd3f5deb5,1247782180,369,0a7c3b05744008862e1875dd6a651aa2a36d8cef,1251179124,369,,,,,"            allClients = null;",,,6461
2536,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,a44fae6243a6363d0e07f3ba1275f8ecd3f5deb5,1247782180,387,a1a877a468b9bf1adeace989cb0e55d74a1e5d5f,1270009589,469,,,,,"        serverFactory = null;",,,6461
2537,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8d14195dd1c20e5ed8d648eee6ab5702a7a8e86a,1249668048,808,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,1258056155,822,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2538,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8d14195dd1c20e5ed8d648eee6ab5702a7a8e86a,1249668048,848,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,1258056155,862,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2539,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8d14195dd1c20e5ed8d648eee6ab5702a7a8e86a,1249668048,961,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,1258056155,975,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2540,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8d14195dd1c20e5ed8d648eee6ab5702a7a8e86a,1249668048,1242,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2541,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,8d14195dd1c20e5ed8d648eee6ab5702a7a8e86a,1249668048,1283,e3b97366f8064a6d65a3eb1c44e1191e5e73a5c3,1257554884,1422,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2542,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,8b22eb1e4b8bfe4be08a766a98f636149e62fb28,1250024972,564,788c15be7363e475e8b050260623ec46c9ef8257,1258571199,564,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2543,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,6e69b7cc29200ad553154bef32b43e448c610092,1253059787,391,a1a877a468b9bf1adeace989cb0e55d74a1e5d5f,1270009589,438,,,,,"            allClients = null;",,,6461
2544,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,99,66646796c2173423655c7faf2b458b658143e6b5,1395380171,108,,,,,"            jmxDataTreeBean = null;",,,6461
2545,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,113,66646796c2173423655c7faf2b458b658143e6b5,1395380171,122,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2546,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,121,66646796c2173423655c7faf2b458b658143e6b5,1395380171,130,,,,,"            jmxServerBean = null;",,,6461
2547,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,135,66646796c2173423655c7faf2b458b658143e6b5,1395380171,144,,,,,"        jmxDataTreeBean = null;",,,6461
2548,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java,0957b8404e1ecfc5703d7c2827752773b7dc23be,1256919553,147,b71191f514a2eec512f795e43a25c64d48f0e4c7,1381350115,149,,,,,"        jmxServerBean = null;",,,6461
2549,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,82a9d1d0a24147dcb533542559d61783058f1a1b,1256944166,1287,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,1529,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2550,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,82a9d1d0a24147dcb533542559d61783058f1a1b,1256944166,1368,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,1258056155,1383,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2551,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,e3b97366f8064a6d65a3eb1c44e1191e5e73a5c3,1257554884,1123,,,,,,,,"            sockKey = null;",,,6461
2552,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,e3b97366f8064a6d65a3eb1c44e1191e5e73a5c3,1257554884,936,5ac3e719264a917674ded90490d5554c9a4da76c,1259879444,961,,,,,"        jmxConnectionBean = null;",,,6461
2553,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,e3b97366f8064a6d65a3eb1c44e1191e5e73a5c3,1257554884,999,5ac3e719264a917674ded90490d5554c9a4da76c,1259879444,1020,6206b495e0c7a8ff3bb7a30cbddf2dd8f02f6dfc,1355940434,-1,1355940434/1257554884,"        sock = null;","         }
         try {
             sock.close();
-            // XXX The next line doesn't seem to be needed, but some posts
-            // to forums suggest that it is needed. Keep in mind if errors in
-            // this section arise.
-            // factory.selector.wakeup();
         } catch (IOException e) {
             if (LOG.isDebugEnabled()) {
                 LOG.debug(""ignoring exception during socketchannel close"", e);
             }
         }
-        sock = null;
     }
-    
+
     private final static byte fourBytes[] = new byte[4];
 
     /*
",,6461
2554,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,e3b97366f8064a6d65a3eb1c44e1191e5e73a5c3,1257554884,1086,47c4bdb0c3c40d756ec0ced91a39c771351e826a,1258055587,1106,,,,,"            jmxConnectionBean = null;",,,6461
2555,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,1258056155,1430,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2556,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,4a425c4e4911f1d4463f098a1c030b9920e391c0,1258066080,1099,81728143a79b7135977e602da85bf43c5b8c8af3,1316040924,1215,,,,,"        root = null;",,,6461
2557,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,788c15be7363e475e8b050260623ec46c9ef8257,1258571199,534,2be6b4dc25b55d86d15a68519a8b19630feaa4de,1304093564,596,,,,,"                        jmxLocalPeerBean = null;",,,6461
2558,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,788c15be7363e475e8b050260623ec46c9ef8257,1258571199,616,2be6b4dc25b55d86d15a68519a8b19630feaa4de,1304093564,678,,,,,"            jmxQuorumBean = null;",,,6461
2559,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,788c15be7363e475e8b050260623ec46c9ef8257,1258571199,617,2be6b4dc25b55d86d15a68519a8b19630feaa4de,1304093564,679,,,,,"            jmxLocalPeerBean = null;",,,6461
2560,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,154647fa5d8cbb8e03dcace62707e1ce8f678fd6,1259778984,1112,5ac3e719264a917674ded90490d5554c9a4da76c,1259879444,1103,,,,,"            jmxConnectionBean = null;",,,6461
2561,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,6b9c7c225e6f6d4a763ea8cc4e1ccac7aa265915,1259970450,976,dc9671d387830ccdea3faade5e7f388cb10518ae,1268109866,1218,df20416c08fa0079d96f6327d10c6f102ebabd85,1268277424,-1,1268277424/1259970450,"        jmxConnectionBean = null;","     }
 
     /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.zookeeper.server.ServerCnxnIface#close()
+     * Close the cnxn and remove it from the factory cnxns list.
+     * 
+     * This function returns immediately if the cnxn is not on the cnxns list.
      */
     public void close() {
-        // unregister from JMX
-        try {
-            if(jmxConnectionBean != null){
-                MBeanRegistry.getInstance().unregister(jmxConnectionBean);
+        synchronized(factory.cnxns){
+            // if this is not in cnxns then it's already closed
+            if (!factory.cnxns.remove(this)) {
+                return;
             }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxConnectionBean = null;
 
-        synchronized (factory.ipMap)
-        {
-            Set<NIOServerCnxn> s = factory.ipMap.get(sock.socket().getInetAddress());
-            s.remove(this);
+            synchronized (factory.ipMap) {
+                Set<NIOServerCnxn> s =
+                    factory.ipMap.get(sock.socket().getInetAddress());
+                s.remove(this);
+            }
+
+            // unregister from JMX
+            try {
+                if(jmxConnectionBean != null){
+                    MBeanRegistry.getInstance().unregister(jmxConnectionBean);
+                }
+            } catch (Exception e) {
+                LOG.warn(""Failed to unregister with JMX"", e);
+            }
+            jmxConnectionBean = null;
+    
+            if (zk != null) {
+                zk.removeCnxn(this);
+            }
+    
+            closeSock();
+    
+            if (sk != null) {
+                try {
+                    // need to cancel this selection key from the selector
+                    sk.cancel();
+                } catch (Exception e) {
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""ignoring exception during selectionkey cancel"", e);
+                    }
+                }
+            }
         }
-        synchronized (factory.cnxns) {
-            factory.cnxns.remove(this);
-        }
-        if (zk != null) {
-            zk.removeCnxn(this);
+    }
+
+    /**
+     * Close resources associated with the sock of this cnxn. 
+     */
+    private void closeSock() {
+        if (sock == null) {
+            return;
         }
 
         LOG.info(""Closed socket connection for client ""
",,6461
2562,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,6b9c7c225e6f6d4a763ea8cc4e1ccac7aa265915,1259970450,1035,dc9671d387830ccdea3faade5e7f388cb10518ae,1268109866,1277,,,,,"        sock = null;",,,6461
2563,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,6b9c7c225e6f6d4a763ea8cc4e1ccac7aa265915,1259970450,1118,73f0ff946205e6054e72249fc0399c6e94b30a80,1264390120,1123,,,,,"            jmxConnectionBean = null;",,,6461
2564,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,47356252a1371452afc3bf371f569cb815d71e29,1260567966,1132,d43038a0c8b8881fb4624ef20a7b30b8511e6b24,1287621845,1252,,,,,"            sockKey = null;",,,6461
2565,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,c387421cb46ea919b0759981ed9bd44123419c14,1260571339,976,,,,,,,,"        jmxConnectionBean = null;",,,6461
2566,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,c387421cb46ea919b0759981ed9bd44123419c14,1260571339,1035,,,,,,,,"        sock = null;",,,6461
2567,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,c387421cb46ea919b0759981ed9bd44123419c14,1260571339,1118,,,,,,,,"            jmxConnectionBean = null;",,,6461
2568,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,a8a73362bd9a3967c46011ded1ed831a586acd2e,1260915835,634,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,648,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2569,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,824,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,1567,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2570,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,864,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,1142,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2571,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,937,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,1215,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2572,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,977,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,1255,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2573,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,1258,59ecde5ed38f0c6701d818841446793214cf702e,1387299329,1980,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2574,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,1300,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,1578,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2575,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,1385,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,1663,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2576,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3ab8e2e2f87fc730a13181fa0e1e4ddb4ecadad3,1262712755,1432,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,1710,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2577,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,5aea0fbbae6fab464b932339c00051f179eb0343,1264465043,917,b99ef6bc93b7d27ee9359bcd1b4d56856445394d,1268418405,940,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2578,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,5aea0fbbae6fab464b932339c00051f179eb0343,1264465043,1357,,,,,,,,"            jmxConnectionBean = null;",,,6461
2579,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/LedgerCache.java,e1a1ee81f1aa930cae20fa3fc76485e45a95f066,1264547805,202,38592a9e79e8c5f8ba8d6a709c7c28e7084030fc,1273782215,209,,,,,"                    lf = null;",,,6461
2580,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java,e1a1ee81f1aa930cae20fa3fc76485e45a95f066,1264547805,129,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,1278708816,131,,,,,"                        channel = null;",,,6461
2581,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/ServerStats.java,e1a1ee81f1aa930cae20fa3fc76485e45a95f066,1264547805,44,,,,,,,,"        instance = null;",,,6461
2582,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java,32a5d09b3bc5088e32b065fd3c011628ca37dbed,1268096775,177,3d68334a22dbbab796df96c399a33553cd4a08a7,1380818752,196,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,-1,1396574677/1268096775,"                this.zooKeeper = null;","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.zookeeper.inspector.manager;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileReader;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-import org.apache.zookeeper.CreateMode;
-import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.WatchedEvent;
-import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZooKeeper;
-import org.apache.zookeeper.Watcher.Event.EventType;
-import org.apache.zookeeper.Watcher.Event.KeeperState;
-import org.apache.zookeeper.ZooDefs.Ids;
-import org.apache.zookeeper.ZooDefs.Perms;
-import org.apache.zookeeper.data.ACL;
-import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager;
-import org.apache.zookeeper.inspector.encryption.DataEncryptionManager;
-import org.apache.zookeeper.inspector.logger.LoggerFactory;
-import org.apache.zookeeper.retry.ZooKeeperRetry;
-
-/**
- * A default implementation of {@link ZooInspectorManager} for connecting to
- * zookeeper instances
- */
-public class ZooInspectorManagerImpl implements ZooInspectorManager {
-    private static final String A_VERSION = ""ACL Version"";
-    private static final String C_TIME = ""Creation Time"";
-    private static final String C_VERSION = ""Children Version"";
-    private static final String CZXID = ""Creation ID"";
-    private static final String DATA_LENGTH = ""Data Length"";
-    private static final String EPHEMERAL_OWNER = ""Ephemeral Owner"";
-    private static final String M_TIME = ""Last Modified Time"";
-    private static final String MZXID = ""Modified ID"";
-    private static final String NUM_CHILDREN = ""Number of Children"";
-    private static final String PZXID = ""Node ID"";
-    private static final String VERSION = ""Data Version"";
-    private static final String ACL_PERMS = ""Permissions"";
-    private static final String ACL_SCHEME = ""Scheme"";
-    private static final String ACL_ID = ""Id"";
-    private static final String SESSION_STATE = ""Session State"";
-    private static final String SESSION_ID = ""Session ID"";
-    /**
-     * The key used for the connect string in the connection properties file
-     */
-    public static final String CONNECT_STRING = ""hosts"";
-    /**
-     * The key used for the session timeout in the connection properties file
-     */
-    public static final String SESSION_TIMEOUT = ""timeout"";
-    /**
-     * The key used for the data encryption manager in the connection properties
-     * file
-     */
-    public static final String DATA_ENCRYPTION_MANAGER = ""encryptionManager"";
-    /**
-     * The key used for the authentication scheme in the connection properties file
-     */
-    public static final String AUTH_SCHEME_KEY = ""authScheme"";
-    /**
-     * The key used for the authentication data in the connection properties file
-     */
-    public static final String AUTH_DATA_KEY = ""authData"";
-
-
-    private static final File defaultNodeViewersFile = new File(
-            ""./config/defaultNodeViewers.cfg"");
-    private static final File defaultConnectionFile = new File(
-            ""./config/defaultConnectionSettings.cfg"");
-
-    private DataEncryptionManager encryptionManager;
-    private String connectString;
-    private int sessionTimeout;
-    private ZooKeeper zooKeeper;
-    private final Map<String, NodeWatcher> watchers = new HashMap<String, NodeWatcher>();
-    protected boolean connected = true;
-    private Properties lastConnectionProps;
-    private String defaultEncryptionManager;
-    private String defaultTimeout;
-    private String defaultHosts;
-    private String defaultAuthScheme;
-    private String defaultAuthValue;
-
-    /**
-     * @throws IOException
-     *             - thrown if the default connection settings cannot be loaded
-     * 
-     */
-    public ZooInspectorManagerImpl() throws IOException {
-        loadDefaultConnectionFile();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#connect(java
-     * .util.Properties)
-     */
-    public boolean connect(Properties connectionProps) {
-        try {
-            if (this.zooKeeper == null) {
-                String connectString = connectionProps
-                        .getProperty(CONNECT_STRING);
-                String sessionTimeout = connectionProps
-                        .getProperty(SESSION_TIMEOUT);
-                String encryptionManager = connectionProps
-                        .getProperty(DATA_ENCRYPTION_MANAGER);
-                String authScheme = connectionProps
-                        .getProperty(AUTH_SCHEME_KEY);
-                String authData = connectionProps
-                        .getProperty(AUTH_DATA_KEY);
-
-                if (connectString == null || sessionTimeout == null) {
-                    throw new IllegalArgumentException(
-                            ""Both connect string and session timeout are required."");
-                }
-                if (encryptionManager == null) {
-                    this.encryptionManager = new BasicDataEncryptionManager();
-                } else {
-                    Class<?> clazz = Class.forName(encryptionManager);
-
-                    if (Arrays.asList(clazz.getInterfaces()).contains(
-                            DataEncryptionManager.class)) {
-                        this.encryptionManager = (DataEncryptionManager) Class
-                                .forName(encryptionManager).newInstance();
-                    } else {
-                        throw new IllegalArgumentException(
-                                ""Data encryption manager must implement DataEncryptionManager interface"");
-                    }
-                }
-                this.connectString = connectString;
-                this.sessionTimeout = Integer.valueOf(sessionTimeout);
-                this.zooKeeper = new ZooKeeperRetry(connectString, Integer
-                        .valueOf(sessionTimeout), new Watcher() {
-
-                    public void process(WatchedEvent event) {
-                        if (event.getState() == KeeperState.Expired) {
-                            connected = false;
-                        }
-                    }
-                });
-                if (authData != null && authData.length() > 0){
-                    this.zooKeeper.addAuthInfo(authScheme, authData.getBytes());
-                }
-                ((ZooKeeperRetry) this.zooKeeper).setRetryLimit(10);
-                connected = ((ZooKeeperRetry) this.zooKeeper).testConnection();
-            }
-        } catch (Exception e) {
-            connected = false;
-            e.printStackTrace();
-        }
-        if (!connected){
-        	disconnect();
-        }
-        return connected;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#disconnect()
-     */
-    public boolean disconnect() {
-        try {
-            if (this.zooKeeper != null) {
-                this.zooKeeper.close();
-                this.zooKeeper = null;
-                connected = false;
-                removeWatchers(this.watchers.keySet());
-                return true;
-            }
-        } catch (Exception e) {
-            LoggerFactory.getLogger().error(
-                    ""Error occurred while disconnecting from ZooKeeper server"",
-                    e);
-        }
-        return false;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * getChildren(java.lang.String)
-     */
-    public List<String> getChildren(String nodePath) {
-        if (connected) {
-            try {
-
-                return zooKeeper.getChildren(nodePath, false);
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred retrieving children of node: ""
-                                + nodePath, e);
-            }
-        }
-        return null;
-
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#getData
-     * (java.lang.String)
-     */
-    public String getData(String nodePath) {
-        if (connected) {
-            try {
-                if (nodePath.length() == 0) {
-                    nodePath = ""/"";
-                }
-                Stat s = zooKeeper.exists(nodePath, false);
-                if (s != null) {
-                    return this.encryptionManager.decryptData(zooKeeper
-                            .getData(nodePath, false, s));
-                }
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred getting data for node: "" + nodePath, e);
-            }
-        }
-        return null;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * getNodeChild(java.lang.String, int)
-     */
-    public String getNodeChild(String nodePath, int childIndex) {
-        if (connected) {
-            try {
-                Stat s = zooKeeper.exists(nodePath, false);
-                if (s != null) {
-                    return this.zooKeeper.getChildren(nodePath, false).get(
-                            childIndex);
-                }
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred retrieving child "" + childIndex
-                                + "" of node: "" + nodePath, e);
-            }
-        }
-        return null;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * getNodeIndex(java.lang.String)
-     */
-    public int getNodeIndex(String nodePath) {
-        if (connected) {
-            int index = nodePath.lastIndexOf(""/"");
-            if (index == -1
-                    || (!nodePath.equals(""/"") && nodePath.charAt(nodePath
-                            .length() - 1) == '/')) {
-                throw new IllegalArgumentException(""Invalid node path: ""
-                        + nodePath);
-            }
-            String parentPath = nodePath.substring(0, index);
-            String child = nodePath.substring(index + 1);
-            if (parentPath != null && parentPath.length() > 0) {
-                List<String> children = this.getChildren(parentPath);
-                if (children != null) {
-                    return children.indexOf(child);
-                }
-            }
-        }
-        return -1;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#getACLs
-     * (java.lang.String)
-     */
-    public List<Map<String, String>> getACLs(String nodePath) {
-        List<Map<String, String>> returnACLs = new ArrayList<Map<String, String>>();
-        if (connected) {
-            try {
-                if (nodePath.length() == 0) {
-                    nodePath = ""/"";
-                }
-                Stat s = zooKeeper.exists(nodePath, false);
-                if (s != null) {
-                    List<ACL> acls = zooKeeper.getACL(nodePath, s);
-                    for (ACL acl : acls) {
-                        Map<String, String> aclMap = new LinkedHashMap<String, String>();
-                        aclMap.put(ACL_SCHEME, acl.getId().getScheme());
-                        aclMap.put(ACL_ID, acl.getId().getId());
-                        StringBuilder sb = new StringBuilder();
-                        int perms = acl.getPerms();
-                        boolean addedPerm = false;
-                        if ((perms & Perms.READ) == Perms.READ) {
-                            sb.append(""Read"");
-                            addedPerm = true;
-                        }
-                        if (addedPerm) {
-                            sb.append("", "");
-                        }
-                        if ((perms & Perms.WRITE) == Perms.WRITE) {
-                            sb.append(""Write"");
-                            addedPerm = true;
-                        }
-                        if (addedPerm) {
-                            sb.append("", "");
-                        }
-                        if ((perms & Perms.CREATE) == Perms.CREATE) {
-                            sb.append(""Create"");
-                            addedPerm = true;
-                        }
-                        if (addedPerm) {
-                            sb.append("", "");
-                        }
-                        if ((perms & Perms.DELETE) == Perms.DELETE) {
-                            sb.append(""Delete"");
-                            addedPerm = true;
-                        }
-                        if (addedPerm) {
-                            sb.append("", "");
-                        }
-                        if ((perms & Perms.ADMIN) == Perms.ADMIN) {
-                            sb.append(""Admin"");
-                            addedPerm = true;
-                        }
-                        aclMap.put(ACL_PERMS, sb.toString());
-                        returnACLs.add(aclMap);
-                    }
-                }
-            } catch (InterruptedException e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred retrieving ACLs of node: "" + nodePath,
-                        e);
-            } catch (KeeperException e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred retrieving ACLs of node: "" + nodePath,
-                        e);
-            }
-        }
-        return returnACLs;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * getNodeMeta(java.lang.String)
-     */
-    public Map<String, String> getNodeMeta(String nodePath) {
-        Map<String, String> nodeMeta = new LinkedHashMap<String, String>();
-        if (connected) {
-            try {
-                if (nodePath.length() == 0) {
-                    nodePath = ""/"";
-                }
-                Stat s = zooKeeper.exists(nodePath, false);
-                if (s != null) {
-                    nodeMeta.put(A_VERSION, String.valueOf(s.getAversion()));
-                    nodeMeta.put(C_TIME, String.valueOf(s.getCtime()));
-                    nodeMeta.put(C_VERSION, String.valueOf(s.getCversion()));
-                    nodeMeta.put(CZXID, String.valueOf(s.getCzxid()));
-                    nodeMeta
-                            .put(DATA_LENGTH, String.valueOf(s.getDataLength()));
-                    nodeMeta.put(EPHEMERAL_OWNER, String.valueOf(s
-                            .getEphemeralOwner()));
-                    nodeMeta.put(M_TIME, String.valueOf(s.getMtime()));
-                    nodeMeta.put(MZXID, String.valueOf(s.getMzxid()));
-                    nodeMeta.put(NUM_CHILDREN, String.valueOf(s
-                            .getNumChildren()));
-                    nodeMeta.put(PZXID, String.valueOf(s.getPzxid()));
-                    nodeMeta.put(VERSION, String.valueOf(s.getVersion()));
-                }
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred retrieving meta data for node: ""
-                                + nodePath, e);
-            }
-        }
-        return nodeMeta;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * getNumChildren(java.lang.String)
-     */
-    public int getNumChildren(String nodePath) {
-        if (connected) {
-            try {
-                Stat s = zooKeeper.exists(nodePath, false);
-                if (s != null) {
-                    return s.getNumChildren();
-                }
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred getting the number of children of node: ""
-                                + nodePath, e);
-            }
-        }
-        return -1;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * hasChildren(java.lang.String)
-     */
-    public boolean hasChildren(String nodePath) {
-        return getNumChildren(nodePath) > 0;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * isAllowsChildren(java.lang.String)
-     */
-    public boolean isAllowsChildren(String nodePath) {
-        if (connected) {
-            try {
-                Stat s = zooKeeper.exists(nodePath, false);
-                if (s != null) {
-                    return s.getEphemeralOwner() == 0;
-                }
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred determining whether node is allowed children: ""
-                                + nodePath, e);
-            }
-        }
-        return false;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
-     * getSessionMeta()
-     */
-    public Map<String, String> getSessionMeta() {
-        Map<String, String> sessionMeta = new LinkedHashMap<String, String>();
-        try {
-            if (zooKeeper != null) {
-
-                sessionMeta.put(SESSION_ID, String.valueOf(zooKeeper
-                        .getSessionId()));
-                sessionMeta.put(SESSION_STATE, String.valueOf(zooKeeper
-                        .getState().toString()));
-                sessionMeta.put(CONNECT_STRING, this.connectString);
-                sessionMeta.put(SESSION_TIMEOUT, String
-                        .valueOf(this.sessionTimeout));
-            }
-        } catch (Exception e) {
-            LoggerFactory.getLogger().error(
-                    ""Error occurred retrieving session meta data."", e);
-        }
-        return sessionMeta;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorNodeTreeManager#createNode
-     * (java.lang.String, java.lang.String)
-     */
-    public boolean createNode(String parent, String nodeName) {
-        if (connected) {
-            try {
-                String[] nodeElements = nodeName.split(""/"");
-                for (String nodeElement : nodeElements) {
-                    String node = parent + ""/"" + nodeElement;
-                    Stat s = zooKeeper.exists(node, false);
-                    if (s == null) {
-                        zooKeeper.create(node, this.encryptionManager
-                                .encryptData(null), Ids.OPEN_ACL_UNSAFE,
-                                CreateMode.PERSISTENT);
-                        parent = node;
-                    }
-                }
-                return true;
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred creating node: "" + parent + ""/""
-                                + nodeName, e);
-            }
-        }
-        return false;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorNodeTreeManager#deleteNode
-     * (java.lang.String)
-     */
-    public boolean deleteNode(String nodePath) {
-        if (connected) {
-            try {
-                Stat s = zooKeeper.exists(nodePath, false);
-                if (s != null) {
-                    List<String> children = zooKeeper.getChildren(nodePath,
-                            false);
-                    for (String child : children) {
-                        String node = nodePath + ""/"" + child;
-                        deleteNode(node);
-                    }
-                    zooKeeper.delete(nodePath, -1);
-                }
-                return true;
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred deleting node: "" + nodePath, e);
-            }
-        }
-        return false;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorNodeManager#setData
-     * (java.lang.String, java.lang.String)
-     */
-    public boolean setData(String nodePath, String data) {
-        if (connected) {
-            try {
-                zooKeeper.setData(nodePath, this.encryptionManager
-                        .encryptData(data), -1);
-                return true;
-            } catch (Exception e) {
-                LoggerFactory.getLogger().error(
-                        ""Error occurred setting data for node: "" + nodePath, e);
-            }
-        }
-        return false;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
-     * getConnectionPropertiesTemplate()
-     */
-    public Pair<Map<String, List<String>>, Map<String, String>> getConnectionPropertiesTemplate() {
-        Map<String, List<String>> template = new LinkedHashMap<String, List<String>>();
-        template.put(CONNECT_STRING, Arrays
-                .asList(new String[] { defaultHosts }));
-        template.put(SESSION_TIMEOUT, Arrays
-                .asList(new String[] { defaultTimeout }));
-        template.put(DATA_ENCRYPTION_MANAGER, Arrays
-                .asList(new String[] { defaultEncryptionManager }));
-        template.put(AUTH_SCHEME_KEY, Arrays
-                .asList(new String[] { defaultAuthScheme }));
-        template.put(AUTH_DATA_KEY, Arrays
-                .asList(new String[] { defaultAuthValue }));
-        Map<String, String> labels = new LinkedHashMap<String, String>();
-        labels.put(CONNECT_STRING, ""Connect String"");
-        labels.put(SESSION_TIMEOUT, ""Session Timeout"");
-        labels.put(DATA_ENCRYPTION_MANAGER, ""Data Encryption Manager"");
-        labels.put(AUTH_SCHEME_KEY, ""Authentication Scheme"");
-        labels.put(AUTH_DATA_KEY, ""Authentication Data"");
-        return new Pair<Map<String, List<String>>, Map<String, String>>(
-                template, labels);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#addWatchers
-     * (java.util.Collection,
-     * org.apache.zookeeper.inspector.manager.NodeListener)
-     */
-    public void addWatchers(Collection<String> selectedNodes,
-            NodeListener nodeListener) {
-        // add watcher for each node and add node to collection of
-        // watched nodes
-        if (connected) {
-            for (String node : selectedNodes) {
-                if (!watchers.containsKey(node)) {
-                    try {
-                        watchers.put(node, new NodeWatcher(node, nodeListener,
-                                zooKeeper));
-                    } catch (Exception e) {
-                        LoggerFactory.getLogger().error(
-                                ""Error occured adding node watcher for node: ""
-                                        + node, e);
-                    }
-                }
-            }
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#removeWatchers
-     * (java.util.Collection)
-     */
-    public void removeWatchers(Collection<String> selectedNodes) {
-        // remove watcher for each node and remove node from
-        // collection of watched nodes
-        if (connected) {
-            for (String node : selectedNodes) {
-                if (watchers.containsKey(node)) {
-                    NodeWatcher watcher = watchers.remove(node);
-                    if (watcher != null) {
-                        watcher.stop();
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * A Watcher which will re-add itself every time an event is fired
-     * 
-     */
-    public class NodeWatcher implements Watcher {
-
-        private final String nodePath;
-        private final NodeListener nodeListener;
-        private final ZooKeeper zookeeper;
-        private boolean closed = false;
-
-        /**
-         * @param nodePath
-         *            - the path to the node to watch
-         * @param nodeListener
-         *            the {@link NodeListener} for this node
-         * @param zookeeper
-         *            - a {@link ZooKeeper} to use to access zookeeper
-         * @throws InterruptedException
-         * @throws KeeperException
-         */
-        public NodeWatcher(String nodePath, NodeListener nodeListener,
-                ZooKeeper zookeeper) throws KeeperException,
-                InterruptedException {
-            this.nodePath = nodePath;
-            this.nodeListener = nodeListener;
-            this.zookeeper = zookeeper;
-            Stat s = zooKeeper.exists(nodePath, this);
-            if (s != null) {
-                zookeeper.getChildren(nodePath, this);
-            }
-        }
-
-        public void process(WatchedEvent event) {
-            if (!closed) {
-                try {
-                    if (event.getType() != EventType.NodeDeleted) {
-
-                        Stat s = zooKeeper.exists(nodePath, this);
-                        if (s != null) {
-                            zookeeper.getChildren(nodePath, this);
-                        }
-                    }
-                } catch (Exception e) {
-                    LoggerFactory.getLogger().error(
-                            ""Error occured re-adding node watcherfor node ""
-                                    + nodePath, e);
-                }
-                nodeListener.processEvent(event.getPath(), event.getType()
-                        .name(), null);
-            }
-        }
-
-        /**
-		 * 
-		 */
-        public void stop() {
-            this.closed = true;
-        }
-
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
-     * loadNodeViewersFile(java.io.File)
-     */
-    public List<String> loadNodeViewersFile(File selectedFile)
-            throws IOException {
-        List<String> result = new ArrayList<String>();
-        if (defaultNodeViewersFile.exists()) {
-            FileReader reader = new FileReader(selectedFile);
-            try {
-                BufferedReader buff = new BufferedReader(reader);
-                try {
-                    while (buff.ready()) {
-                        String line = buff.readLine();
-                        if (line != null && line.length() > 0 && !line.startsWith(""#"")) {
-                            result.add(line);
-                        }
-                    }
-                } finally {
-                    buff.close();
-                }
-            } finally {
-                reader.close();
-            }
-        }
-        return result;
-    }
-
-    private void loadDefaultConnectionFile() throws IOException {
-        if (defaultConnectionFile.exists()) {
-            Properties props = new Properties();
-
-            FileReader reader = new FileReader(defaultConnectionFile);
-            try {
-                props.load(reader);
-            } finally {
-                reader.close();
-            }
-            defaultEncryptionManager = props
-                    .getProperty(DATA_ENCRYPTION_MANAGER) == null ? ""org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager""
-                    : props.getProperty(DATA_ENCRYPTION_MANAGER);
-            defaultTimeout = props.getProperty(SESSION_TIMEOUT) == null ? ""5000""
-                    : props.getProperty(SESSION_TIMEOUT);
-            defaultHosts = props.getProperty(CONNECT_STRING) == null ? ""localhost:2181""
-                    : props.getProperty(CONNECT_STRING);
-            defaultAuthScheme = props.getProperty(AUTH_SCHEME_KEY) == null ? """"
-                    : props.getProperty(AUTH_SCHEME_KEY);
-            defaultAuthValue = props.getProperty(AUTH_DATA_KEY) == null ? """"
-                    : props.getProperty(AUTH_DATA_KEY);
-        } else {
-            defaultEncryptionManager = ""org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager"";
-            defaultTimeout = ""5000"";
-            defaultHosts = ""localhost:2181"";
-            defaultAuthScheme = """";
-            defaultAuthValue = """";
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
-     * saveDefaultConnectionFile(java.util.Properties)
-     */
-    public void saveDefaultConnectionFile(Properties props) throws IOException {
-        File defaultDir = defaultConnectionFile.getParentFile();
-        if (!defaultDir.exists()) {
-            if (!defaultDir.mkdirs()) {
-                throw new IOException(
-                        ""Failed to create configuration directory: ""
-                                + defaultDir.getAbsolutePath());
-            }
-        }
-        if (!defaultConnectionFile.exists()) {
-            if (!defaultConnectionFile.createNewFile()) {
-                throw new IOException(
-                        ""Failed to create default connection file: ""
-                                + defaultConnectionFile.getAbsolutePath());
-            }
-        }
-        FileWriter writer = new FileWriter(defaultConnectionFile);
-        try {
-            props.store(writer, ""Default connection for ZooInspector"");
-        } finally {
-            writer.close();
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
-     * saveNodeViewersFile(java.io.File, java.util.List)
-     */
-    public void saveNodeViewersFile(File selectedFile,
-            List<String> nodeViewersClassNames) throws IOException {
-        if (!selectedFile.exists()) {
-            if (!selectedFile.createNewFile()) {
-                throw new IOException(
-                        ""Failed to create node viewers configuration file: ""
-                                + selectedFile.getAbsolutePath());
-            }
-        }
-        FileWriter writer = new FileWriter(selectedFile);
-        try {
-            BufferedWriter buff = new BufferedWriter(writer);
-            try {
-                for (String nodeViewersClassName : nodeViewersClassNames) {
-                    buff.append(nodeViewersClassName);
-                    buff.append(""\n"");
-                }
-            } finally {
-                buff.flush();
-                buff.close();
-            }
-        } finally {
-            writer.close();
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
-     * setDefaultNodeViewerConfiguration(java.io.File, java.util.List)
-     */
-    public void setDefaultNodeViewerConfiguration(
-            List<String> nodeViewersClassNames) throws IOException {
-        File defaultDir = defaultNodeViewersFile.getParentFile();
-        if (!defaultDir.exists()) {
-            if (!defaultDir.mkdirs()) {
-                throw new IOException(
-                        ""Failed to create configuration directory: ""
-                                + defaultDir.getAbsolutePath());
-            }
-        }
-        saveNodeViewersFile(defaultNodeViewersFile, nodeViewersClassNames);
-    }
-
-    public List<String> getDefaultNodeViewerConfiguration() throws IOException {
-        return loadNodeViewersFile(defaultNodeViewersFile);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
-     * getLastConnectionProps()
-     */
-    public Properties getLastConnectionProps() {
-        return this.lastConnectionProps;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
-     * setLastConnectionProps(java.util.Properties)
-     */
-    public void setLastConnectionProps(Properties connectionProps) {
-        this.lastConnectionProps = connectionProps;
-    }
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.inspector.manager;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooDefs.Perms;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager;
+import org.apache.zookeeper.inspector.encryption.DataEncryptionManager;
+import org.apache.zookeeper.inspector.logger.LoggerFactory;
+import org.apache.zookeeper.retry.ZooKeeperRetry;
+
+/**
+ * A default implementation of {@link ZooInspectorManager} for connecting to
+ * zookeeper instances
+ */
+public class ZooInspectorManagerImpl implements ZooInspectorManager {
+    private static final String A_VERSION = ""ACL Version"";
+    private static final String C_TIME = ""Creation Time"";
+    private static final String C_VERSION = ""Children Version"";
+    private static final String CZXID = ""Creation ID"";
+    private static final String DATA_LENGTH = ""Data Length"";
+    private static final String EPHEMERAL_OWNER = ""Ephemeral Owner"";
+    private static final String M_TIME = ""Last Modified Time"";
+    private static final String MZXID = ""Modified ID"";
+    private static final String NUM_CHILDREN = ""Number of Children"";
+    private static final String PZXID = ""Node ID"";
+    private static final String VERSION = ""Data Version"";
+    private static final String ACL_PERMS = ""Permissions"";
+    private static final String ACL_SCHEME = ""Scheme"";
+    private static final String ACL_ID = ""Id"";
+    private static final String SESSION_STATE = ""Session State"";
+    private static final String SESSION_ID = ""Session ID"";
+    /**
+     * The key used for the connect string in the connection properties file
+     */
+    public static final String CONNECT_STRING = ""hosts"";
+    /**
+     * The key used for the session timeout in the connection properties file
+     */
+    public static final String SESSION_TIMEOUT = ""timeout"";
+    /**
+     * The key used for the data encryption manager in the connection properties
+     * file
+     */
+    public static final String DATA_ENCRYPTION_MANAGER = ""encryptionManager"";
+    /**
+     * The key used for the authentication scheme in the connection properties file
+     */
+    public static final String AUTH_SCHEME_KEY = ""authScheme"";
+    /**
+     * The key used for the authentication data in the connection properties file
+     */
+    public static final String AUTH_DATA_KEY = ""authData"";
+
+
+    private static final File defaultNodeViewersFile = new File(
+            ""./config/defaultNodeViewers.cfg"");
+    private static final File defaultConnectionFile = new File(
+            ""./config/defaultConnectionSettings.cfg"");
+
+    private DataEncryptionManager encryptionManager;
+    private String connectString;
+    private int sessionTimeout;
+    private ZooKeeper zooKeeper;
+    private final Map<String, NodeWatcher> watchers = new HashMap<String, NodeWatcher>();
+    protected boolean connected = true;
+    private Properties lastConnectionProps;
+    private String defaultEncryptionManager;
+    private String defaultTimeout;
+    private String defaultHosts;
+    private String defaultAuthScheme;
+    private String defaultAuthValue;
+
+    /**
+     * @throws IOException
+     *             - thrown if the default connection settings cannot be loaded
+     * 
+     */
+    public ZooInspectorManagerImpl() throws IOException {
+        loadDefaultConnectionFile();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#connect(java
+     * .util.Properties)
+     */
+    public boolean connect(Properties connectionProps) {
+        try {
+            if (this.zooKeeper == null) {
+                String connectString = connectionProps
+                        .getProperty(CONNECT_STRING);
+                String sessionTimeout = connectionProps
+                        .getProperty(SESSION_TIMEOUT);
+                String encryptionManager = connectionProps
+                        .getProperty(DATA_ENCRYPTION_MANAGER);
+                String authScheme = connectionProps
+                        .getProperty(AUTH_SCHEME_KEY);
+                String authData = connectionProps
+                        .getProperty(AUTH_DATA_KEY);
+
+                if (connectString == null || sessionTimeout == null) {
+                    throw new IllegalArgumentException(
+                            ""Both connect string and session timeout are required."");
+                }
+                if (encryptionManager == null) {
+                    this.encryptionManager = new BasicDataEncryptionManager();
+                } else {
+                    Class<?> clazz = Class.forName(encryptionManager);
+
+                    if (Arrays.asList(clazz.getInterfaces()).contains(
+                            DataEncryptionManager.class)) {
+                        this.encryptionManager = (DataEncryptionManager) Class
+                                .forName(encryptionManager).newInstance();
+                    } else {
+                        throw new IllegalArgumentException(
+                                ""Data encryption manager must implement DataEncryptionManager interface"");
+                    }
+                }
+                this.connectString = connectString;
+                this.sessionTimeout = Integer.valueOf(sessionTimeout);
+                this.zooKeeper = new ZooKeeperRetry(connectString, Integer
+                        .valueOf(sessionTimeout), new Watcher() {
+
+                    public void process(WatchedEvent event) {
+                        if (event.getState() == KeeperState.Expired) {
+                            connected = false;
+                        }
+                    }
+                });
+                if (authData != null && authData.length() > 0){
+                    this.zooKeeper.addAuthInfo(authScheme, authData.getBytes());
+                }
+                ((ZooKeeperRetry) this.zooKeeper).setRetryLimit(10);
+                connected = ((ZooKeeperRetry) this.zooKeeper).testConnection();
+            }
+        } catch (Exception e) {
+            connected = false;
+            e.printStackTrace();
+        }
+        if (!connected){
+        	disconnect();
+        }
+        return connected;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#disconnect()
+     */
+    public boolean disconnect() {
+        try {
+            if (this.zooKeeper != null) {
+                this.zooKeeper.close();
+                this.zooKeeper = null;
+                connected = false;
+                removeWatchers(this.watchers.keySet());
+                return true;
+            }
+        } catch (Exception e) {
+            LoggerFactory.getLogger().error(
+                    ""Error occurred while disconnecting from ZooKeeper server"",
+                    e);
+        }
+        return false;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * getChildren(java.lang.String)
+     */
+    public List<String> getChildren(String nodePath) {
+        if (connected) {
+            try {
+
+                return zooKeeper.getChildren(nodePath, false);
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred retrieving children of node: ""
+                                + nodePath, e);
+            }
+        }
+        return null;
+
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#getData
+     * (java.lang.String)
+     */
+    public String getData(String nodePath) {
+        if (connected) {
+            try {
+                if (nodePath.length() == 0) {
+                    nodePath = ""/"";
+                }
+                Stat s = zooKeeper.exists(nodePath, false);
+                if (s != null) {
+                    return this.encryptionManager.decryptData(zooKeeper
+                            .getData(nodePath, false, s));
+                }
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred getting data for node: "" + nodePath, e);
+            }
+        }
+        return null;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * getNodeChild(java.lang.String, int)
+     */
+    public String getNodeChild(String nodePath, int childIndex) {
+        if (connected) {
+            try {
+                Stat s = zooKeeper.exists(nodePath, false);
+                if (s != null) {
+                    return this.zooKeeper.getChildren(nodePath, false).get(
+                            childIndex);
+                }
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred retrieving child "" + childIndex
+                                + "" of node: "" + nodePath, e);
+            }
+        }
+        return null;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * getNodeIndex(java.lang.String)
+     */
+    public int getNodeIndex(String nodePath) {
+        if (connected) {
+            int index = nodePath.lastIndexOf(""/"");
+            if (index == -1
+                    || (!nodePath.equals(""/"") && nodePath.charAt(nodePath
+                            .length() - 1) == '/')) {
+                throw new IllegalArgumentException(""Invalid node path: ""
+                        + nodePath);
+            }
+            String parentPath = nodePath.substring(0, index);
+            String child = nodePath.substring(index + 1);
+            if (parentPath != null && parentPath.length() > 0) {
+                List<String> children = this.getChildren(parentPath);
+                if (children != null) {
+                    return children.indexOf(child);
+                }
+            }
+        }
+        return -1;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#getACLs
+     * (java.lang.String)
+     */
+    public List<Map<String, String>> getACLs(String nodePath) {
+        List<Map<String, String>> returnACLs = new ArrayList<Map<String, String>>();
+        if (connected) {
+            try {
+                if (nodePath.length() == 0) {
+                    nodePath = ""/"";
+                }
+                Stat s = zooKeeper.exists(nodePath, false);
+                if (s != null) {
+                    List<ACL> acls = zooKeeper.getACL(nodePath, s);
+                    for (ACL acl : acls) {
+                        Map<String, String> aclMap = new LinkedHashMap<String, String>();
+                        aclMap.put(ACL_SCHEME, acl.getId().getScheme());
+                        aclMap.put(ACL_ID, acl.getId().getId());
+                        StringBuilder sb = new StringBuilder();
+                        int perms = acl.getPerms();
+                        boolean addedPerm = false;
+                        if ((perms & Perms.READ) == Perms.READ) {
+                            sb.append(""Read"");
+                            addedPerm = true;
+                        }
+                        if (addedPerm) {
+                            sb.append("", "");
+                        }
+                        if ((perms & Perms.WRITE) == Perms.WRITE) {
+                            sb.append(""Write"");
+                            addedPerm = true;
+                        }
+                        if (addedPerm) {
+                            sb.append("", "");
+                        }
+                        if ((perms & Perms.CREATE) == Perms.CREATE) {
+                            sb.append(""Create"");
+                            addedPerm = true;
+                        }
+                        if (addedPerm) {
+                            sb.append("", "");
+                        }
+                        if ((perms & Perms.DELETE) == Perms.DELETE) {
+                            sb.append(""Delete"");
+                            addedPerm = true;
+                        }
+                        if (addedPerm) {
+                            sb.append("", "");
+                        }
+                        if ((perms & Perms.ADMIN) == Perms.ADMIN) {
+                            sb.append(""Admin"");
+                            addedPerm = true;
+                        }
+                        aclMap.put(ACL_PERMS, sb.toString());
+                        returnACLs.add(aclMap);
+                    }
+                }
+            } catch (InterruptedException e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred retrieving ACLs of node: "" + nodePath,
+                        e);
+            } catch (KeeperException e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred retrieving ACLs of node: "" + nodePath,
+                        e);
+            }
+        }
+        return returnACLs;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * getNodeMeta(java.lang.String)
+     */
+    public Map<String, String> getNodeMeta(String nodePath) {
+        Map<String, String> nodeMeta = new LinkedHashMap<String, String>();
+        if (connected) {
+            try {
+                if (nodePath.length() == 0) {
+                    nodePath = ""/"";
+                }
+                Stat s = zooKeeper.exists(nodePath, false);
+                if (s != null) {
+                    nodeMeta.put(A_VERSION, String.valueOf(s.getAversion()));
+                    nodeMeta.put(C_TIME, String.valueOf(s.getCtime()));
+                    nodeMeta.put(C_VERSION, String.valueOf(s.getCversion()));
+                    nodeMeta.put(CZXID, String.valueOf(s.getCzxid()));
+                    nodeMeta
+                            .put(DATA_LENGTH, String.valueOf(s.getDataLength()));
+                    nodeMeta.put(EPHEMERAL_OWNER, String.valueOf(s
+                            .getEphemeralOwner()));
+                    nodeMeta.put(M_TIME, String.valueOf(s.getMtime()));
+                    nodeMeta.put(MZXID, String.valueOf(s.getMzxid()));
+                    nodeMeta.put(NUM_CHILDREN, String.valueOf(s
+                            .getNumChildren()));
+                    nodeMeta.put(PZXID, String.valueOf(s.getPzxid()));
+                    nodeMeta.put(VERSION, String.valueOf(s.getVersion()));
+                }
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred retrieving meta data for node: ""
+                                + nodePath, e);
+            }
+        }
+        return nodeMeta;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * getNumChildren(java.lang.String)
+     */
+    public int getNumChildren(String nodePath) {
+        if (connected) {
+            try {
+                Stat s = zooKeeper.exists(nodePath, false);
+                if (s != null) {
+                    return s.getNumChildren();
+                }
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred getting the number of children of node: ""
+                                + nodePath, e);
+            }
+        }
+        return -1;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * hasChildren(java.lang.String)
+     */
+    public boolean hasChildren(String nodePath) {
+        return getNumChildren(nodePath) > 0;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * isAllowsChildren(java.lang.String)
+     */
+    public boolean isAllowsChildren(String nodePath) {
+        if (connected) {
+            try {
+                Stat s = zooKeeper.exists(nodePath, false);
+                if (s != null) {
+                    return s.getEphemeralOwner() == 0;
+                }
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred determining whether node is allowed children: ""
+                                + nodePath, e);
+            }
+        }
+        return false;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorReadOnlyManager#
+     * getSessionMeta()
+     */
+    public Map<String, String> getSessionMeta() {
+        Map<String, String> sessionMeta = new LinkedHashMap<String, String>();
+        try {
+            if (zooKeeper != null) {
+
+                sessionMeta.put(SESSION_ID, String.valueOf(zooKeeper
+                        .getSessionId()));
+                sessionMeta.put(SESSION_STATE, String.valueOf(zooKeeper
+                        .getState().toString()));
+                sessionMeta.put(CONNECT_STRING, this.connectString);
+                sessionMeta.put(SESSION_TIMEOUT, String
+                        .valueOf(this.sessionTimeout));
+            }
+        } catch (Exception e) {
+            LoggerFactory.getLogger().error(
+                    ""Error occurred retrieving session meta data."", e);
+        }
+        return sessionMeta;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorNodeTreeManager#createNode
+     * (java.lang.String, java.lang.String)
+     */
+    public boolean createNode(String parent, String nodeName) {
+        if (connected) {
+            try {
+                String[] nodeElements = nodeName.split(""/"");
+                for (String nodeElement : nodeElements) {
+                    String node = parent + ""/"" + nodeElement;
+                    Stat s = zooKeeper.exists(node, false);
+                    if (s == null) {
+                        zooKeeper.create(node, this.encryptionManager
+                                .encryptData(null), Ids.OPEN_ACL_UNSAFE,
+                                CreateMode.PERSISTENT);
+                        parent = node;
+                    }
+                }
+                return true;
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred creating node: "" + parent + ""/""
+                                + nodeName, e);
+            }
+        }
+        return false;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorNodeTreeManager#deleteNode
+     * (java.lang.String)
+     */
+    public boolean deleteNode(String nodePath) {
+        if (connected) {
+            try {
+                Stat s = zooKeeper.exists(nodePath, false);
+                if (s != null) {
+                    List<String> children = zooKeeper.getChildren(nodePath,
+                            false);
+                    for (String child : children) {
+                        String node = nodePath + ""/"" + child;
+                        deleteNode(node);
+                    }
+                    zooKeeper.delete(nodePath, -1);
+                }
+                return true;
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred deleting node: "" + nodePath, e);
+            }
+        }
+        return false;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorNodeManager#setData
+     * (java.lang.String, java.lang.String)
+     */
+    public boolean setData(String nodePath, String data) {
+        if (connected) {
+            try {
+                zooKeeper.setData(nodePath, this.encryptionManager
+                        .encryptData(data), -1);
+                return true;
+            } catch (Exception e) {
+                LoggerFactory.getLogger().error(
+                        ""Error occurred setting data for node: "" + nodePath, e);
+            }
+        }
+        return false;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
+     * getConnectionPropertiesTemplate()
+     */
+    public Pair<Map<String, List<String>>, Map<String, String>> getConnectionPropertiesTemplate() {
+        Map<String, List<String>> template = new LinkedHashMap<String, List<String>>();
+        template.put(CONNECT_STRING, Arrays
+                .asList(new String[] { defaultHosts }));
+        template.put(SESSION_TIMEOUT, Arrays
+                .asList(new String[] { defaultTimeout }));
+        template.put(DATA_ENCRYPTION_MANAGER, Arrays
+                .asList(new String[] { defaultEncryptionManager }));
+        template.put(AUTH_SCHEME_KEY, Arrays
+                .asList(new String[] { defaultAuthScheme }));
+        template.put(AUTH_DATA_KEY, Arrays
+                .asList(new String[] { defaultAuthValue }));
+        Map<String, String> labels = new LinkedHashMap<String, String>();
+        labels.put(CONNECT_STRING, ""Connect String"");
+        labels.put(SESSION_TIMEOUT, ""Session Timeout"");
+        labels.put(DATA_ENCRYPTION_MANAGER, ""Data Encryption Manager"");
+        labels.put(AUTH_SCHEME_KEY, ""Authentication Scheme"");
+        labels.put(AUTH_DATA_KEY, ""Authentication Data"");
+        return new Pair<Map<String, List<String>>, Map<String, String>>(
+                template, labels);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#addWatchers
+     * (java.util.Collection,
+     * org.apache.zookeeper.inspector.manager.NodeListener)
+     */
+    public void addWatchers(Collection<String> selectedNodes,
+            NodeListener nodeListener) {
+        // add watcher for each node and add node to collection of
+        // watched nodes
+        if (connected) {
+            for (String node : selectedNodes) {
+                if (!watchers.containsKey(node)) {
+                    try {
+                        watchers.put(node, new NodeWatcher(node, nodeListener,
+                                zooKeeper));
+                    } catch (Exception e) {
+                        LoggerFactory.getLogger().error(
+                                ""Error occured adding node watcher for node: ""
+                                        + node, e);
+                    }
+                }
+            }
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.zookeeper.inspector.manager.ZooInspectorManager#removeWatchers
+     * (java.util.Collection)
+     */
+    public void removeWatchers(Collection<String> selectedNodes) {
+        // remove watcher for each node and remove node from
+        // collection of watched nodes
+        if (connected) {
+            for (String node : selectedNodes) {
+                if (watchers.containsKey(node)) {
+                    NodeWatcher watcher = watchers.remove(node);
+                    if (watcher != null) {
+                        watcher.stop();
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * A Watcher which will re-add itself every time an event is fired
+     * 
+     */
+    public class NodeWatcher implements Watcher {
+
+        private final String nodePath;
+        private final NodeListener nodeListener;
+        private final ZooKeeper zookeeper;
+        private boolean closed = false;
+
+        /**
+         * @param nodePath
+         *            - the path to the node to watch
+         * @param nodeListener
+         *            the {@link NodeListener} for this node
+         * @param zookeeper
+         *            - a {@link ZooKeeper} to use to access zookeeper
+         * @throws InterruptedException
+         * @throws KeeperException
+         */
+        public NodeWatcher(String nodePath, NodeListener nodeListener,
+                ZooKeeper zookeeper) throws KeeperException,
+                InterruptedException {
+            this.nodePath = nodePath;
+            this.nodeListener = nodeListener;
+            this.zookeeper = zookeeper;
+            Stat s = zooKeeper.exists(nodePath, this);
+            if (s != null) {
+                zookeeper.getChildren(nodePath, this);
+            }
+        }
+
+        public void process(WatchedEvent event) {
+            if (!closed) {
+                try {
+                    if (event.getType() != EventType.NodeDeleted) {
+
+                        Stat s = zooKeeper.exists(nodePath, this);
+                        if (s != null) {
+                            zookeeper.getChildren(nodePath, this);
+                        }
+                    }
+                } catch (Exception e) {
+                    LoggerFactory.getLogger().error(
+                            ""Error occured re-adding node watcherfor node ""
+                                    + nodePath, e);
+                }
+                nodeListener.processEvent(event.getPath(), event.getType()
+                        .name(), null);
+            }
+        }
+
+        /**
+		 * 
+		 */
+        public void stop() {
+            this.closed = true;
+        }
+
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
+     * loadNodeViewersFile(java.io.File)
+     */
+    public List<String> loadNodeViewersFile(File selectedFile)
+            throws IOException {
+        List<String> result = new ArrayList<String>();
+        if (defaultNodeViewersFile.exists()) {
+            FileReader reader = new FileReader(selectedFile);
+            try {
+                BufferedReader buff = new BufferedReader(reader);
+                try {
+                    while (buff.ready()) {
+                        String line = buff.readLine();
+                        if (line != null && line.length() > 0 && !line.startsWith(""#"")) {
+                            result.add(line);
+                        }
+                    }
+                } finally {
+                    buff.close();
+                }
+            } finally {
+                reader.close();
+            }
+        }
+        return result;
+    }
+
+    private void loadDefaultConnectionFile() throws IOException {
+        if (defaultConnectionFile.exists()) {
+            Properties props = new Properties();
+
+            FileReader reader = new FileReader(defaultConnectionFile);
+            try {
+                props.load(reader);
+            } finally {
+                reader.close();
+            }
+            defaultEncryptionManager = props
+                    .getProperty(DATA_ENCRYPTION_MANAGER) == null ? ""org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager""
+                    : props.getProperty(DATA_ENCRYPTION_MANAGER);
+            defaultTimeout = props.getProperty(SESSION_TIMEOUT) == null ? ""5000""
+                    : props.getProperty(SESSION_TIMEOUT);
+            defaultHosts = props.getProperty(CONNECT_STRING) == null ? ""localhost:2181""
+                    : props.getProperty(CONNECT_STRING);
+            defaultAuthScheme = props.getProperty(AUTH_SCHEME_KEY) == null ? """"
+                    : props.getProperty(AUTH_SCHEME_KEY);
+            defaultAuthValue = props.getProperty(AUTH_DATA_KEY) == null ? """"
+                    : props.getProperty(AUTH_DATA_KEY);
+        } else {
+            defaultEncryptionManager = ""org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager"";
+            defaultTimeout = ""5000"";
+            defaultHosts = ""localhost:2181"";
+            defaultAuthScheme = """";
+            defaultAuthValue = """";
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
+     * saveDefaultConnectionFile(java.util.Properties)
+     */
+    public void saveDefaultConnectionFile(Properties props) throws IOException {
+        File defaultDir = defaultConnectionFile.getParentFile();
+        if (!defaultDir.exists()) {
+            if (!defaultDir.mkdirs()) {
+                throw new IOException(
+                        ""Failed to create configuration directory: ""
+                                + defaultDir.getAbsolutePath());
+            }
+        }
+        if (!defaultConnectionFile.exists()) {
+            if (!defaultConnectionFile.createNewFile()) {
+                throw new IOException(
+                        ""Failed to create default connection file: ""
+                                + defaultConnectionFile.getAbsolutePath());
+            }
+        }
+        FileWriter writer = new FileWriter(defaultConnectionFile);
+        try {
+            props.store(writer, ""Default connection for ZooInspector"");
+        } finally {
+            writer.close();
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
+     * saveNodeViewersFile(java.io.File, java.util.List)
+     */
+    public void saveNodeViewersFile(File selectedFile,
+            List<String> nodeViewersClassNames) throws IOException {
+        if (!selectedFile.exists()) {
+            if (!selectedFile.createNewFile()) {
+                throw new IOException(
+                        ""Failed to create node viewers configuration file: ""
+                                + selectedFile.getAbsolutePath());
+            }
+        }
+        FileWriter writer = new FileWriter(selectedFile);
+        try {
+            BufferedWriter buff = new BufferedWriter(writer);
+            try {
+                for (String nodeViewersClassName : nodeViewersClassNames) {
+                    buff.append(nodeViewersClassName);
+                    buff.append(""\n"");
+                }
+            } finally {
+                buff.flush();
+                buff.close();
+            }
+        } finally {
+            writer.close();
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
+     * setDefaultNodeViewerConfiguration(java.io.File, java.util.List)
+     */
+    public void setDefaultNodeViewerConfiguration(
+            List<String> nodeViewersClassNames) throws IOException {
+        File defaultDir = defaultNodeViewersFile.getParentFile();
+        if (!defaultDir.exists()) {
+            if (!defaultDir.mkdirs()) {
+                throw new IOException(
+                        ""Failed to create configuration directory: ""
+                                + defaultDir.getAbsolutePath());
+            }
+        }
+        saveNodeViewersFile(defaultNodeViewersFile, nodeViewersClassNames);
+    }
+
+    public List<String> getDefaultNodeViewerConfiguration() throws IOException {
+        return loadNodeViewersFile(defaultNodeViewersFile);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
+     * getLastConnectionProps()
+     */
+    public Properties getLastConnectionProps() {
+        return this.lastConnectionProps;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @seeorg.apache.zookeeper.inspector.manager.ZooInspectorManager#
+     * setLastConnectionProps(java.util.Properties)
+     */
+    public void setLastConnectionProps(Properties connectionProps) {
+        this.lastConnectionProps = connectionProps;
+    }
+}
",,6461
2583,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java,32a5d09b3bc5088e32b065fd3c011628ca37dbed,1268096775,120,7db83eb9dcbd26b79f852e93520db821dabff047,1499147769,120,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,-1,1396574677/1268096775,"                return super.exists(path, watch ? watcher : null);","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.zookeeper.retry;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.zookeeper.CreateMode;
-import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZooKeeper;
-import org.apache.zookeeper.data.ACL;
-import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.inspector.logger.LoggerFactory;
-
-/**
- * A Class which extends {@link ZooKeeper} and will automatically retry calls to
- * zookeeper if a {@link KeeperException.ConnectionLossException} occurs
- */
-public class ZooKeeperRetry extends ZooKeeper {
-
-    private boolean closed = false;
-    private final Watcher watcher;
-    private int limit = -1;
-
-    /**
-     * @param connectString
-     * @param sessionTimeout
-     * @param watcher
-     * @throws IOException
-     */
-    public ZooKeeperRetry(String connectString, int sessionTimeout,
-            Watcher watcher) throws IOException {
-        super(connectString, sessionTimeout, watcher);
-        this.watcher = watcher;
-    }
-
-    /**
-     * @param connectString
-     * @param sessionTimeout
-     * @param watcher
-     * @param sessionId
-     * @param sessionPasswd
-     * @throws IOException
-     */
-    public ZooKeeperRetry(String connectString, int sessionTimeout,
-            Watcher watcher, long sessionId, byte[] sessionPasswd)
-            throws IOException {
-        super(connectString, sessionTimeout, watcher, sessionId, sessionPasswd);
-        this.watcher = watcher;
-    }
-
-    @Override
-    public synchronized void close() throws InterruptedException {
-        this.closed = true;
-        super.close();
-    }
-
-    @Override
-    public String create(String path, byte[] data, List<ACL> acl,
-            CreateMode createMode) throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.create(path, data, acl, createMode);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                if (exists(path, false) != null) {
-                    return path;
-                }
-            } catch (KeeperException.NodeExistsException e) {
-                return path;
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public void delete(String path, int version) throws InterruptedException,
-            KeeperException {
-        int count = 0;
-        do {
-            try {
-                super.delete(path, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                if (exists(path, false) == null) {
-                    return;
-                }
-            } catch (KeeperException.NoNodeException e) {
-                break;
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-    }
-
-    @Override
-    public Stat exists(String path, boolean watch) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.exists(path, watch ? watcher : null);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat exists(String path, Watcher watcher) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.exists(path, watcher);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public List<ACL> getACL(String path, Stat stat) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getACL(path, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public List<String> getChildren(String path, boolean watch)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getChildren(path, watch ? watcher : null);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return new ArrayList<String>();
-    }
-
-    @Override
-    public List<String> getChildren(String path, Watcher watcher)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getChildren(path, watcher);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return new ArrayList<String>();
-    }
-
-    @Override
-    public byte[] getData(String path, boolean watch, Stat stat)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getData(path, watch ? watcher : null, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public byte[] getData(String path, Watcher watcher, Stat stat)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getData(path, watcher, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat setACL(String path, List<ACL> acl, int version)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.setACL(path, acl, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                Stat s = exists(path, false);
-                if (s != null) {
-                    if (getACL(path, s).equals(acl)) {
-                        return s;
-                    }
-                } else {
-                    return null;
-                }
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat setData(String path, byte[] data, int version)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.setData(path, data, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                Stat s = exists(path, false);
-                if (s != null) {
-                    if (getData(path, false, s) == data) {
-                        return s;
-                    }
-                } else {
-                    return null;
-                }
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    /**
-     * @param limit
-     */
-    public void setRetryLimit(int limit) {
-        this.limit = limit;
-    }
-
-    /**
-     * @return true if successfully connected to zookeeper
-     */
-    public boolean testConnection() {
-        int count = 0;
-        do {
-            try {
-                return super.exists(""/"", null) != null;
-            } catch (Exception e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (count++ < 5);
-        return false;
-    }
-
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.retry;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.inspector.logger.LoggerFactory;
+
+/**
+ * A Class which extends {@link ZooKeeper} and will automatically retry calls to
+ * zookeeper if a {@link KeeperException.ConnectionLossException} occurs
+ */
+public class ZooKeeperRetry extends ZooKeeper {
+
+    private boolean closed = false;
+    private final Watcher watcher;
+    private int limit = -1;
+
+    /**
+     * @param connectString
+     * @param sessionTimeout
+     * @param watcher
+     * @throws IOException
+     */
+    public ZooKeeperRetry(String connectString, int sessionTimeout,
+            Watcher watcher) throws IOException {
+        super(connectString, sessionTimeout, watcher);
+        this.watcher = watcher;
+    }
+
+    /**
+     * @param connectString
+     * @param sessionTimeout
+     * @param watcher
+     * @param sessionId
+     * @param sessionPasswd
+     * @throws IOException
+     */
+    public ZooKeeperRetry(String connectString, int sessionTimeout,
+            Watcher watcher, long sessionId, byte[] sessionPasswd)
+            throws IOException {
+        super(connectString, sessionTimeout, watcher, sessionId, sessionPasswd);
+        this.watcher = watcher;
+    }
+
+    @Override
+    public synchronized void close() throws InterruptedException {
+        this.closed = true;
+        super.close();
+    }
+
+    @Override
+    public String create(String path, byte[] data, List<ACL> acl,
+            CreateMode createMode) throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.create(path, data, acl, createMode);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                if (exists(path, false) != null) {
+                    return path;
+                }
+            } catch (KeeperException.NodeExistsException e) {
+                return path;
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public void delete(String path, int version) throws InterruptedException,
+            KeeperException {
+        int count = 0;
+        do {
+            try {
+                super.delete(path, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                if (exists(path, false) == null) {
+                    return;
+                }
+            } catch (KeeperException.NoNodeException e) {
+                break;
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+    }
+
+    @Override
+    public Stat exists(String path, boolean watch) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.exists(path, watch ? watcher : null);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat exists(String path, Watcher watcher) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.exists(path, watcher);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public List<ACL> getACL(String path, Stat stat) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getACL(path, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public List<String> getChildren(String path, boolean watch)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getChildren(path, watch ? watcher : null);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return new ArrayList<String>();
+    }
+
+    @Override
+    public List<String> getChildren(String path, Watcher watcher)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getChildren(path, watcher);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return new ArrayList<String>();
+    }
+
+    @Override
+    public byte[] getData(String path, boolean watch, Stat stat)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getData(path, watch ? watcher : null, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public byte[] getData(String path, Watcher watcher, Stat stat)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getData(path, watcher, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat setACL(String path, List<ACL> acl, int version)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.setACL(path, acl, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                Stat s = exists(path, false);
+                if (s != null) {
+                    if (getACL(path, s).equals(acl)) {
+                        return s;
+                    }
+                } else {
+                    return null;
+                }
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat setData(String path, byte[] data, int version)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.setData(path, data, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                Stat s = exists(path, false);
+                if (s != null) {
+                    if (getData(path, false, s) == data) {
+                        return s;
+                    }
+                } else {
+                    return null;
+                }
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    /**
+     * @param limit
+     */
+    public void setRetryLimit(int limit) {
+        this.limit = limit;
+    }
+
+    /**
+     * @return true if successfully connected to zookeeper
+     */
+    public boolean testConnection() {
+        int count = 0;
+        do {
+            try {
+                return super.exists(""/"", null) != null;
+            } catch (Exception e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (count++ < 5);
+        return false;
+    }
+
+}
",,6461
2584,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java,32a5d09b3bc5088e32b065fd3c011628ca37dbed,1268096775,165,7db83eb9dcbd26b79f852e93520db821dabff047,1499147769,165,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,-1,1396574677/1268096775,"                return super.getChildren(path, watch ? watcher : null);","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.zookeeper.retry;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.zookeeper.CreateMode;
-import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZooKeeper;
-import org.apache.zookeeper.data.ACL;
-import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.inspector.logger.LoggerFactory;
-
-/**
- * A Class which extends {@link ZooKeeper} and will automatically retry calls to
- * zookeeper if a {@link KeeperException.ConnectionLossException} occurs
- */
-public class ZooKeeperRetry extends ZooKeeper {
-
-    private boolean closed = false;
-    private final Watcher watcher;
-    private int limit = -1;
-
-    /**
-     * @param connectString
-     * @param sessionTimeout
-     * @param watcher
-     * @throws IOException
-     */
-    public ZooKeeperRetry(String connectString, int sessionTimeout,
-            Watcher watcher) throws IOException {
-        super(connectString, sessionTimeout, watcher);
-        this.watcher = watcher;
-    }
-
-    /**
-     * @param connectString
-     * @param sessionTimeout
-     * @param watcher
-     * @param sessionId
-     * @param sessionPasswd
-     * @throws IOException
-     */
-    public ZooKeeperRetry(String connectString, int sessionTimeout,
-            Watcher watcher, long sessionId, byte[] sessionPasswd)
-            throws IOException {
-        super(connectString, sessionTimeout, watcher, sessionId, sessionPasswd);
-        this.watcher = watcher;
-    }
-
-    @Override
-    public synchronized void close() throws InterruptedException {
-        this.closed = true;
-        super.close();
-    }
-
-    @Override
-    public String create(String path, byte[] data, List<ACL> acl,
-            CreateMode createMode) throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.create(path, data, acl, createMode);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                if (exists(path, false) != null) {
-                    return path;
-                }
-            } catch (KeeperException.NodeExistsException e) {
-                return path;
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public void delete(String path, int version) throws InterruptedException,
-            KeeperException {
-        int count = 0;
-        do {
-            try {
-                super.delete(path, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                if (exists(path, false) == null) {
-                    return;
-                }
-            } catch (KeeperException.NoNodeException e) {
-                break;
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-    }
-
-    @Override
-    public Stat exists(String path, boolean watch) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.exists(path, watch ? watcher : null);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat exists(String path, Watcher watcher) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.exists(path, watcher);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public List<ACL> getACL(String path, Stat stat) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getACL(path, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public List<String> getChildren(String path, boolean watch)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getChildren(path, watch ? watcher : null);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return new ArrayList<String>();
-    }
-
-    @Override
-    public List<String> getChildren(String path, Watcher watcher)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getChildren(path, watcher);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return new ArrayList<String>();
-    }
-
-    @Override
-    public byte[] getData(String path, boolean watch, Stat stat)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getData(path, watch ? watcher : null, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public byte[] getData(String path, Watcher watcher, Stat stat)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getData(path, watcher, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat setACL(String path, List<ACL> acl, int version)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.setACL(path, acl, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                Stat s = exists(path, false);
-                if (s != null) {
-                    if (getACL(path, s).equals(acl)) {
-                        return s;
-                    }
-                } else {
-                    return null;
-                }
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat setData(String path, byte[] data, int version)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.setData(path, data, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                Stat s = exists(path, false);
-                if (s != null) {
-                    if (getData(path, false, s) == data) {
-                        return s;
-                    }
-                } else {
-                    return null;
-                }
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    /**
-     * @param limit
-     */
-    public void setRetryLimit(int limit) {
-        this.limit = limit;
-    }
-
-    /**
-     * @return true if successfully connected to zookeeper
-     */
-    public boolean testConnection() {
-        int count = 0;
-        do {
-            try {
-                return super.exists(""/"", null) != null;
-            } catch (Exception e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (count++ < 5);
-        return false;
-    }
-
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.retry;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.inspector.logger.LoggerFactory;
+
+/**
+ * A Class which extends {@link ZooKeeper} and will automatically retry calls to
+ * zookeeper if a {@link KeeperException.ConnectionLossException} occurs
+ */
+public class ZooKeeperRetry extends ZooKeeper {
+
+    private boolean closed = false;
+    private final Watcher watcher;
+    private int limit = -1;
+
+    /**
+     * @param connectString
+     * @param sessionTimeout
+     * @param watcher
+     * @throws IOException
+     */
+    public ZooKeeperRetry(String connectString, int sessionTimeout,
+            Watcher watcher) throws IOException {
+        super(connectString, sessionTimeout, watcher);
+        this.watcher = watcher;
+    }
+
+    /**
+     * @param connectString
+     * @param sessionTimeout
+     * @param watcher
+     * @param sessionId
+     * @param sessionPasswd
+     * @throws IOException
+     */
+    public ZooKeeperRetry(String connectString, int sessionTimeout,
+            Watcher watcher, long sessionId, byte[] sessionPasswd)
+            throws IOException {
+        super(connectString, sessionTimeout, watcher, sessionId, sessionPasswd);
+        this.watcher = watcher;
+    }
+
+    @Override
+    public synchronized void close() throws InterruptedException {
+        this.closed = true;
+        super.close();
+    }
+
+    @Override
+    public String create(String path, byte[] data, List<ACL> acl,
+            CreateMode createMode) throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.create(path, data, acl, createMode);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                if (exists(path, false) != null) {
+                    return path;
+                }
+            } catch (KeeperException.NodeExistsException e) {
+                return path;
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public void delete(String path, int version) throws InterruptedException,
+            KeeperException {
+        int count = 0;
+        do {
+            try {
+                super.delete(path, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                if (exists(path, false) == null) {
+                    return;
+                }
+            } catch (KeeperException.NoNodeException e) {
+                break;
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+    }
+
+    @Override
+    public Stat exists(String path, boolean watch) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.exists(path, watch ? watcher : null);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat exists(String path, Watcher watcher) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.exists(path, watcher);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public List<ACL> getACL(String path, Stat stat) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getACL(path, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public List<String> getChildren(String path, boolean watch)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getChildren(path, watch ? watcher : null);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return new ArrayList<String>();
+    }
+
+    @Override
+    public List<String> getChildren(String path, Watcher watcher)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getChildren(path, watcher);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return new ArrayList<String>();
+    }
+
+    @Override
+    public byte[] getData(String path, boolean watch, Stat stat)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getData(path, watch ? watcher : null, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public byte[] getData(String path, Watcher watcher, Stat stat)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getData(path, watcher, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat setACL(String path, List<ACL> acl, int version)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.setACL(path, acl, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                Stat s = exists(path, false);
+                if (s != null) {
+                    if (getACL(path, s).equals(acl)) {
+                        return s;
+                    }
+                } else {
+                    return null;
+                }
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat setData(String path, byte[] data, int version)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.setData(path, data, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                Stat s = exists(path, false);
+                if (s != null) {
+                    if (getData(path, false, s) == data) {
+                        return s;
+                    }
+                } else {
+                    return null;
+                }
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    /**
+     * @param limit
+     */
+    public void setRetryLimit(int limit) {
+        this.limit = limit;
+    }
+
+    /**
+     * @return true if successfully connected to zookeeper
+     */
+    public boolean testConnection() {
+        int count = 0;
+        do {
+            try {
+                return super.exists(""/"", null) != null;
+            } catch (Exception e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (count++ < 5);
+        return false;
+    }
+
+}
",,6461
2585,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java,32a5d09b3bc5088e32b065fd3c011628ca37dbed,1268096775,195,7db83eb9dcbd26b79f852e93520db821dabff047,1499147769,195,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,-1,1396574677/1268096775,"                return super.getData(path, watch ? watcher : null, stat);","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.zookeeper.retry;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.zookeeper.CreateMode;
-import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZooKeeper;
-import org.apache.zookeeper.data.ACL;
-import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.inspector.logger.LoggerFactory;
-
-/**
- * A Class which extends {@link ZooKeeper} and will automatically retry calls to
- * zookeeper if a {@link KeeperException.ConnectionLossException} occurs
- */
-public class ZooKeeperRetry extends ZooKeeper {
-
-    private boolean closed = false;
-    private final Watcher watcher;
-    private int limit = -1;
-
-    /**
-     * @param connectString
-     * @param sessionTimeout
-     * @param watcher
-     * @throws IOException
-     */
-    public ZooKeeperRetry(String connectString, int sessionTimeout,
-            Watcher watcher) throws IOException {
-        super(connectString, sessionTimeout, watcher);
-        this.watcher = watcher;
-    }
-
-    /**
-     * @param connectString
-     * @param sessionTimeout
-     * @param watcher
-     * @param sessionId
-     * @param sessionPasswd
-     * @throws IOException
-     */
-    public ZooKeeperRetry(String connectString, int sessionTimeout,
-            Watcher watcher, long sessionId, byte[] sessionPasswd)
-            throws IOException {
-        super(connectString, sessionTimeout, watcher, sessionId, sessionPasswd);
-        this.watcher = watcher;
-    }
-
-    @Override
-    public synchronized void close() throws InterruptedException {
-        this.closed = true;
-        super.close();
-    }
-
-    @Override
-    public String create(String path, byte[] data, List<ACL> acl,
-            CreateMode createMode) throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.create(path, data, acl, createMode);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                if (exists(path, false) != null) {
-                    return path;
-                }
-            } catch (KeeperException.NodeExistsException e) {
-                return path;
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public void delete(String path, int version) throws InterruptedException,
-            KeeperException {
-        int count = 0;
-        do {
-            try {
-                super.delete(path, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                if (exists(path, false) == null) {
-                    return;
-                }
-            } catch (KeeperException.NoNodeException e) {
-                break;
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-    }
-
-    @Override
-    public Stat exists(String path, boolean watch) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.exists(path, watch ? watcher : null);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat exists(String path, Watcher watcher) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.exists(path, watcher);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public List<ACL> getACL(String path, Stat stat) throws KeeperException,
-            InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getACL(path, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public List<String> getChildren(String path, boolean watch)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getChildren(path, watch ? watcher : null);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return new ArrayList<String>();
-    }
-
-    @Override
-    public List<String> getChildren(String path, Watcher watcher)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getChildren(path, watcher);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return new ArrayList<String>();
-    }
-
-    @Override
-    public byte[] getData(String path, boolean watch, Stat stat)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getData(path, watch ? watcher : null, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public byte[] getData(String path, Watcher watcher, Stat stat)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.getData(path, watcher, stat);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat setACL(String path, List<ACL> acl, int version)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.setACL(path, acl, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                Stat s = exists(path, false);
-                if (s != null) {
-                    if (getACL(path, s).equals(acl)) {
-                        return s;
-                    }
-                } else {
-                    return null;
-                }
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    @Override
-    public Stat setData(String path, byte[] data, int version)
-            throws KeeperException, InterruptedException {
-        int count = 0;
-        do {
-            try {
-                return super.setData(path, data, version);
-            } catch (KeeperException.ConnectionLossException e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-                Stat s = exists(path, false);
-                if (s != null) {
-                    if (getData(path, false, s) == data) {
-                        return s;
-                    }
-                } else {
-                    return null;
-                }
-            }
-        } while (!closed && (limit == -1 || count++ < limit));
-        return null;
-    }
-
-    /**
-     * @param limit
-     */
-    public void setRetryLimit(int limit) {
-        this.limit = limit;
-    }
-
-    /**
-     * @return true if successfully connected to zookeeper
-     */
-    public boolean testConnection() {
-        int count = 0;
-        do {
-            try {
-                return super.exists(""/"", null) != null;
-            } catch (Exception e) {
-                LoggerFactory.getLogger().warn(
-                        ""ZooKeeper connection lost.  Trying to reconnect."");
-            }
-        } while (count++ < 5);
-        return false;
-    }
-
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.retry;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.inspector.logger.LoggerFactory;
+
+/**
+ * A Class which extends {@link ZooKeeper} and will automatically retry calls to
+ * zookeeper if a {@link KeeperException.ConnectionLossException} occurs
+ */
+public class ZooKeeperRetry extends ZooKeeper {
+
+    private boolean closed = false;
+    private final Watcher watcher;
+    private int limit = -1;
+
+    /**
+     * @param connectString
+     * @param sessionTimeout
+     * @param watcher
+     * @throws IOException
+     */
+    public ZooKeeperRetry(String connectString, int sessionTimeout,
+            Watcher watcher) throws IOException {
+        super(connectString, sessionTimeout, watcher);
+        this.watcher = watcher;
+    }
+
+    /**
+     * @param connectString
+     * @param sessionTimeout
+     * @param watcher
+     * @param sessionId
+     * @param sessionPasswd
+     * @throws IOException
+     */
+    public ZooKeeperRetry(String connectString, int sessionTimeout,
+            Watcher watcher, long sessionId, byte[] sessionPasswd)
+            throws IOException {
+        super(connectString, sessionTimeout, watcher, sessionId, sessionPasswd);
+        this.watcher = watcher;
+    }
+
+    @Override
+    public synchronized void close() throws InterruptedException {
+        this.closed = true;
+        super.close();
+    }
+
+    @Override
+    public String create(String path, byte[] data, List<ACL> acl,
+            CreateMode createMode) throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.create(path, data, acl, createMode);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                if (exists(path, false) != null) {
+                    return path;
+                }
+            } catch (KeeperException.NodeExistsException e) {
+                return path;
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public void delete(String path, int version) throws InterruptedException,
+            KeeperException {
+        int count = 0;
+        do {
+            try {
+                super.delete(path, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                if (exists(path, false) == null) {
+                    return;
+                }
+            } catch (KeeperException.NoNodeException e) {
+                break;
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+    }
+
+    @Override
+    public Stat exists(String path, boolean watch) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.exists(path, watch ? watcher : null);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat exists(String path, Watcher watcher) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.exists(path, watcher);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public List<ACL> getACL(String path, Stat stat) throws KeeperException,
+            InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getACL(path, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public List<String> getChildren(String path, boolean watch)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getChildren(path, watch ? watcher : null);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return new ArrayList<String>();
+    }
+
+    @Override
+    public List<String> getChildren(String path, Watcher watcher)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getChildren(path, watcher);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return new ArrayList<String>();
+    }
+
+    @Override
+    public byte[] getData(String path, boolean watch, Stat stat)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getData(path, watch ? watcher : null, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public byte[] getData(String path, Watcher watcher, Stat stat)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.getData(path, watcher, stat);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat setACL(String path, List<ACL> acl, int version)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.setACL(path, acl, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                Stat s = exists(path, false);
+                if (s != null) {
+                    if (getACL(path, s).equals(acl)) {
+                        return s;
+                    }
+                } else {
+                    return null;
+                }
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    @Override
+    public Stat setData(String path, byte[] data, int version)
+            throws KeeperException, InterruptedException {
+        int count = 0;
+        do {
+            try {
+                return super.setData(path, data, version);
+            } catch (KeeperException.ConnectionLossException e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+                Stat s = exists(path, false);
+                if (s != null) {
+                    if (getData(path, false, s) == data) {
+                        return s;
+                    }
+                } else {
+                    return null;
+                }
+            }
+        } while (!closed && (limit == -1 || count++ < limit));
+        return null;
+    }
+
+    /**
+     * @param limit
+     */
+    public void setRetryLimit(int limit) {
+        this.limit = limit;
+    }
+
+    /**
+     * @return true if successfully connected to zookeeper
+     */
+    public boolean testConnection() {
+        int count = 0;
+        do {
+            try {
+                return super.exists(""/"", null) != null;
+            } catch (Exception e) {
+                LoggerFactory.getLogger().warn(
+                        ""ZooKeeper connection lost.  Trying to reconnect."");
+            }
+        } while (count++ < 5);
+        return false;
+    }
+
+}
",,6461
2586,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,ab5aa8c07299b04cccf3d2ca8b5c59db4f69af56,1268100046,1362,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,1280437836,1637,,,,,"            jmxConnectionBean = null;",,,6461
2587,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,df20416c08fa0079d96f6327d10c6f102ebabd85,1268277424,1233,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,1280437836,1488,,,,,"            jmxConnectionBean = null;",,,6461
2588,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,df20416c08fa0079d96f6327d10c6f102ebabd85,1268277424,1307,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,1280437836,1562,,,,,"        sock = null;",,,6461
2589,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java,65fc5e579a1e659a3977808dffe51e2a436afa86,1268937590,213,575c53253bf9f548f342c3371d05bc00d2c2363d,1298051688,217,,,,,"            zk = null;",,,6461
2590,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/InstanceManager.java,f8f4ce353d4a3624b47e757737dd877cfad3e169,1269019790,292,9ac5756b18d377774f49064e6e1de3f39d059b87,1319522994,281,,,,,"                lastException = null;",,,6461
2591,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/InstanceManager.java,f8f4ce353d4a3624b47e757737dd877cfad3e169,1269019790,316,9ac5756b18d377774f49064e6e1de3f39d059b87,1319522994,305,,,,,"                lastException = null;",,,6461
2592,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,2470b06a967ad18d8ba0b0c6dc52b5fd0965a385,1273009513,964,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,1280437836,980,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2593,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/Log4JSource.java,6bb8b641c65185eefd252e1fe38a933fe11bbceb,1276097182,215,6aec8db7185cfc17022d90279f83f01ff237346a,1417276432,216,,,,,"		next = null;",,,6461
2594,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/TxnLogSource.java,6bb8b641c65185eefd252e1fe38a933fe11bbceb,1276097182,258,eb51de49f723542a17e722fa817d81605a04c74c,1308844907,258,,,,,"		next = null;",,,6461
2595,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,2a8a3063d64fb935ca4136ba10bb15efeb97d52e,1278354022,425,,,,,,,,"        serverFactory = null;",,,6461
2596,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,2a8a3063d64fb935ca4136ba10bb15efeb97d52e,1278354022,444,28573d112600863f6918a963cb3583a09d69aa1e,1449433807,531,,,,,"            allClients = null;",,,6461
2597,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,2a8a3063d64fb935ca4136ba10bb15efeb97d52e,1278354022,475,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,479,,,,,"        serverFactory = null;",,,6461
2598,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,49a05a7bdbb183ee594a6b518d580b07fd35e59e,1278359405,839,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,839,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2599,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java,b4337499e5c2864adcade4fbdab77cef93dad1b1,1282029849,77,,,,,,,,"            session = null;",,,6461
2600,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,457,53a3d5530bd337625374396199ab985e115025ed,1302592447,458,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2601,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,1012,53a3d5530bd337625374396199ab985e115025ed,1302592447,1013,12878387483a4084c5a3beafbfae0172a44e5dcf,1378766233,-1,1378766233/1282112648,"        sock = null;","                         "" which had sessionid 0x"" + Long.toHexString(sessionId) :
                         "" (no session established for client)""));
         closeSock(sock);
-        sock = null;
     }
 
     /**
      * Close resources associated with a sock.
      */
     public static void closeSock(SocketChannel sock) {
-        if (sock == null) {
+        if (sock.isOpen() == false) {
             return;
         }
 
",,6461
2602,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,269,80803034aabb68229730b9d7429525bd460c3183,1447018577,274,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2603,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,723,310f890ff8c4e4977204fb0dd8443bbe6ba3c7a1,1388156240,754,,,,,"                        bb = null;",,,6461
2604,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,161,d8adc547f9856747905b7d46450f13fa98df147f,1490635922,161,,,,,"                        cnxn.queuedBuffer = null;",,,6461
2605,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,206,d8adc547f9856747905b7d46450f13fa98df147f,1490635922,206,,,,,"                            cnxn.queuedBuffer = null;",,,6461
2606,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,30cff66e5efe6b99b7e7a2293061f0eea0def02f,1282112648,434,97bdb8e94963857be25fd69eada9212c2d6f19d1,1328518062,416,,,,,"        serverFactory = null;",,,6461
2607,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/hedwig/client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java,c16f5b46bc8ab67fd66d789bddfe5eb092542ea6,1282253113,271,,,,,,,,"            lastMessageSeqId = null;",,,6461
2608,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/hedwig/client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java,c16f5b46bc8ab67fd66d789bddfe5eb092542ea6,1282253113,321,,,,,,,,"            origSubData.context = null;",,,6461
2609,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/hedwig/server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java,c16f5b46bc8ab67fd66d789bddfe5eb092542ea6,1282253113,220,,,,,,,,"        failureException = null;",,,6461
2610,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,b67088488ed98f2d21dc374a5a67be622cd8e046,1289428594,323,524dbc6be1e064092a06c7928ce8feea092ab898,1289495515,322,18c58fa390c47b74d2af7ffca7b87610568b37f5,1291148195,-1,1291148195/1289428594,"                this.chrootPath = null;","      * @param sessionPasswd session passwd if re-establishing session
      * @throws IOException
      */
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
+    public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,
             ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,
-            long sessionId, byte[] sessionPasswd) throws IOException {
+            long sessionId, byte[] sessionPasswd) {
         this.zooKeeper = zooKeeper;
         this.watcher = watcher;
         this.sessionId = sessionId;
         this.sessionPasswd = sessionPasswd;
-
-        // parse out chroot, if any
-        int off = hosts.indexOf('/');
-        if (off >= 0) {
-            String chrootPath = hosts.substring(off);
-            // ignore ""/"" chroot spec, same as null
-            if (chrootPath.length() == 1) {
-                this.chrootPath = null;
-            } else {
-                PathUtils.validatePath(chrootPath);
-                this.chrootPath = chrootPath;
-            }
-            hosts = hosts.substring(0,  off);
-        } else {
-            this.chrootPath = null;
-        }
-
-        String hostsList[] = hosts.split("","");
-        for (String host : hostsList) {
-            int port = 2181;
-            int pidx = host.lastIndexOf(':');
-            if (pidx >= 0) {
-                // otherwise : is at the end of the string, ignore
-                if (pidx < host.length() - 1) {
-                    port = Integer.parseInt(host.substring(pidx + 1));
-                }
-                host = host.substring(0, pidx);
-            }
-            InetAddress addrs[] = InetAddress.getAllByName(host);
-            for (InetAddress addr : addrs) {
-                serverAddrs.add(new InetSocketAddress(addr, port));
-            }
-        }
         this.sessionTimeout = sessionTimeout;
-        connectTimeout = sessionTimeout / hostsList.length;
+        this.hostProvider = hostProvider;
+        this.chrootPath = chrootPath;
+
+        connectTimeout = sessionTimeout / hostProvider.size();
         readTimeout = sessionTimeout * 2 / 3;
-        Collections.shuffle(serverAddrs);
+
         sendThread = new SendThread(clientCnxnSocket);
         eventThread = new EventThread();
     }
",,6461
2611,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,b67088488ed98f2d21dc374a5a67be622cd8e046,1289428594,330,524dbc6be1e064092a06c7928ce8feea092ab898,1289495515,329,18c58fa390c47b74d2af7ffca7b87610568b37f5,1291148195,-1,1291148195/1289428594,"            this.chrootPath = null;","      * @param sessionPasswd session passwd if re-establishing session
      * @throws IOException
      */
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
+    public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,
             ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,
-            long sessionId, byte[] sessionPasswd) throws IOException {
+            long sessionId, byte[] sessionPasswd) {
         this.zooKeeper = zooKeeper;
         this.watcher = watcher;
         this.sessionId = sessionId;
         this.sessionPasswd = sessionPasswd;
-
-        // parse out chroot, if any
-        int off = hosts.indexOf('/');
-        if (off >= 0) {
-            String chrootPath = hosts.substring(off);
-            // ignore ""/"" chroot spec, same as null
-            if (chrootPath.length() == 1) {
-                this.chrootPath = null;
-            } else {
-                PathUtils.validatePath(chrootPath);
-                this.chrootPath = chrootPath;
-            }
-            hosts = hosts.substring(0,  off);
-        } else {
-            this.chrootPath = null;
-        }
-
-        String hostsList[] = hosts.split("","");
-        for (String host : hostsList) {
-            int port = 2181;
-            int pidx = host.lastIndexOf(':');
-            if (pidx >= 0) {
-                // otherwise : is at the end of the string, ignore
-                if (pidx < host.length() - 1) {
-                    port = Integer.parseInt(host.substring(pidx + 1));
-                }
-                host = host.substring(0, pidx);
-            }
-            InetAddress addrs[] = InetAddress.getAllByName(host);
-            for (InetAddress addr : addrs) {
-                serverAddrs.add(new InetSocketAddress(addr, port));
-            }
-        }
         this.sessionTimeout = sessionTimeout;
-        connectTimeout = sessionTimeout / hostsList.length;
+        this.hostProvider = hostProvider;
+        this.chrootPath = chrootPath;
+
+        connectTimeout = sessionTimeout / hostProvider.size();
         readTimeout = sessionTimeout * 2 / 3;
-        Collections.shuffle(serverAddrs);
+
         sendThread = new SendThread(clientCnxnSocket);
         eventThread = new EventThread();
     }
",,6461
2612,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java,b67088488ed98f2d21dc374a5a67be622cd8e046,1289428594,164,6e5a25670346ddf5e4bc3b1598f8ec5e52699c09,1351704294,230,,,,,"        sockKey = null;",,,6461
2613,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,09580032cb9cdcc694d0adae9f1cb897f9a5c215,1290005969,545,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,560,,,,,"            recvWorker = null;",,,6461
2614,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/client/ConnectStringParser.java,18c58fa390c47b74d2af7ffca7b87610568b37f5,1291148195,55,3d81f925c585ef252a55ab09b7f3ba838f98a797,1359096859,58,,,,,"                this.chrootPath = null;",,,6461
2615,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/client/ConnectStringParser.java,18c58fa390c47b74d2af7ffca7b87610568b37f5,1291148195,62,3d81f925c585ef252a55ab09b7f3ba838f98a797,1359096859,65,,,,,"            this.chrootPath = null;",,,6461
2616,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/version/util/VerGen.java,0e604b1006d0edc079004639e63477a800f2f9f5,1291836574,131,4ed40f05a649783c855b63d09a1b485eff2b9555,1355296793,131,,,,,"            result.qualifier = null;",,,6461
2617,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,2a6f177a50c84b7998fa831db1ee54a2f6e2349a,1293108162,573,d25e90b75d234865eeaf0a5d33bcc6976f8da245,1316038967,604,,,,,"                hdr = null;",,,6461
2618,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,a035a32e21026bf1c6bc7d3d99215d694d5dfa92,1300291114,640,53a3d5530bd337625374396199ab985e115025ed,1302592447,641,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2619,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,a035a32e21026bf1c6bc7d3d99215d694d5dfa92,1300291114,831,5a6535bf410ed223aac075241045ccd807b17b81,1404789956,1060,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2620,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,53a3d5530bd337625374396199ab985e115025ed,1302592447,354,,,,,,,,"                jmxDataTreeBean = null;",,,6461
2621,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,53a3d5530bd337625374396199ab985e115025ed,1302592447,358,,,,,,,,"            jmxServerBean = null;",,,6461
2622,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,53a3d5530bd337625374396199ab985e115025ed,1302592447,441,bb857582bab316abea48588375df98de51df9115,1359076658,434,,,,,"        jmxServerBean = null;",,,6461
2623,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,2be6b4dc25b55d86d15a68519a8b19630feaa4de,1304093564,659,5a6535bf410ed223aac075241045ccd807b17b81,1404789956,865,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2624,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,883,,,,,,,,"                rwServerAddress = null;",,,6461
2625,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,460,f6bba09481dffc7db1d47be732d3cc8067603767,1531972754,488,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2626,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,1040,395b5effc712bb8d960ab0f2c2ee6f6fdb47140c,1354088606,1042,,,,,"        sock = null;",,,6461
2627,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,598,1538d107efb36b9f39617d33e883260c1a7e2027,1308267270,639,,,,,"                        jmxLocalPeerBean = null;",,,6461
2628,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,611,1538d107efb36b9f39617d33e883260c1a7e2027,1308267270,652,,,,,"            jmxQuorumBean = null;",,,6461
2629,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,709,1538d107efb36b9f39617d33e883260c1a7e2027,1308267270,750,,,,,"            jmxQuorumBean = null;",,,6461
2630,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,9be9a3a1d03d6f78b4e55423d15f46c5d3a82f74,1305847068,710,aa786021bc3939ee79f8fde0a3fbcfbdeff69272,1320131733,767,,,,,"            jmxLocalPeerBean = null;",,,6461
2631,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java,a2763e3cf5cca5301aa8eac25dfb61c9501e4724,1305847492,72,b71191f514a2eec512f795e43a25c64d48f0e4c7,1381350115,83,,,,,"            jmxDataTreeBean = null;",,,6461
2632,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java,a2763e3cf5cca5301aa8eac25dfb61c9501e4724,1305847492,83,b71191f514a2eec512f795e43a25c64d48f0e4c7,1381350115,94,,,,,"            jmxServerBean = null;",,,6461
2633,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java,a2763e3cf5cca5301aa8eac25dfb61c9501e4724,1305847492,97,b71191f514a2eec512f795e43a25c64d48f0e4c7,1381350115,108,,,,,"        jmxDataTreeBean = null;",,,6461
2634,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java,a2763e3cf5cca5301aa8eac25dfb61c9501e4724,1305847492,109,b71191f514a2eec512f795e43a25c64d48f0e4c7,1381350115,120,,,,,"        jmxServerBean = null;",,,6461
2635,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,e74a8149ebce642e6805afd3576536f27632bf6e,1307995749,459,97bdb8e94963857be25fd69eada9212c2d6f19d1,1328518062,438,,,,,"            allClients = null;",,,6461
2636,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,e74a8149ebce642e6805afd3576536f27632bf6e,1307995749,476,28573d112600863f6918a963cb3583a09d69aa1e,1449433807,514,,,,,"        serverFactory = null;",,,6461
2637,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java,776db7808e27624aa125f1314b7fbb2196837507,1308028445,114,7bf199eb4df4537adca112c7962e200a87d2666d,1335136813,124,43eedab16b074f7b87da98ac0af60092bb0c52fd,1342560311,-1,1342560311/1308028445,"            	currentThread = null;","                 // test will still fail even though we just log/ignore
                 LOG.error(""unexpected exception in run"", e);
             } finally {
-            	currentThread = null;
+                currentThread = null;
             }
         }
 
         public void shutdown() throws InterruptedException {
-        	Thread t = currentThread;
-        	if (t != null && t.isAlive()) {
-        		main.shutdown();
-        		t.join(500);
-        	}
+            Thread t = currentThread;
+            if (t != null && t.isAlive()) {
+                main.shutdown();
+                t.join(500);
+            }
         }
-		public void join(long timeout) throws InterruptedException {
-			Thread t = currentThread;
-			if (t != null) {
-				t.join(timeout);
-			}
-		}
-		public boolean isAlive() {
-			Thread t = currentThread;
-			return t != null && t.isAlive();
-		}
+
+        public void join(long timeout) throws InterruptedException {
+            Thread t = currentThread;
+            if (t != null) {
+                t.join(timeout);
+            }
+        }
+
+        public boolean isAlive() {
+            Thread t = currentThread;
+            return t != null && t.isAlive();
+        }
+
+        public void clean() {
+            ClientBase.recursiveDelete(main.quorumPeer.getTxnFactory()
+                    .getDataDir());
+        }
     }
 }
",,6461
2638,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,793,e44601d1249ea70b5bfa514082c714640c6217dd,1323468930,737,,,,,"            rc.multiResult = null;",,,6461
2639,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,483,7307c9825187d3f3debf3b252ad5590965d9b56d,1317331976,483,,,,,"        request.hdr = null;",,,6461
2640,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,0b3d1c6a7b46961e1fc501d66fb52173935306a1,1309474408,484,7307c9825187d3f3debf3b252ad5590965d9b56d,1317331976,484,,,,,"        request.txn = null;",,,6461
2641,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1113,1d6325605f1c6344c045839c043d239a6612d18a,1315263526,1031,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2642,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1153,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,1298,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2643,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1226,1d6325605f1c6344c045839c043d239a6612d18a,1315263526,1142,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2644,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1266,da88e47f755f745f353d81e54162e6ce151e7b37,1313340003,1183,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2645,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1547,1d6325605f1c6344c045839c043d239a6612d18a,1315263526,1458,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2646,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1589,da88e47f755f745f353d81e54162e6ce151e7b37,1313340003,1506,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2647,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1674,1d6325605f1c6344c045839c043d239a6612d18a,1315263526,1583,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2648,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,1310703045,1721,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,1781,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2649,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,f650291795d66491b326856bb7b987b0afd33d02,1313705135,903,181de25c0dc703eaff77dd6415b676f09564277a,1536572690,1056,,,,,"                rwServerAddress = null;",,,6461
2650,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8024660dc7003e1162a8ae7ffe10438316d58c5d,1314685747,644,aa786021bc3939ee79f8fde0a3fbcfbdeff69272,1320131733,642,,,,,"                        jmxLocalPeerBean = null;",,,6461
2651,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8024660dc7003e1162a8ae7ffe10438316d58c5d,1314685747,657,aa786021bc3939ee79f8fde0a3fbcfbdeff69272,1320131733,655,,,,,"            jmxQuorumBean = null;",,,6461
2652,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8024660dc7003e1162a8ae7ffe10438316d58c5d,1314685747,756,aa786021bc3939ee79f8fde0a3fbcfbdeff69272,1320131733,768,,,,,"            jmxLocalPeerBean = null;",,,6461
2653,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,634243cc4bb695e1679584dc80af8e33172309ad,1315253011,1178,5a882c303de74370c7e57a516b68d07260be9bc3,1397717238,1638,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2654,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,634243cc4bb695e1679584dc80af8e33172309ad,1315253011,1496,1d6325605f1c6344c045839c043d239a6612d18a,1315263526,1498,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2655,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,634243cc4bb695e1679584dc80af8e33172309ad,1315253011,1626,1d6325605f1c6344c045839c043d239a6612d18a,1315263526,1628,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2656,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,9ea4f145f21fb4920e45962db3e1b0c8c9ef7bec,1318863589,462,,,,e04e40167ffe34472435f040f346af06e76ff760,1319133738,-1,1319133738/1318863589,"        request.hdr = null;","     protected void pRequest(Request request) {
         // LOG.info(""Prep>>> cxid = "" + request.cxid + "" type = "" +
         // request.type + "" id = 0x"" + Long.toHexString(request.sessionId));
-        request.hdr = null;
-        request.txn = null;
+        request.setHdr(null);
+        request.setTxn(null);
 
         try {
             switch (request.type) {
",,6461
2657,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,9ea4f145f21fb4920e45962db3e1b0c8c9ef7bec,1318863589,463,,,,e04e40167ffe34472435f040f346af06e76ff760,1319133738,-1,1319133738/1318863589,"        request.txn = null;","     protected void pRequest(Request request) {
         // LOG.info(""Prep>>> cxid = "" + request.cxid + "" type = "" +
         // request.type + "" id = 0x"" + Long.toHexString(request.sessionId));
-        request.hdr = null;
-        request.txn = null;
+        request.setHdr(null);
+        request.setTxn(null);
 
         try {
             switch (request.type) {
",,6461
2658,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/Request.java,e04e40167ffe34472435f040f346af06e76ff760,1319133738,54,a1cd9204d298ca9b5b30c2f272d55b306c393271,1398731038,55,,,,,"        this.request = null;",,,6461
2659,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/Request.java,e04e40167ffe34472435f040f346af06e76ff760,1319133738,55,a1cd9204d298ca9b5b30c2f272d55b306c393271,1398731038,56,,,,,"        this.cnxn = null;",,,6461
2660,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/Request.java,e04e40167ffe34472435f040f346af06e76ff760,1319133738,56,a1cd9204d298ca9b5b30c2f272d55b306c393271,1398731038,57,,,,,"        this.authInfo = null;",,,6461
2661,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,dad9038097c9ae699a32f812c6aa4410bf63b735,1321381828,619,0b65e3d4cbb7647ea692bfea59c02e5b24bf821c,1536189061,688,,,,,"                inputStream = null;",,,6461
2662,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,dad9038097c9ae699a32f812c6aa4410bf63b735,1321381828,620,0b65e3d4cbb7647ea692bfea59c02e5b24bf821c,1536189061,687,,,,,"                ia = null;",,,6461
2663,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,dad9038097c9ae699a32f812c6aa4410bf63b735,1321381828,621,069c3e4fccbd56307b19b57864fbf6312ace2219,1517527618,688,,,,,"                hdr = null;",,,6461
2664,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,73deba9c208dbb062da894f9b3cd83792fff7bc7,1323905999,735,53cbcc6086b8170e7f7671c5ddbb474c41893c02,1331997431,733,,,,,"            rc.multiResult = null;",,,6461
2665,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5ddc24bf36fcc1e509302d0caef074f9c827e0b1,1328517632,646,d1b07d588e445085eff4abeb42cf730cc7c57e83,1517295761,875,,,,,"                        jmxLocalPeerBean = null;",,,6461
2666,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5ddc24bf36fcc1e509302d0caef074f9c827e0b1,1328517632,659,d1b07d588e445085eff4abeb42cf730cc7c57e83,1517295761,889,,,,,"            jmxQuorumBean = null;",,,6461
2667,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5ddc24bf36fcc1e509302d0caef074f9c827e0b1,1328517632,771,c84f7ef14542dc1d3291e932932e6b6faf536944,1355383535,940,,,,,"            jmxQuorumBean = null;",,,6461
2668,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5ddc24bf36fcc1e509302d0caef074f9c827e0b1,1328517632,772,c84f7ef14542dc1d3291e932932e6b6faf536944,1355383535,941,,,,,"            jmxLocalPeerBean = null;",,,6461
2669,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1049,8c6155afb6df604ff59fa4e4148a809c0740d3b6,1348849939,1069,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2670,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1087,cbe58afeeccca6acd532968ddb32833ed65021b8,1331944276,1102,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2671,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1160,8c6155afb6df604ff59fa4e4148a809c0740d3b6,1348849939,1180,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2672,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1198,c35f9b0303b3b4fae62802f43707a06528013906,1359903131,1414,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2673,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1476,59ecde5ed38f0c6701d818841446793214cf702e,1387299329,1940,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2674,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1516,8c6155afb6df604ff59fa4e4148a809c0740d3b6,1348849939,1536,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2675,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1601,59ecde5ed38f0c6701d818841446793214cf702e,1387299329,2065,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2676,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,60ff341b8b2080c6ffae5be887a3897ca201aafb,1328518571,1646,59ecde5ed38f0c6701d818841446793214cf702e,1387299329,2110,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2677,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,297517b5e1461400039aa7c4fdbbd246183a133f,1331830049,420,e2ad1053563537bd815dad63482b61bd34d5143d,1342559978,423,,,,,"        serverFactory = null;",,,6461
2678,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,297517b5e1461400039aa7c4fdbbd246183a133f,1331830049,442,772304a191c1ea1dc41185d6ccfca51d41c4d240,1388708692,455,,,,,"            allClients = null;",,,6461
2679,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,297517b5e1461400039aa7c4fdbbd246183a133f,1331830049,459,e2ad1053563537bd815dad63482b61bd34d5143d,1342559978,462,,,,,"        serverFactory = null;",,,6461
2680,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,7bf199eb4df4537adca112c7962e200a87d2666d,1335136813,559,,,,,,,,"            recvWorker = null;",,,6461
2681,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,7bf199eb4df4537adca112c7962e200a87d2666d,1335136813,124,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,138,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1335136813,"            this.clientAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2682,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,7bf199eb4df4537adca112c7962e200a87d2666d,1335136813,130,d1b07d588e445085eff4abeb42cf730cc7c57e83,1517295761,144,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1335136813,"            this.electionAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2683,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,7bf199eb4df4537adca112c7962e200a87d2666d,1335136813,131,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,144,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1335136813,"            this.clientAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2684,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,7bf199eb4df4537adca112c7962e200a87d2666d,1335136813,198,d1b07d588e445085eff4abeb42cf730cc7c57e83,1517295761,212,,,,,"            this.clientAddr = null;",,,6461
2685,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/common/IOUtils.java,e2ad1053563537bd815dad63482b61bd34d5143d,1342559978,87,,,,,,,,"                out = null;",,,6461
2686,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/common/IOUtils.java,e2ad1053563537bd815dad63482b61bd34d5143d,1342559978,89,,,,,,,,"                in = null;",,,6461
2687,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java,43eedab16b074f7b87da98ac0af60092bb0c52fd,1342560311,127,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,145,,,,,"                currentThread = null;",,,6461
2688,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,6206b495e0c7a8ff3bb7a30cbddf2dd8f02f6dfc,1355940434,1006,,,,12878387483a4084c5a3beafbfae0172a44e5dcf,1378766233,-1,1378766233/1355940434,"        sock = null;","                         "" which had sessionid 0x"" + Long.toHexString(sessionId) :
                         "" (no session established for client)""));
         closeSock(sock);
-        sock = null;
     }
 
     /**
      * Close resources associated with a sock.
      */
     public static void closeSock(SocketChannel sock) {
-        if (sock == null) {
+        if (sock.isOpen() == false) {
             return;
         }
 
",,6461
2689,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/RateLogger.java,6206b495e0c7a8ff3bb7a30cbddf2dd8f02f6dfc,1355940434,41,,,,,,,,"        msg = null;",,,6461
2690,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,97a8c5be83c4468cd67fa412b715cbb4f312885e,1355941010,770,5fdd70ac49c7a5334bdcae309719ac4ada352dde,1531222160,800,,,,,"            rc.multiResult = null;",,,6461
2691,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,97a8c5be83c4468cd67fa412b715cbb4f312885e,1355941010,437,d53be91194395c01d5f78361717e03439b8fb942,1403715965,509,,,,,"            name = null;",,,6461
2692,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,1447,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,1678,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2693,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,1541,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,1772,,,,,"        return getConfig(watch ? watchManager.defaultWatcher : null, stat);",,,6461
2694,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,1550,43deb9b8a8efb0befd4e17cd5ab3e907a700d5c8,1406004677,1781,,,,,"        getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2695,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,83,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,83,,,,,"        joining = null;",,,6461
2696,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,84,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,84,,,,,"        leaving = null;",,,6461
2697,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,85,fef1ae2e7b2bf712b315b6907ebef0bf2a988927,1390276201,85,,,,,"        members = null;",,,6461
2698,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,253,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,253,892e10f6a45cca0464dae4089265511b7d0b9a38,1406136979,-1,1406136979/1362636109,"                        electionAddr = null;","                         electionAddr = new InetSocketAddress(host_port[0], Integer.parseInt(host_port[1]));                   
                     } else {
                         LOG.error(""Got urecognized protocol version "" + protocolVersion + "" from "" + sid);
-                        electionAddr = null;
                     }
                 } else {
-                   LOG.error(""Read only "" + num_read + "" bytes out of "" + num_remaining_bytes + "" sent by server "" + sid);
-                   electionAddr = null;                
+                   LOG.error(""Read only "" + num_read + "" bytes out of "" + num_remaining_bytes + "" sent by server "" + sid);          
                 }
             } 
             if (sid == QuorumPeer.OBSERVER_ID) {
",,6461
2699,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,257,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,257,892e10f6a45cca0464dae4089265511b7d0b9a38,1406136979,-1,1406136979/1362636109,"                   electionAddr = null;                ","                         electionAddr = new InetSocketAddress(host_port[0], Integer.parseInt(host_port[1]));                   
                     } else {
                         LOG.error(""Got urecognized protocol version "" + protocolVersion + "" from "" + sid);
-                        electionAddr = null;
                     }
                 } else {
-                   LOG.error(""Read only "" + num_read + "" bytes out of "" + num_remaining_bytes + "" sent by server "" + sid);
-                   electionAddr = null;                
+                   LOG.error(""Read only "" + num_read + "" bytes out of "" + num_remaining_bytes + "" sent by server "" + sid);          
                 }
             } 
             if (sid == QuorumPeer.OBSERVER_ID) {
",,6461
2700,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,615,72eb405829a9173966d6b29e229c56c95ace0524,1380147199,621,,,,,"            recvWorker = null;",,,6461
2701,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,971,d1b07d588e445085eff4abeb42cf730cc7c57e83,1517295761,1016,,,,,"            jmxQuorumBean = null;",,,6461
2702,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,972,d1b07d588e445085eff4abeb42cf730cc7c57e83,1517295761,1017,,,,,"            jmxLocalPeerBean = null;",,,6461
2703,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ReconfigTest.java,5428cd4bc963c2e653a260c458a8a8edf3fa08ef,1362636109,179,d061f1b5a5eca108e566a68e6f7aa07913c90ac3,1491350575,178,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,-1,1396574677/1362636109,"        zkArr[0] = null; // not used.","-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.zookeeper.test;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-
-import org.apache.zookeeper.CreateMode;
-import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.PortAssignment;
-import org.apache.zookeeper.WatchedEvent;
-import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZKTestCase;
-import org.apache.zookeeper.ZooDefs;
-import org.apache.zookeeper.ZooKeeper;
-import org.apache.zookeeper.AsyncCallback.DataCallback;
-import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
-import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
-import org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical;
-import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
-import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
-import org.junit.Assert;
-import org.junit.After;
-import org.junit.Test;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class ReconfigTest extends ZKTestCase implements DataCallback{
-    private static final Logger LOG = LoggerFactory
-            .getLogger(ReconfigTest.class);
-
-    private QuorumUtil qu;
-
-    @After
-    public void tearDown() throws Exception {
-        if (qu != null) {
-            qu.tearDown();
-        }
-    }
-
-    public static String reconfig(ZooKeeper zk, List<String> joiningServers,
-            List<String> leavingServers, List<String> newMembers, long fromConfig)
-            throws KeeperException, InterruptedException {
-        byte[] config = null;
-        for (int j = 0; j < 30; j++) {
-            try {
-                config = zk.reconfig(joiningServers, leavingServers,
-                        newMembers, fromConfig, new Stat());
-                break;
-            } catch (KeeperException.ConnectionLossException e) {
-                if (j < 29) {
-                    Thread.sleep(1000);
-                } else {
-                    // test fails if we still can't connect to the quorum after
-                    // 30 seconds.
-                    Assert.fail(""client could not connect to reestablished quorum: giving up after 30+ seconds."");
-                }
-            }
-        }
-
-        String configStr = new String(config);
-        if (joiningServers != null) {
-            for (String joiner : joiningServers)
-                Assert.assertTrue(configStr.contains(joiner));
-        }
-        if (leavingServers != null) {
-            for (String leaving : leavingServers)
-                Assert.assertFalse(configStr.contains(""server."".concat(leaving)));
-        }
-
-        return configStr;
-    }
-
-    public static String testServerHasConfig(ZooKeeper zk,
-            List<String> joiningServers, List<String> leavingServers)
-            throws KeeperException, InterruptedException {
-        byte[] config = null;
-        for (int j = 0; j < 30; j++) {
-            try {
-                zk.sync(""/"", null, null);
-                config = zk.getConfig(false, new Stat());
-                break;
-            } catch (KeeperException.ConnectionLossException e) {
-                if (j < 29) {
-                    Thread.sleep(1000);
-                } else {
-                    // test fails if we still can't connect to the quorum after
-                    // 30 seconds.
-                    Assert.fail(""client could not connect to reestablished quorum: giving up after 30+ seconds."");
-                }
-            }
-
-        }
-        String configStr = new String(config);
-        if (joiningServers != null) {
-            for (String joiner : joiningServers) {
-               Assert.assertTrue(configStr.contains(joiner));
-            }
-        }
-        if (leavingServers != null) {
-            for (String leaving : leavingServers)
-                Assert.assertFalse(configStr.contains(""server."".concat(leaving)));
-        }
-
-        return configStr;
-    }
-    
-    public static void testNormalOperation(ZooKeeper writer, ZooKeeper reader)
-            throws KeeperException, InterruptedException {
-        boolean testNodeExists = false;
-       
-       for (int j = 0; j < 30; j++) {
-            try {
-               if (!testNodeExists) {
-                   try{ 
-                       writer.create(""/test"", ""test"".getBytes(),
-                           ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-                   } catch (KeeperException.NodeExistsException e) {                       
-                   }
-                   testNodeExists = true;
-               }
-                String data = ""test"" + j;
-                writer.setData(""/test"", data.getBytes(), -1);
-                reader.sync(""/"", null, null);
-                byte[] res = reader.getData(""/test"", null, new Stat());
-                Assert.assertEquals(data, new String(res));
-                break;
-            } catch (KeeperException.ConnectionLossException e) {
-                if (j < 29) {
-                    Thread.sleep(1000);
-                } else {
-                    // test fails if we still can't connect to the quorum after
-                    // 30 seconds.
-                    Assert.fail(""client could not connect to reestablished quorum: giving up after 30+ seconds."");
-                }
-            }
-
-        }
-
-    }    
-    
-    private int getLeaderId(QuorumUtil qu) {
-        int leaderId = 1;
-        while (qu.getPeer(leaderId).peer.leader == null)
-            leaderId++;
-        return leaderId;
-    }
-
-    private ZooKeeper[] createHandles(QuorumUtil qu) throws IOException {
-        // create an extra handle, so we can index the handles from 1 to qu.ALL
-        // using the server id.
-        ZooKeeper[] zkArr = new ZooKeeper[qu.ALL + 1];
-        zkArr[0] = null; // not used.
-        for (int i = 1; i <= qu.ALL; i++) {
-            // server ids are 1, 2 and 3
-            zkArr[i] = new ZooKeeper(""127.0.0.1:""
-                    + qu.getPeer(i).peer.getClientPort(),
-                    ClientBase.CONNECTION_TIMEOUT, new Watcher() {
-                        public void process(WatchedEvent event) {
-                        }});
-        }
-        return zkArr;
-    }
-
-    private void closeAllHandles(ZooKeeper[] zkArr) throws InterruptedException {
-        for (ZooKeeper zk : zkArr)
-            if (zk != null)
-                zk.close();
-    }
-
- 
-    @Test
-    public void testRemoveAddOne() throws Exception {
-        qu = new QuorumUtil(1); // create 3 servers
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-
-        List<String> leavingServers = new ArrayList<String>();
-        List<String> joiningServers = new ArrayList<String>();
-
-        int leaderIndex = getLeaderId(qu);
-
-        // during first iteration, leavingIndex will correspond to a follower
-        // during second iteration leavingIndex will be the index of the leader
-        int leavingIndex = (leaderIndex == 1) ? 2 : 1;
-
-        for (int i = 0; i < 2; i++) {
-            // some of the operations will be executed by a client connected to
-            // the removed server
-            // while others are invoked by a client connected to some other
-            // server.
-            // when we're removing the leader, zk1 will be the client connected
-            // to removed server
-            ZooKeeper zk1 = (leavingIndex == leaderIndex) ? zkArr[leaderIndex]
-                    : zkArr[(leaderIndex % qu.ALL) + 1];
-            ZooKeeper zk2 = (leavingIndex == leaderIndex) ? zkArr[(leaderIndex % qu.ALL) + 1]
-                    : zkArr[leaderIndex];
-
-            leavingServers.add(Integer.toString(leavingIndex));
-
-            // remember this server so we can add it back later
-            joiningServers.add(""server.""
-                    + leavingIndex
-                    + ""=localhost:""
-                    + qu.getPeer(leavingIndex).peer.getQuorumAddress()
-                            .getPort()
-                    + "":""
-                    + qu.getPeer(leavingIndex).peer.getElectionAddress()
-                            .getPort() + "":participant;localhost:""
-                    + qu.getPeer(leavingIndex).peer.getClientPort());
-
-            String configStr = reconfig(zk1, null, leavingServers, null, -1);
-            testServerHasConfig(zk2, null, leavingServers);
-            testNormalOperation(zk2, zk1);
-
-            QuorumVerifier qv = qu.getPeer(1).peer.configFromString(configStr);
-            long version = qv.getVersion();
-
-            // checks that conditioning on version works properly
-            try {
-                reconfig(zk2, joiningServers, null, null, version + 1);
-                Assert.fail(""reconfig succeeded even though version condition was incorrect!"");
-            } catch (KeeperException.BadVersionException e) {
-
-            }
-
-            reconfig(zk2, joiningServers, null, null, version);
-
-            testNormalOperation(zk1, zk2);
-            testServerHasConfig(zk1, joiningServers, null);
-
-            // second iteration of the loop will remove the leader
-            // and add it back (as follower)
-            leavingIndex = leaderIndex = getLeaderId(qu);
-            leavingServers.clear();
-            joiningServers.clear();
-        }
-
-        closeAllHandles(zkArr);
-    }
-
-    /**
-     * 1. removes and adds back two servers (incl leader). One of the servers is added back as observer
-     * 2. tests that reconfig fails if quorum of new config is not up
-     * 3. tests that a server that's not up during reconfig learns the new config when it comes up
-     * @throws Exception
-     */
-    @Test
-    public void testRemoveAddTwo() throws Exception {
-        qu = new QuorumUtil(2); // create 5 servers
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-
-        List<String> leavingServers = new ArrayList<String>();
-        List<String> joiningServers = new ArrayList<String>();
-
-        int leaderIndex = getLeaderId(qu);
-
-        // lets remove the leader and some other server
-        int leavingIndex1 = leaderIndex;
-        int leavingIndex2 = (leaderIndex == 1) ? 2 : 1;
-
-        // find some server that's staying
-        int stayingIndex1 = 1, stayingIndex2 = 1, stayingIndex3 = 1;
-        while (stayingIndex1 == leavingIndex1 || stayingIndex1 == leavingIndex2)
-            stayingIndex1++;
-
-        while (stayingIndex2 == leavingIndex1 || stayingIndex2 == leavingIndex2
-                || stayingIndex2 == stayingIndex1)
-            stayingIndex2++;
-
-        while (stayingIndex3 == leavingIndex1 || stayingIndex3 == leavingIndex2
-                || stayingIndex3 == stayingIndex1
-                || stayingIndex3 == stayingIndex2)
-            stayingIndex3++;
-
-        leavingServers.add(Integer.toString(leavingIndex1));
-        leavingServers.add(Integer.toString(leavingIndex2));
-
-        // remember these servers so we can add them back later
-        joiningServers.add(""server."" + leavingIndex1 + ""=localhost:""
-                + qu.getPeer(leavingIndex1).peer.getQuorumAddress().getPort()
-                + "":""
-                + qu.getPeer(leavingIndex1).peer.getElectionAddress().getPort()
-                + "":participant;localhost:""
-                + qu.getPeer(leavingIndex1).peer.getClientPort());
-
-        // this server will be added back as an observer
-        joiningServers.add(""server."" + leavingIndex2 + ""=localhost:""
-                + qu.getPeer(leavingIndex2).peer.getQuorumAddress().getPort()
-                + "":""
-                + qu.getPeer(leavingIndex2).peer.getElectionAddress().getPort()
-                + "":observer;localhost:""
-                + qu.getPeer(leavingIndex2).peer.getClientPort());
-
-        qu.shutdown(leavingIndex1);
-        qu.shutdown(leavingIndex2);
-
-        // 3 servers still up so this should work
-        reconfig(zkArr[stayingIndex2], null, leavingServers, null, -1);
-        
-        qu.shutdown(stayingIndex2);
-
-        // the following commands would not work in the original
-        // cluster of 5, but now that we've removed 2 servers
-        // we have a cluster of 3 servers and one of them is allowed to fail
-
-        testServerHasConfig(zkArr[stayingIndex1], null, leavingServers);
-        testServerHasConfig(zkArr[stayingIndex3], null, leavingServers);
-        testNormalOperation(zkArr[stayingIndex1], zkArr[stayingIndex3]);
-        
-        // this is a test that a reconfig will only succeed
-        // if there is a quorum up in new config. Below there is no
-        // quorum so it should fail
-        
-        // the sleep is necessary so that the leader figures out
-        // that the switched off servers are down
-        Thread.sleep(10000);
-
-        try {
-            reconfig(zkArr[stayingIndex1], joiningServers, null, null, -1);
-            Assert.fail(""reconfig completed successfully even though there is no quorum up in new config!"");
-        } catch (KeeperException.NewConfigNoQuorum e) {
-
-        }
-        
-        // now start the third server so that new config has quorum
-        qu.restart(stayingIndex2);
-
-        reconfig(zkArr[stayingIndex1], joiningServers, null, null, -1);
-        testNormalOperation(zkArr[stayingIndex2], zkArr[stayingIndex3]);
-        testServerHasConfig(zkArr[stayingIndex2], joiningServers, null);
-
-        // this server wasn't around during the configuration change
-        // we should check that it is able to connect, finds out
-        // about the change and becomes an observer.
-
-        qu.restart(leavingIndex2);
-        Assert.assertTrue(qu.getPeer(leavingIndex2).peer.getPeerState() == ServerState.OBSERVING);
-        testNormalOperation(zkArr[stayingIndex2], zkArr[leavingIndex2]);
-        testServerHasConfig(zkArr[leavingIndex2], joiningServers, null);
-
-        closeAllHandles(zkArr);
-    }
-
-    @Test
-    public void testBulkReconfig() throws Exception {
-        qu = new QuorumUtil(3); // create 7 servers
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-
-        // new config will have three of the servers as followers
-        // two of the servers as observers, and all ports different
-        ArrayList<String> newServers = new ArrayList<String>();
-        for (int i = 1; i <= 5; i++) {
-            String server = ""server."" + i + ""=localhost:"" + PortAssignment.unique()
-                    + "":"" + PortAssignment.unique() + "":""
-                    + ((i == 4 || i == 5) ? ""observer"" : ""participant"")
-                    + "";localhost:"" + qu.getPeer(i).peer.getClientPort();
-            newServers.add(server);
-        }
-
-        qu.shutdown(3);
-        qu.shutdown(6);
-        qu.shutdown(7);
-        
-        reconfig(zkArr[1], null, null, newServers, -1);
-        testNormalOperation(zkArr[1], zkArr[2]);
-       
-        testServerHasConfig(zkArr[1], newServers, null);
-        testServerHasConfig(zkArr[2], newServers, null);
-        testServerHasConfig(zkArr[4], newServers, null);
-        testServerHasConfig(zkArr[5], newServers, null);
-    
-        qu.shutdown(5);
-        qu.shutdown(4);
-        
-        testNormalOperation(zkArr[1], zkArr[2]);
-
-        closeAllHandles(zkArr);
-    }
-
-    @Test
-    public void testRemoveOneAsynchronous() throws Exception {
-        qu = new QuorumUtil(2); 
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-
-        List<String> leavingServers = new ArrayList<String>();
-       
-        // lets remove someone who's not the leader
-        leavingServers.add(getLeaderId(qu) == 5 ? ""4"": ""5"");
- 
-        LinkedList<Integer> results = new LinkedList<Integer>();
-        
-        zkArr[1].reconfig(null, leavingServers, null, -1, this, results);   
-        
-        synchronized (results) {
-            while (results.size() < 1) {
-               results.wait();
-            }
-        }        
-        Assert.assertEquals(0, (int) results.get(0));
-        
-        testNormalOperation(zkArr[1], zkArr[2]);       
-        for (int i=1; i<=5; i++)
-            testServerHasConfig(zkArr[i], null, leavingServers);
-
-        closeAllHandles(zkArr);
-    }
-
-    @SuppressWarnings(""unchecked"")
-    public void processResult(int rc, String path, Object ctx, byte[] data,
-            Stat stat) {
-        synchronized(ctx) {
-            ((LinkedList<Integer>)ctx).add(rc);
-            ctx.notifyAll();
-        }
-    }
-    
-    
-    @Test
-    public void testRoleChange() throws Exception {
-        qu = new QuorumUtil(1); // create 3 servers
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-
-        // changing a server's role / port is done by ""adding"" it with the same
-        // id but different role / port
-        List<String> joiningServers = new ArrayList<String>();
-
-        int leaderIndex = getLeaderId(qu);
-
-        // during first and second iteration, leavingIndex will correspond to a
-        // follower
-        // during third and fouth iteration leavingIndex will be the index of
-        // the leader
-        int changingIndex = (leaderIndex == 1) ? 2 : 1;
-
-        // first convert participant to observer, then observer to participant,
-        // and so on
-        String newRole = ""observer"";
-
-        for (int i = 0; i < 4; i++) {
-            // some of the operations will be executed by a client connected to
-            // the removed server
-            // while others are invoked by a client connected to some other
-            // server.
-            // when we're removing the leader, zk1 will be the client connected
-            // to removed server
-            ZooKeeper zk1 = (changingIndex == leaderIndex) ? zkArr[leaderIndex]
-                    : zkArr[(leaderIndex % qu.ALL) + 1];
-
-            // exactly as it is now, except for role change
-            joiningServers.add(""server.""
-                    + changingIndex
-                    + ""=localhost:""
-                    + qu.getPeer(changingIndex).peer.getQuorumAddress()
-                            .getPort()
-                    + "":""
-                    + qu.getPeer(changingIndex).peer.getElectionAddress()
-                            .getPort() + "":"" + newRole + "";localhost:""
-                    + qu.getPeer(changingIndex).peer.getClientPort());
-
-            reconfig(zk1, joiningServers, null, null, -1);
-            testNormalOperation(zkArr[changingIndex], zk1);
-
-            if (newRole.equals(""observer"")) {
-                Assert.assertTrue(qu.getPeer(changingIndex).peer.observer != null
-                        && qu.getPeer(changingIndex).peer.follower == null
-                        && qu.getPeer(changingIndex).peer.leader == null);
-                Assert.assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);
-            } else {
-                Assert.assertTrue(qu.getPeer(changingIndex).peer.observer == null
-                        && (qu.getPeer(changingIndex).peer.follower != null || qu
-                                .getPeer(changingIndex).peer.leader != null));
-                Assert.assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.FOLLOWING
-                        || qu.getPeer(changingIndex).peer.getPeerState() == ServerState.LEADING);
-            }
-
-            joiningServers.clear();
-
-            if (newRole.equals(""observer"")) {
-                newRole = ""participant"";
-            } else {
-                // lets change leader to observer
-                newRole = ""observer"";
-                leaderIndex = getLeaderId(qu);
-                changingIndex = leaderIndex;
-            }
-        }
-        closeAllHandles(zkArr);
-    }
-
-    @Test
-    public void testPortChange() throws Exception {
-        qu = new QuorumUtil(1); // create 3 servers
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-
-        List<String> joiningServers = new ArrayList<String>();
-
-        int leaderIndex = getLeaderId(qu);
-        int followerIndex = leaderIndex == 1 ? 2 : 1;
-
-        // change leader into observer, and modify all its ports at the same
-        // time
-        int observerIndex = leaderIndex;
-
-        // new ports
-        int port1 = PortAssignment.unique();
-        int port2 = PortAssignment.unique();
-        int port3 = PortAssignment.unique();
-        joiningServers.add(""server."" + observerIndex + ""=localhost:"" + port1
-                + "":"" + port2 + "":observer;localhost:"" + port3);
-
-        // create a /test znode and check that read/write works before
-        // any reconfig is invoked
-        testNormalOperation(zkArr[observerIndex], zkArr[followerIndex]);
-
-        reconfig(zkArr[followerIndex], joiningServers, null, null, -1);
-
-        // the change of port may not be immediate -- we repeatedly
-        // invoke an operation expecting it to eventually fail once
-        // the client port of observerIndex changes. If it didn't
-        // change -- that's an error.
-        try {
-          for (int i=0; i < 30; i++) {
-            Thread.sleep(1000);
-            zkArr[observerIndex].setData(""/test"", ""teststr"".getBytes(), -1);
-          }
-          Assert.fail(""client port didn't change"");
-        } catch (KeeperException.ConnectionLossException e) {
-            zkArr[observerIndex] = new ZooKeeper(""127.0.0.1:""
-                    + qu.getPeer(observerIndex).peer.getClientPort(),
-                    ClientBase.CONNECTION_TIMEOUT, new Watcher() {
-                        public void process(WatchedEvent event) {}});
-        }
-
-        leaderIndex = getLeaderId(qu);
-
-        followerIndex = 1;
-        while (followerIndex == leaderIndex || followerIndex == observerIndex)
-            followerIndex++;
-
-        testNormalOperation(zkArr[observerIndex], zkArr[followerIndex]);
-
-        testServerHasConfig(zkArr[observerIndex], joiningServers, null);
-
-        Assert.assertTrue(qu.getPeer(observerIndex).peer.getQuorumAddress()
-                .getPort() == port1);
-        Assert.assertTrue(qu.getPeer(observerIndex).peer.getElectionAddress()
-                .getPort() == port2);
-        Assert.assertTrue(qu.getPeer(observerIndex).peer.getClientPort() == port3);
-        Assert.assertTrue(qu.getPeer(observerIndex).peer.getPeerState() == ServerState.OBSERVING);
-
-        joiningServers.clear();
-
-        // change leader's leading port - should renounce leadership
-
-        port1 = PortAssignment.unique();
-        joiningServers.add(""server."" + leaderIndex + ""=localhost:"" + port1
-                + "":""
-                + qu.getPeer(leaderIndex).peer.getElectionAddress().getPort()
-                + "":participant;localhost:""
-                + qu.getPeer(leaderIndex).peer.getClientPort());
-
-        reconfig(zkArr[followerIndex], joiningServers, null, null, -1);
-
-        testNormalOperation(zkArr[observerIndex], zkArr[followerIndex]);
-
-        Assert.assertTrue(qu.getPeer(leaderIndex).peer.getQuorumAddress()
-                .getPort() == port1);
-        Assert.assertTrue(qu.getPeer(leaderIndex).peer.leader == null
-                && qu.getPeer(leaderIndex).peer.follower != null);
-        Assert.assertTrue(qu.getPeer(followerIndex).peer.leader != null
-                && qu.getPeer(followerIndex).peer.follower == null);
-
-        joiningServers.clear();
-
-        // change in leader election port
-
-        for (int i = 1; i <= 3; i++) {
-            joiningServers.add(""server."" + i + ""=localhost:""
-                    + qu.getPeer(i).peer.getQuorumAddress().getPort() + "":""
-                    + PortAssignment.unique() + "":participant;localhost:""
-                    + qu.getPeer(i).peer.getClientPort());
-        }
-
-        reconfig(zkArr[1], joiningServers, null, null, -1);
-
-        leaderIndex = getLeaderId(qu);
-        int follower1 = leaderIndex == 1 ? 2 : 1;
-        int follower2 = 1;
-        while (follower2 == leaderIndex || follower2 == follower1)
-            follower2++;
-
-        // lets kill the leader and see if a new one is elected
-
-        qu.shutdown(getLeaderId(qu));
-
-        testNormalOperation(zkArr[follower2], zkArr[follower1]);
-        testServerHasConfig(zkArr[follower1], joiningServers, null);
-        testServerHasConfig(zkArr[follower2], joiningServers, null);
-
-        closeAllHandles(zkArr);
-    }
-
-    @Test
-    public void testUnspecifiedClientAddress() throws Exception {
-    	int[] ports = new int[3];
-    	for (int port : ports) {
-    		port = PortAssignment.unique();
-    	}
-    	String server = ""server.0=localhost:"" + ports[0] + "":"" + ports[1] + "";"" + ports[2];
-    	QuorumServer qs = new QuorumServer(0, server);
-    	Assert.assertEquals(qs.clientAddr.getHostName(), ""0.0.0.0"");
-    	Assert.assertEquals(qs.clientAddr.getPort(), ports[2]);
-    }
-    
-    @Test
-    public void testQuorumSystemChange() throws Exception {
-        qu = new QuorumUtil(3); // create 7 servers
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-
-        ArrayList<String> members = new ArrayList<String>();
-        members.add(""group.1=3:4:5"");
-        members.add(""group.2=1:2"");
-        members.add(""weight.1=0"");
-        members.add(""weight.2=0"");
-        members.add(""weight.3=1"");
-        members.add(""weight.4=1"");
-        members.add(""weight.5=1"");
-
-        for (int i = 1; i <= 5; i++) {
-            members.add(""server."" + i + ""=127.0.0.1:""
-                    + qu.getPeer(i).peer.getQuorumAddress().getPort() + "":""
-                    + qu.getPeer(i).peer.getElectionAddress().getPort() + "";""
-                    + ""127.0.0.1:"" + qu.getPeer(i).peer.getClientPort());
-        }
-
-        reconfig(zkArr[1], null, null, members, -1);
-
-        // this should flush the config to servers 2, 3, 4 and 5
-        testNormalOperation(zkArr[2], zkArr[3]);
-        testNormalOperation(zkArr[4], zkArr[5]);
-
-        for (int i = 1; i <= 5; i++) {
-            if (!(qu.getPeer(i).peer.quorumVerifier instanceof QuorumHierarchical))
-                Assert.fail(""peer "" + i
-                        + "" doesn't think the quorum system is Hieararchical!"");
-        }
-
-        qu.shutdown(1);
-        qu.shutdown(2);
-        qu.shutdown(3);
-        qu.shutdown(7);
-        qu.shutdown(6);
-
-        // servers 4 and 5 should be able to work independently
-        testNormalOperation(zkArr[4], zkArr[5]);
-
-        qu.restart(1);
-        qu.restart(2);
-
-        members.clear();
-        for (int i = 1; i <= 3; i++) {
-            members.add(""server."" + i + ""=127.0.0.1:""
-                    + qu.getPeer(i).peer.getQuorumAddress().getPort() + "":""
-                    + qu.getPeer(i).peer.getElectionAddress().getPort() + "";""
-                    + ""127.0.0.1:"" + qu.getPeer(i).peer.getClientPort());
-        }
-
-        reconfig(zkArr[1], null, null, members, -1);
-
-        // flush the config to server 2
-        testNormalOperation(zkArr[1], zkArr[2]);
-
-        qu.shutdown(4);
-        qu.shutdown(5);
-
-        // servers 1 and 2 should be able to work independently
-        testNormalOperation(zkArr[1], zkArr[2]);
-
-        for (int i = 1; i <= 2; i++) {
-            if (!(qu.getPeer(i).peer.quorumVerifier instanceof QuorumMaj))
-                Assert.fail(""peer ""
-                        + i
-                        + "" doesn't think the quorum system is a majority quorum system!"");
-        }
-
-        closeAllHandles(zkArr);
-    }
-    
-    @Test
-    public void testInitialConfigHasPositiveVersion() throws Exception {
-        qu = new QuorumUtil(1); // create 3 servers
-        qu.disableJMXTest = true;
-        qu.startAll();
-        ZooKeeper[] zkArr = createHandles(qu);
-        testNormalOperation(zkArr[1], zkArr[2]);
-        for (int i=1; i<4; i++) {
-            String configStr = testServerHasConfig(zkArr[i], null, null);
-            QuorumVerifier qv = qu.getPeer(i).peer.configFromString(configStr);
-            long version = qv.getVersion();
-            Assert.assertTrue(version == 0x100000000L);
-        }
-    }
-}
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.AsyncCallback.DataCallback;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
+import org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical;
+import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
+import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
+import org.junit.Assert;
+import org.junit.After;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ReconfigTest extends ZKTestCase implements DataCallback{
+    private static final Logger LOG = LoggerFactory
+            .getLogger(ReconfigTest.class);
+
+    private QuorumUtil qu;
+
+    @After
+    public void tearDown() throws Exception {
+        if (qu != null) {
+            qu.tearDown();
+        }
+    }
+
+    public static String reconfig(ZooKeeper zk, List<String> joiningServers,
+            List<String> leavingServers, List<String> newMembers, long fromConfig)
+            throws KeeperException, InterruptedException {
+        byte[] config = null;
+        for (int j = 0; j < 30; j++) {
+            try {
+                config = zk.reconfig(joiningServers, leavingServers,
+                        newMembers, fromConfig, new Stat());
+                break;
+            } catch (KeeperException.ConnectionLossException e) {
+                if (j < 29) {
+                    Thread.sleep(1000);
+                } else {
+                    // test fails if we still can't connect to the quorum after
+                    // 30 seconds.
+                    Assert.fail(""client could not connect to reestablished quorum: giving up after 30+ seconds."");
+                }
+            }
+        }
+
+        String configStr = new String(config);
+        if (joiningServers != null) {
+            for (String joiner : joiningServers)
+                Assert.assertTrue(configStr.contains(joiner));
+        }
+        if (leavingServers != null) {
+            for (String leaving : leavingServers)
+                Assert.assertFalse(configStr.contains(""server."".concat(leaving)));
+        }
+
+        return configStr;
+    }
+
+    public static String testServerHasConfig(ZooKeeper zk,
+            List<String> joiningServers, List<String> leavingServers)
+            throws KeeperException, InterruptedException {
+        byte[] config = null;
+        for (int j = 0; j < 30; j++) {
+            try {
+                zk.sync(""/"", null, null);
+                config = zk.getConfig(false, new Stat());
+                break;
+            } catch (KeeperException.ConnectionLossException e) {
+                if (j < 29) {
+                    Thread.sleep(1000);
+                } else {
+                    // test fails if we still can't connect to the quorum after
+                    // 30 seconds.
+                    Assert.fail(""client could not connect to reestablished quorum: giving up after 30+ seconds."");
+                }
+            }
+
+        }
+        String configStr = new String(config);
+        if (joiningServers != null) {
+            for (String joiner : joiningServers) {
+               Assert.assertTrue(configStr.contains(joiner));
+            }
+        }
+        if (leavingServers != null) {
+            for (String leaving : leavingServers)
+                Assert.assertFalse(configStr.contains(""server."".concat(leaving)));
+        }
+
+        return configStr;
+    }
+    
+    public static void testNormalOperation(ZooKeeper writer, ZooKeeper reader)
+            throws KeeperException, InterruptedException {
+        boolean testNodeExists = false;
+       
+       for (int j = 0; j < 30; j++) {
+            try {
+               if (!testNodeExists) {
+                   try{ 
+                       writer.create(""/test"", ""test"".getBytes(),
+                           ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+                   } catch (KeeperException.NodeExistsException e) {                       
+                   }
+                   testNodeExists = true;
+               }
+                String data = ""test"" + j;
+                writer.setData(""/test"", data.getBytes(), -1);
+                reader.sync(""/"", null, null);
+                byte[] res = reader.getData(""/test"", null, new Stat());
+                Assert.assertEquals(data, new String(res));
+                break;
+            } catch (KeeperException.ConnectionLossException e) {
+                if (j < 29) {
+                    Thread.sleep(1000);
+                } else {
+                    // test fails if we still can't connect to the quorum after
+                    // 30 seconds.
+                    Assert.fail(""client could not connect to reestablished quorum: giving up after 30+ seconds."");
+                }
+            }
+
+        }
+
+    }    
+    
+    private int getLeaderId(QuorumUtil qu) {
+        int leaderId = 1;
+        while (qu.getPeer(leaderId).peer.leader == null)
+            leaderId++;
+        return leaderId;
+    }
+
+    private ZooKeeper[] createHandles(QuorumUtil qu) throws IOException {
+        // create an extra handle, so we can index the handles from 1 to qu.ALL
+        // using the server id.
+        ZooKeeper[] zkArr = new ZooKeeper[qu.ALL + 1];
+        zkArr[0] = null; // not used.
+        for (int i = 1; i <= qu.ALL; i++) {
+            // server ids are 1, 2 and 3
+            zkArr[i] = new ZooKeeper(""127.0.0.1:""
+                    + qu.getPeer(i).peer.getClientPort(),
+                    ClientBase.CONNECTION_TIMEOUT, new Watcher() {
+                        public void process(WatchedEvent event) {
+                        }});
+        }
+        return zkArr;
+    }
+
+    private void closeAllHandles(ZooKeeper[] zkArr) throws InterruptedException {
+        for (ZooKeeper zk : zkArr)
+            if (zk != null)
+                zk.close();
+    }
+
+ 
+    @Test
+    public void testRemoveAddOne() throws Exception {
+        qu = new QuorumUtil(1); // create 3 servers
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+
+        List<String> leavingServers = new ArrayList<String>();
+        List<String> joiningServers = new ArrayList<String>();
+
+        int leaderIndex = getLeaderId(qu);
+
+        // during first iteration, leavingIndex will correspond to a follower
+        // during second iteration leavingIndex will be the index of the leader
+        int leavingIndex = (leaderIndex == 1) ? 2 : 1;
+
+        for (int i = 0; i < 2; i++) {
+            // some of the operations will be executed by a client connected to
+            // the removed server
+            // while others are invoked by a client connected to some other
+            // server.
+            // when we're removing the leader, zk1 will be the client connected
+            // to removed server
+            ZooKeeper zk1 = (leavingIndex == leaderIndex) ? zkArr[leaderIndex]
+                    : zkArr[(leaderIndex % qu.ALL) + 1];
+            ZooKeeper zk2 = (leavingIndex == leaderIndex) ? zkArr[(leaderIndex % qu.ALL) + 1]
+                    : zkArr[leaderIndex];
+
+            leavingServers.add(Integer.toString(leavingIndex));
+
+            // remember this server so we can add it back later
+            joiningServers.add(""server.""
+                    + leavingIndex
+                    + ""=localhost:""
+                    + qu.getPeer(leavingIndex).peer.getQuorumAddress()
+                            .getPort()
+                    + "":""
+                    + qu.getPeer(leavingIndex).peer.getElectionAddress()
+                            .getPort() + "":participant;localhost:""
+                    + qu.getPeer(leavingIndex).peer.getClientPort());
+
+            String configStr = reconfig(zk1, null, leavingServers, null, -1);
+            testServerHasConfig(zk2, null, leavingServers);
+            testNormalOperation(zk2, zk1);
+
+            QuorumVerifier qv = qu.getPeer(1).peer.configFromString(configStr);
+            long version = qv.getVersion();
+
+            // checks that conditioning on version works properly
+            try {
+                reconfig(zk2, joiningServers, null, null, version + 1);
+                Assert.fail(""reconfig succeeded even though version condition was incorrect!"");
+            } catch (KeeperException.BadVersionException e) {
+
+            }
+
+            reconfig(zk2, joiningServers, null, null, version);
+
+            testNormalOperation(zk1, zk2);
+            testServerHasConfig(zk1, joiningServers, null);
+
+            // second iteration of the loop will remove the leader
+            // and add it back (as follower)
+            leavingIndex = leaderIndex = getLeaderId(qu);
+            leavingServers.clear();
+            joiningServers.clear();
+        }
+
+        closeAllHandles(zkArr);
+    }
+
+    /**
+     * 1. removes and adds back two servers (incl leader). One of the servers is added back as observer
+     * 2. tests that reconfig fails if quorum of new config is not up
+     * 3. tests that a server that's not up during reconfig learns the new config when it comes up
+     * @throws Exception
+     */
+    @Test
+    public void testRemoveAddTwo() throws Exception {
+        qu = new QuorumUtil(2); // create 5 servers
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+
+        List<String> leavingServers = new ArrayList<String>();
+        List<String> joiningServers = new ArrayList<String>();
+
+        int leaderIndex = getLeaderId(qu);
+
+        // lets remove the leader and some other server
+        int leavingIndex1 = leaderIndex;
+        int leavingIndex2 = (leaderIndex == 1) ? 2 : 1;
+
+        // find some server that's staying
+        int stayingIndex1 = 1, stayingIndex2 = 1, stayingIndex3 = 1;
+        while (stayingIndex1 == leavingIndex1 || stayingIndex1 == leavingIndex2)
+            stayingIndex1++;
+
+        while (stayingIndex2 == leavingIndex1 || stayingIndex2 == leavingIndex2
+                || stayingIndex2 == stayingIndex1)
+            stayingIndex2++;
+
+        while (stayingIndex3 == leavingIndex1 || stayingIndex3 == leavingIndex2
+                || stayingIndex3 == stayingIndex1
+                || stayingIndex3 == stayingIndex2)
+            stayingIndex3++;
+
+        leavingServers.add(Integer.toString(leavingIndex1));
+        leavingServers.add(Integer.toString(leavingIndex2));
+
+        // remember these servers so we can add them back later
+        joiningServers.add(""server."" + leavingIndex1 + ""=localhost:""
+                + qu.getPeer(leavingIndex1).peer.getQuorumAddress().getPort()
+                + "":""
+                + qu.getPeer(leavingIndex1).peer.getElectionAddress().getPort()
+                + "":participant;localhost:""
+                + qu.getPeer(leavingIndex1).peer.getClientPort());
+
+        // this server will be added back as an observer
+        joiningServers.add(""server."" + leavingIndex2 + ""=localhost:""
+                + qu.getPeer(leavingIndex2).peer.getQuorumAddress().getPort()
+                + "":""
+                + qu.getPeer(leavingIndex2).peer.getElectionAddress().getPort()
+                + "":observer;localhost:""
+                + qu.getPeer(leavingIndex2).peer.getClientPort());
+
+        qu.shutdown(leavingIndex1);
+        qu.shutdown(leavingIndex2);
+
+        // 3 servers still up so this should work
+        reconfig(zkArr[stayingIndex2], null, leavingServers, null, -1);
+        
+        qu.shutdown(stayingIndex2);
+
+        // the following commands would not work in the original
+        // cluster of 5, but now that we've removed 2 servers
+        // we have a cluster of 3 servers and one of them is allowed to fail
+
+        testServerHasConfig(zkArr[stayingIndex1], null, leavingServers);
+        testServerHasConfig(zkArr[stayingIndex3], null, leavingServers);
+        testNormalOperation(zkArr[stayingIndex1], zkArr[stayingIndex3]);
+        
+        // this is a test that a reconfig will only succeed
+        // if there is a quorum up in new config. Below there is no
+        // quorum so it should fail
+        
+        // the sleep is necessary so that the leader figures out
+        // that the switched off servers are down
+        Thread.sleep(10000);
+
+        try {
+            reconfig(zkArr[stayingIndex1], joiningServers, null, null, -1);
+            Assert.fail(""reconfig completed successfully even though there is no quorum up in new config!"");
+        } catch (KeeperException.NewConfigNoQuorum e) {
+
+        }
+        
+        // now start the third server so that new config has quorum
+        qu.restart(stayingIndex2);
+
+        reconfig(zkArr[stayingIndex1], joiningServers, null, null, -1);
+        testNormalOperation(zkArr[stayingIndex2], zkArr[stayingIndex3]);
+        testServerHasConfig(zkArr[stayingIndex2], joiningServers, null);
+
+        // this server wasn't around during the configuration change
+        // we should check that it is able to connect, finds out
+        // about the change and becomes an observer.
+
+        qu.restart(leavingIndex2);
+        Assert.assertTrue(qu.getPeer(leavingIndex2).peer.getPeerState() == ServerState.OBSERVING);
+        testNormalOperation(zkArr[stayingIndex2], zkArr[leavingIndex2]);
+        testServerHasConfig(zkArr[leavingIndex2], joiningServers, null);
+
+        closeAllHandles(zkArr);
+    }
+
+    @Test
+    public void testBulkReconfig() throws Exception {
+        qu = new QuorumUtil(3); // create 7 servers
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+
+        // new config will have three of the servers as followers
+        // two of the servers as observers, and all ports different
+        ArrayList<String> newServers = new ArrayList<String>();
+        for (int i = 1; i <= 5; i++) {
+            String server = ""server."" + i + ""=localhost:"" + PortAssignment.unique()
+                    + "":"" + PortAssignment.unique() + "":""
+                    + ((i == 4 || i == 5) ? ""observer"" : ""participant"")
+                    + "";localhost:"" + qu.getPeer(i).peer.getClientPort();
+            newServers.add(server);
+        }
+
+        qu.shutdown(3);
+        qu.shutdown(6);
+        qu.shutdown(7);
+        
+        reconfig(zkArr[1], null, null, newServers, -1);
+        testNormalOperation(zkArr[1], zkArr[2]);
+       
+        testServerHasConfig(zkArr[1], newServers, null);
+        testServerHasConfig(zkArr[2], newServers, null);
+        testServerHasConfig(zkArr[4], newServers, null);
+        testServerHasConfig(zkArr[5], newServers, null);
+    
+        qu.shutdown(5);
+        qu.shutdown(4);
+        
+        testNormalOperation(zkArr[1], zkArr[2]);
+
+        closeAllHandles(zkArr);
+    }
+
+    @Test
+    public void testRemoveOneAsynchronous() throws Exception {
+        qu = new QuorumUtil(2); 
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+
+        List<String> leavingServers = new ArrayList<String>();
+       
+        // lets remove someone who's not the leader
+        leavingServers.add(getLeaderId(qu) == 5 ? ""4"": ""5"");
+ 
+        LinkedList<Integer> results = new LinkedList<Integer>();
+        
+        zkArr[1].reconfig(null, leavingServers, null, -1, this, results);   
+        
+        synchronized (results) {
+            while (results.size() < 1) {
+               results.wait();
+            }
+        }        
+        Assert.assertEquals(0, (int) results.get(0));
+        
+        testNormalOperation(zkArr[1], zkArr[2]);       
+        for (int i=1; i<=5; i++)
+            testServerHasConfig(zkArr[i], null, leavingServers);
+
+        closeAllHandles(zkArr);
+    }
+
+    @SuppressWarnings(""unchecked"")
+    public void processResult(int rc, String path, Object ctx, byte[] data,
+            Stat stat) {
+        synchronized(ctx) {
+            ((LinkedList<Integer>)ctx).add(rc);
+            ctx.notifyAll();
+        }
+    }
+    
+    
+    @Test
+    public void testRoleChange() throws Exception {
+        qu = new QuorumUtil(1); // create 3 servers
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+
+        // changing a server's role / port is done by ""adding"" it with the same
+        // id but different role / port
+        List<String> joiningServers = new ArrayList<String>();
+
+        int leaderIndex = getLeaderId(qu);
+
+        // during first and second iteration, leavingIndex will correspond to a
+        // follower
+        // during third and fouth iteration leavingIndex will be the index of
+        // the leader
+        int changingIndex = (leaderIndex == 1) ? 2 : 1;
+
+        // first convert participant to observer, then observer to participant,
+        // and so on
+        String newRole = ""observer"";
+
+        for (int i = 0; i < 4; i++) {
+            // some of the operations will be executed by a client connected to
+            // the removed server
+            // while others are invoked by a client connected to some other
+            // server.
+            // when we're removing the leader, zk1 will be the client connected
+            // to removed server
+            ZooKeeper zk1 = (changingIndex == leaderIndex) ? zkArr[leaderIndex]
+                    : zkArr[(leaderIndex % qu.ALL) + 1];
+
+            // exactly as it is now, except for role change
+            joiningServers.add(""server.""
+                    + changingIndex
+                    + ""=localhost:""
+                    + qu.getPeer(changingIndex).peer.getQuorumAddress()
+                            .getPort()
+                    + "":""
+                    + qu.getPeer(changingIndex).peer.getElectionAddress()
+                            .getPort() + "":"" + newRole + "";localhost:""
+                    + qu.getPeer(changingIndex).peer.getClientPort());
+
+            reconfig(zk1, joiningServers, null, null, -1);
+            testNormalOperation(zkArr[changingIndex], zk1);
+
+            if (newRole.equals(""observer"")) {
+                Assert.assertTrue(qu.getPeer(changingIndex).peer.observer != null
+                        && qu.getPeer(changingIndex).peer.follower == null
+                        && qu.getPeer(changingIndex).peer.leader == null);
+                Assert.assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);
+            } else {
+                Assert.assertTrue(qu.getPeer(changingIndex).peer.observer == null
+                        && (qu.getPeer(changingIndex).peer.follower != null || qu
+                                .getPeer(changingIndex).peer.leader != null));
+                Assert.assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.FOLLOWING
+                        || qu.getPeer(changingIndex).peer.getPeerState() == ServerState.LEADING);
+            }
+
+            joiningServers.clear();
+
+            if (newRole.equals(""observer"")) {
+                newRole = ""participant"";
+            } else {
+                // lets change leader to observer
+                newRole = ""observer"";
+                leaderIndex = getLeaderId(qu);
+                changingIndex = leaderIndex;
+            }
+        }
+        closeAllHandles(zkArr);
+    }
+
+    @Test
+    public void testPortChange() throws Exception {
+        qu = new QuorumUtil(1); // create 3 servers
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+
+        List<String> joiningServers = new ArrayList<String>();
+
+        int leaderIndex = getLeaderId(qu);
+        int followerIndex = leaderIndex == 1 ? 2 : 1;
+
+        // change leader into observer, and modify all its ports at the same
+        // time
+        int observerIndex = leaderIndex;
+
+        // new ports
+        int port1 = PortAssignment.unique();
+        int port2 = PortAssignment.unique();
+        int port3 = PortAssignment.unique();
+        joiningServers.add(""server."" + observerIndex + ""=localhost:"" + port1
+                + "":"" + port2 + "":observer;localhost:"" + port3);
+
+        // create a /test znode and check that read/write works before
+        // any reconfig is invoked
+        testNormalOperation(zkArr[observerIndex], zkArr[followerIndex]);
+
+        reconfig(zkArr[followerIndex], joiningServers, null, null, -1);
+
+        // the change of port may not be immediate -- we repeatedly
+        // invoke an operation expecting it to eventually fail once
+        // the client port of observerIndex changes. If it didn't
+        // change -- that's an error.
+        try {
+          for (int i=0; i < 30; i++) {
+            Thread.sleep(1000);
+            zkArr[observerIndex].setData(""/test"", ""teststr"".getBytes(), -1);
+          }
+          Assert.fail(""client port didn't change"");
+        } catch (KeeperException.ConnectionLossException e) {
+            zkArr[observerIndex] = new ZooKeeper(""127.0.0.1:""
+                    + qu.getPeer(observerIndex).peer.getClientPort(),
+                    ClientBase.CONNECTION_TIMEOUT, new Watcher() {
+                        public void process(WatchedEvent event) {}});
+        }
+
+        leaderIndex = getLeaderId(qu);
+
+        followerIndex = 1;
+        while (followerIndex == leaderIndex || followerIndex == observerIndex)
+            followerIndex++;
+
+        testNormalOperation(zkArr[observerIndex], zkArr[followerIndex]);
+
+        testServerHasConfig(zkArr[observerIndex], joiningServers, null);
+
+        Assert.assertTrue(qu.getPeer(observerIndex).peer.getQuorumAddress()
+                .getPort() == port1);
+        Assert.assertTrue(qu.getPeer(observerIndex).peer.getElectionAddress()
+                .getPort() == port2);
+        Assert.assertTrue(qu.getPeer(observerIndex).peer.getClientPort() == port3);
+        Assert.assertTrue(qu.getPeer(observerIndex).peer.getPeerState() == ServerState.OBSERVING);
+
+        joiningServers.clear();
+
+        // change leader's leading port - should renounce leadership
+
+        port1 = PortAssignment.unique();
+        joiningServers.add(""server."" + leaderIndex + ""=localhost:"" + port1
+                + "":""
+                + qu.getPeer(leaderIndex).peer.getElectionAddress().getPort()
+                + "":participant;localhost:""
+                + qu.getPeer(leaderIndex).peer.getClientPort());
+
+        reconfig(zkArr[followerIndex], joiningServers, null, null, -1);
+
+        testNormalOperation(zkArr[observerIndex], zkArr[followerIndex]);
+
+        Assert.assertTrue(qu.getPeer(leaderIndex).peer.getQuorumAddress()
+                .getPort() == port1);
+        Assert.assertTrue(qu.getPeer(leaderIndex).peer.leader == null
+                && qu.getPeer(leaderIndex).peer.follower != null);
+        Assert.assertTrue(qu.getPeer(followerIndex).peer.leader != null
+                && qu.getPeer(followerIndex).peer.follower == null);
+
+        joiningServers.clear();
+
+        // change in leader election port
+
+        for (int i = 1; i <= 3; i++) {
+            joiningServers.add(""server."" + i + ""=localhost:""
+                    + qu.getPeer(i).peer.getQuorumAddress().getPort() + "":""
+                    + PortAssignment.unique() + "":participant;localhost:""
+                    + qu.getPeer(i).peer.getClientPort());
+        }
+
+        reconfig(zkArr[1], joiningServers, null, null, -1);
+
+        leaderIndex = getLeaderId(qu);
+        int follower1 = leaderIndex == 1 ? 2 : 1;
+        int follower2 = 1;
+        while (follower2 == leaderIndex || follower2 == follower1)
+            follower2++;
+
+        // lets kill the leader and see if a new one is elected
+
+        qu.shutdown(getLeaderId(qu));
+
+        testNormalOperation(zkArr[follower2], zkArr[follower1]);
+        testServerHasConfig(zkArr[follower1], joiningServers, null);
+        testServerHasConfig(zkArr[follower2], joiningServers, null);
+
+        closeAllHandles(zkArr);
+    }
+
+    @Test
+    public void testUnspecifiedClientAddress() throws Exception {
+    	int[] ports = new int[3];
+    	for (int port : ports) {
+    		port = PortAssignment.unique();
+    	}
+    	String server = ""server.0=localhost:"" + ports[0] + "":"" + ports[1] + "";"" + ports[2];
+    	QuorumServer qs = new QuorumServer(0, server);
+    	Assert.assertEquals(qs.clientAddr.getHostName(), ""0.0.0.0"");
+    	Assert.assertEquals(qs.clientAddr.getPort(), ports[2]);
+    }
+    
+    @Test
+    public void testQuorumSystemChange() throws Exception {
+        qu = new QuorumUtil(3); // create 7 servers
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+
+        ArrayList<String> members = new ArrayList<String>();
+        members.add(""group.1=3:4:5"");
+        members.add(""group.2=1:2"");
+        members.add(""weight.1=0"");
+        members.add(""weight.2=0"");
+        members.add(""weight.3=1"");
+        members.add(""weight.4=1"");
+        members.add(""weight.5=1"");
+
+        for (int i = 1; i <= 5; i++) {
+            members.add(""server."" + i + ""=127.0.0.1:""
+                    + qu.getPeer(i).peer.getQuorumAddress().getPort() + "":""
+                    + qu.getPeer(i).peer.getElectionAddress().getPort() + "";""
+                    + ""127.0.0.1:"" + qu.getPeer(i).peer.getClientPort());
+        }
+
+        reconfig(zkArr[1], null, null, members, -1);
+
+        // this should flush the config to servers 2, 3, 4 and 5
+        testNormalOperation(zkArr[2], zkArr[3]);
+        testNormalOperation(zkArr[4], zkArr[5]);
+
+        for (int i = 1; i <= 5; i++) {
+            if (!(qu.getPeer(i).peer.quorumVerifier instanceof QuorumHierarchical))
+                Assert.fail(""peer "" + i
+                        + "" doesn't think the quorum system is Hieararchical!"");
+        }
+
+        qu.shutdown(1);
+        qu.shutdown(2);
+        qu.shutdown(3);
+        qu.shutdown(7);
+        qu.shutdown(6);
+
+        // servers 4 and 5 should be able to work independently
+        testNormalOperation(zkArr[4], zkArr[5]);
+
+        qu.restart(1);
+        qu.restart(2);
+
+        members.clear();
+        for (int i = 1; i <= 3; i++) {
+            members.add(""server."" + i + ""=127.0.0.1:""
+                    + qu.getPeer(i).peer.getQuorumAddress().getPort() + "":""
+                    + qu.getPeer(i).peer.getElectionAddress().getPort() + "";""
+                    + ""127.0.0.1:"" + qu.getPeer(i).peer.getClientPort());
+        }
+
+        reconfig(zkArr[1], null, null, members, -1);
+
+        // flush the config to server 2
+        testNormalOperation(zkArr[1], zkArr[2]);
+
+        qu.shutdown(4);
+        qu.shutdown(5);
+
+        // servers 1 and 2 should be able to work independently
+        testNormalOperation(zkArr[1], zkArr[2]);
+
+        for (int i = 1; i <= 2; i++) {
+            if (!(qu.getPeer(i).peer.quorumVerifier instanceof QuorumMaj))
+                Assert.fail(""peer ""
+                        + i
+                        + "" doesn't think the quorum system is a majority quorum system!"");
+        }
+
+        closeAllHandles(zkArr);
+    }
+    
+    @Test
+    public void testInitialConfigHasPositiveVersion() throws Exception {
+        qu = new QuorumUtil(1); // create 3 servers
+        qu.disableJMXTest = true;
+        qu.startAll();
+        ZooKeeper[] zkArr = createHandles(qu);
+        testNormalOperation(zkArr[1], zkArr[2]);
+        for (int i=1; i<4; i++) {
+            String configStr = testServerHasConfig(zkArr[i], null, null);
+            QuorumVerifier qv = qu.getPeer(i).peer.configFromString(configStr);
+            long version = qv.getVersion();
+            Assert.assertTrue(version == 0x100000000L);
+        }
+    }
+}
",,6461
2704,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/TxnLogProposalIterator.java,9f102d311e0d68a2e0a212b1c870a6f999a128a5,1372454555,80,5d00c83b2a94bf40477651d9b0176e2d7d07012a,1392220809,80,,,,,"            p.request = null;",,,6461
2705,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,28246a44ef4653515708937fc2a9c5d51baa0937,1381188920,365,2a372fcdce3c0142c0bb23f06098a2c1a49f807e,1532745428,375,,,,,"                jmxDataTreeBean = null;",,,6461
2706,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,28246a44ef4653515708937fc2a9c5d51baa0937,1381188920,369,fb267672d219c73c0cf2527fafebc1a0b17d3bee,1498235945,375,,,,,"            jmxServerBean = null;",,,6461
2707,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,28246a44ef4653515708937fc2a9c5d51baa0937,1381188920,458,2a372fcdce3c0142c0bb23f06098a2c1a49f807e,1532745428,464,,,,,"        jmxServerBean = null;",,,6461
2708,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,28246a44ef4653515708937fc2a9c5d51baa0937,1381188920,459,a0eba7abd002498631da8d8127261c297c911590,1498428967,464,,,,,"        jmxDataTreeBean = null;",,,6461
2709,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,f7c7765b6c4e2b9f69af9d80b63bee5daf2df90f,1389652445,1943,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,2141,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2710,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,f7c7765b6c4e2b9f69af9d80b63bee5daf2df90f,1389652445,1983,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2711,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,f7c7765b6c4e2b9f69af9d80b63bee5daf2df90f,1389652445,2068,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2712,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,f7c7765b6c4e2b9f69af9d80b63bee5daf2df90f,1389652445,2113,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2713,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,98789ea4876fea771ca761d1c66d44e18d104b8e,1390544312,2160,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,2181,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2714,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,98789ea4876fea771ca761d1c66d44e18d104b8e,1390544312,2245,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,2266,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2715,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,98789ea4876fea771ca761d1c66d44e18d104b8e,1390544312,2290,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,2311,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2716,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/RemoveWatchesTest.java,98789ea4876fea771ca761d1c66d44e18d104b8e,1390544312,122,a1cd9204d298ca9b5b30c2f272d55b306c393271,1398731038,146,,,,,"            zk1 = null;",,,6461
2717,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/RemoveWatchesTest.java,98789ea4876fea771ca761d1c66d44e18d104b8e,1390544312,159,a1cd9204d298ca9b5b30c2f272d55b306c393271,1398731038,183,,,,,"            zk1 = null;",,,6461
2718,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,d88a04ffdfa37cb80f4a8adf2d205d9a36b27840,1392338070,611,,,,,,,,"            recvWorker = null;",,,6461
2719,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/DataTreeTest.java,6aaa3b23f708fbbd1c04f58646ba27cb70831e27,1392773513,59,,,,,,,,"        dt=null;",,,6461
2720,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java,66646796c2173423655c7faf2b458b658143e6b5,1395380171,156,,,,,,,,"        jmxServerBean = null;",,,6461
2721,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,1395544376,623,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,634,,,,,"            recvWorker = null;",,,6461
2722,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,71989813100ed91620ec18989cd2d0b1b7c8a9df,1395608611,440,,,,,,,,"            name = null;",,,6461
2723,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,71989813100ed91620ec18989cd2d0b1b7c8a9df,1395608611,488,,,,,,,,"            stat = null;",,,6461
2724,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,71989813100ed91620ec18989cd2d0b1b7c8a9df,1395608611,536,,,,,,,,"            stat = null;",,,6461
2725,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,71989813100ed91620ec18989cd2d0b1b7c8a9df,1395608611,555,,,,,,,,"            stat = null;",,,6461
2726,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,71989813100ed91620ec18989cd2d0b1b7c8a9df,1395608611,569,,,,,,,,"            stat = null;",,,6461
2727,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java,14c3f3450c34a6b4ce2c63815441204eec512220,1395781999,154,,,,,,,,"                currentThread = null;",,,6461
2728,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,198,15e3f7fccc770783786e8097f7a6618509bfee0f,1487060662,198,,,,,"                this.zooKeeper = null;",,,6461
2729,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,120,,,,,,,,"                return super.exists(path, watch ? watcher : null);",,,6461
2730,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,165,,,,,,,,"                return super.getChildren(path, watch ? watcher : null);",,,6461
2731,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,195,,,,,,,,"                return super.getData(path, watch ? watcher : null, stat);",,,6461
2732,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ReconfigTest.java,b1befb0c4d51d13081690fcb0994bc306de7cc2f,1396574677,172,,,,,,,,"        zkArr[0] = null; // not used.",,,6461
2733,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,903ce8dff71fb53de27ba2c16563e4ed43bf504e,1400384946,1013,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,1017,,,,,"            jmxLocalPeerBean = null;",,,6461
2734,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,177,,,,,,,,"            name = null;",,,6461
2735,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,185,,,,,,,,"            name = null;",,,6461
2736,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,196,,,,,,,,"            name = null;",,,6461
2737,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,244,,,,,,,,"            stat = null;",,,6461
2738,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,245,,,,,,,,"            acl = null;",,,6461
2739,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,489,,,,,,,,"            name = null;",,,6461
2740,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,490,,,,,,,,"            stat = null;",,,6461
2741,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,497,,,,,,,,"            name = null;",,,6461
2742,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,498,,,,,,,,"            stat = null;",,,6461
2743,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,510,,,,,,,,"            stat = null;",,,6461
2744,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,559,,,,,,,,"            data = null;",,,6461
2745,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,560,,,,,,,,"            stat = null;",,,6461
2746,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,608,,,,,,,,"            stat = null;",,,6461
2747,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,617,,,,,,,,"            stat = null;",,,6461
2748,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,637,,,,,,,,"            stat = null;",,,6461
2749,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,646,,,,,,,,"            stat = null;",,,6461
2750,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/AsyncOps.java,d53be91194395c01d5f78361717e03439b8fb942,1403715965,661,,,,,,,,"            stat = null;",,,6461
2751,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java,9a97169a433b6eff5c58ff563bbb783c17248fb5,1405630603,241,,,,,,,,"        sockKey = null;",,,6461
2752,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,0214cfcdde243e0adf2e81c94bb3d48e25308f2b,1405709336,865,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2753,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,0214cfcdde243e0adf2e81c94bb3d48e25308f2b,1405709336,1060,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2754,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java,0214cfcdde243e0adf2e81c94bb3d48e25308f2b,1405709336,154,,,,,,,,"                currentThread = null;",,,6461
2755,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,836,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2756,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,972,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2757,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,865,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2758,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,1060,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2759,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,138,,,,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1405824620,"            this.clientAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2760,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,144,bad9ede36559615bb7eafe8e4d333f2c7c353faa,1406871485,144,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1405824620,"            this.electionAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2761,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,212,,,,,,,,"            this.clientAddr = null;",,,6461
2762,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2763,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2764,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,5d3675d4bc5867f90a96986337ce570e171508d7,1405824620,1015,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,1017,,,,,"            jmxQuorumBean = null;",,,6461
2765,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,43deb9b8a8efb0befd4e17cd5ab3e907a700d5c8,1406004677,687,,,,,,,,"                ia = null;",,,6461
2766,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,43deb9b8a8efb0befd4e17cd5ab3e907a700d5c8,1406004677,688,0b65e3d4cbb7647ea692bfea59c02e5b24bf821c,1536189061,686,,,,,"                hdr = null;",,,6461
2767,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java,43deb9b8a8efb0befd4e17cd5ab3e907a700d5c8,1406004677,836,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2768,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java,43deb9b8a8efb0befd4e17cd5ab3e907a700d5c8,1406004677,972,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2769,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,892e10f6a45cca0464dae4089265511b7d0b9a38,1406136979,253,,,,,,,,"                        electionAddr = null;",,,6461
2770,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,892e10f6a45cca0464dae4089265511b7d0b9a38,1406136979,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2771,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,892e10f6a45cca0464dae4089265511b7d0b9a38,1406136979,634,,,,,,,,"            recvWorker = null;",,,6461
2772,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java,135a315933c4899fe0f0d6fe5d89c2fc1f881e4a,1408001526,142,,,,,,,,"                peer = null;",,,6461
2773,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java,0b585528c8d8c36715b3489900e77c9198301102,1408481441,154,,,,,,,,"                currentThread = null;",,,6461
2774,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java,a95add82db688000a7dc2ceb15464c368e7702fb,1422584630,161,,,,,,,,"                        cnxn.queuedBuffer = null;",,,6461
2775,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java,a95add82db688000a7dc2ceb15464c368e7702fb,1422584630,206,,,,,,,,"                            cnxn.queuedBuffer = null;",,,6461
2776,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,1529,,,,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2777,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,1567,,,,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2778,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,1640,f0b67b6e49acec5f022bee25e08f82a29572c97a,1519166280,1640,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2779,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,1678,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2780,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,1772,,,,,,,,"        return getConfig(watch ? watchManager.defaultWatcher : null, stat);",,,6461
2781,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,2141,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2782,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,2181,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2783,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,2266,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2784,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,2ba2ae309e6d11f224bab84e68e0d23f963b3aaa,1426493344,2311,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2785,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,634,,,,,,,,"            recvWorker = null;",,,6461
2786,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,138,,,,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1428603397,"            this.clientAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2787,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,212,,,,,,,,"            this.clientAddr = null;",,,6461
2788,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2789,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2790,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2791,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,1016,,,,,,,,"            jmxLocalPeerBean = null;",,,6461
2792,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,b52252aeb460b65a7e53f31af241160c6b6c5b56,1428603397,1017,,,,,,,,"            jmxRemotePeerBean = null;",,,6461
2793,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/RemoveWatchesTest.java,c88423a925b69e7446b75bc127e2fd2dac30eee7,1430793516,146,,,,,,,,"            zk1 = null;",,,6461
2794,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/RemoveWatchesTest.java,c88423a925b69e7446b75bc127e2fd2dac30eee7,1430793516,183,,,,,,,,"            zk1 = null;",,,6461
2795,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,138,,,,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1431210467,"            this.clientAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2796,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,145,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,144,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,-1,1435363410/1431210467,"            this.clientAddr = null;","         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
",,6461
2797,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,212,,,,,,,,"            this.clientAddr = null;",,,6461
2798,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2799,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2800,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,1017,,,,,,,,"            jmxRemotePeerBean = null;",,,6461
2801,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ReconfigTest.java,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,1431210467,178,,,,,,,,"        zkArr[0] = null; // not used.",,,6461
2802,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,692bfe67ad63fb7cf2e1b901f06f1787c74e5f8d,1431580201,253,,,,,,,,"                        electionAddr = null;",,,6461
2803,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,692bfe67ad63fb7cf2e1b901f06f1787c74e5f8d,1431580201,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2804,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,692bfe67ad63fb7cf2e1b901f06f1787c74e5f8d,1431580201,634,,,,,,,,"            recvWorker = null;",,,6461
2805,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,fb13c80bd3400f6b2c7a21a952e49c3a196c4d2f,1431662728,1056,,,,,,,,"                rwServerAddress = null;",,,6461
2806,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,1529,,,,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2807,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,1567,,,,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2808,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,1640,,,,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2809,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,1678,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2810,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,1772,,,,,,,,"        return getConfig(watch ? watchManager.defaultWatcher : null, stat);",,,6461
2811,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,1781,,,,,,,,"        getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2812,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,2141,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2813,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,2181,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2814,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,2266,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2815,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,3a7a240ef7381edf15925045e9f94408177e51cd,1432921553,2311,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2816,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,63884670328f09a3814db54cb4644d683822e4d4,1432936009,253,,,,,,,,"                        electionAddr = null;",,,6461
2817,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,63884670328f09a3814db54cb4644d683822e4d4,1432936009,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2818,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,63884670328f09a3814db54cb4644d683822e4d4,1432936009,634,,,,,,,,"            recvWorker = null;",,,6461
2819,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/DataTreeTest.java,71dd96a232cb590e90601fde4bfafcd4eef1f82a,1433555332,59,,,,,,,,"        dt=null;",,,6461
2820,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,2d94a794d33a27567b37b772c08316277ee4e547,1434156169,1056,,,,,,,,"                rwServerAddress = null;",,,6461
2821,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,138,,,,,,,,"            this.clientAddr = null;",,,6461
2822,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,144,,,,,,,,"            this.electionAddr = null;",,,6461
2823,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,145,d1b07d588e445085eff4abeb42cf730cc7c57e83,1517295761,145,,,,,"            this.clientAddr = null;",,,6461
2824,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,212,,,,,,,,"            this.clientAddr = null;",,,6461
2825,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2826,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2827,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2828,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,1016,,,,,,,,"            jmxLocalPeerBean = null;",,,6461
2829,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,c520e1e826d88955db7637a33cd4f20c20c0bd7a,1435363410,1017,,,,,,,,"            jmxRemotePeerBean = null;",,,6461
2830,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,08cc9187d9eb327b2a71bc9a8c62636815dfe9e5,1445187641,212,,,,,,,,"            this.clientAddr = null;",,,6461
2831,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,08cc9187d9eb327b2a71bc9a8c62636815dfe9e5,1445187641,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2832,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,08cc9187d9eb327b2a71bc9a8c62636815dfe9e5,1445187641,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2833,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,08cc9187d9eb327b2a71bc9a8c62636815dfe9e5,1445187641,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2834,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,08cc9187d9eb327b2a71bc9a8c62636815dfe9e5,1445187641,1016,,,,,,,,"            jmxLocalPeerBean = null;",,,6461
2835,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,08cc9187d9eb327b2a71bc9a8c62636815dfe9e5,1445187641,1017,,,,,,,,"            jmxRemotePeerBean = null;",,,6461
2836,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/JMXEnv.java,e65986980ee173e19b36cd8f5a3dd4dae786ca30,1446534687,68,,,,,,,,"        cc = null;",,,6461
2837,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/JMXEnv.java,e65986980ee173e19b36cd8f5a3dd4dae786ca30,1446534687,75,,,,,,,,"        cs = null;",,,6461
2838,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,80803034aabb68229730b9d7429525bd460c3183,1447018577,754,,,,,,,,"                        bb = null;",,,6461
2839,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,c502e93d4f829dfe8060ef50cf369c23ec7cc78c,1449351806,1056,,,,,,,,"                rwServerAddress = null;",,,6461
2840,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,9bb9b1d7016433ce98cd33be904ee1e77d484ffd,1449428309,1056,,,,,,,,"                rwServerAddress = null;",,,6461
2841,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java,28573d112600863f6918a963cb3583a09d69aa1e,1449433807,142,,,,,,,,"                peer = null;",,,6461
2842,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,3496911f7fb14294483640ab29f4e8c089dd8283,1464821964,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2843,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,3496911f7fb14294483640ab29f4e8c089dd8283,1464821964,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2844,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,3496911f7fb14294483640ab29f4e8c089dd8283,1464821964,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2845,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,0c4b4483338d9c71f313f66d3d5bd7912a8ea30a,1465400595,253,,,,,,,,"                        electionAddr = null;",,,6461
2846,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,0c4b4483338d9c71f313f66d3d5bd7912a8ea30a,1465400595,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2847,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,0c4b4483338d9c71f313f66d3d5bd7912a8ea30a,1465400595,634,,,,,,,,"            recvWorker = null;",,,6461
2848,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ReconfigTest.java,5ccea64951f9e6ffa6a6bf4d0f273861948559da,1466010699,178,,,,,,,,"        zkArr[0] = null; // not used.",,,6461
2849,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8616a9ec8ce4bc8ac2987b7417a6f0c4b7333658,1482241645,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2850,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8616a9ec8ce4bc8ac2987b7417a6f0c4b7333658,1482241645,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2851,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8616a9ec8ce4bc8ac2987b7417a6f0c4b7333658,1482241645,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2852,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8616a9ec8ce4bc8ac2987b7417a6f0c4b7333658,1482241645,1016,,,,,,,,"            jmxLocalPeerBean = null;",,,6461
2853,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,8616a9ec8ce4bc8ac2987b7417a6f0c4b7333658,1482241645,1017,,,,,,,,"            jmxRemotePeerBean = null;",,,6461
2854,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,1529,,,,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2855,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,1567,,,,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2856,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,1640,,,,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2857,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,1678,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2858,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,1772,,,,,,,,"        return getConfig(watch ? watchManager.defaultWatcher : null, stat);",,,6461
2859,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,1781,,,,,,,,"        getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2860,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,2141,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2861,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,2181,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2862,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,2266,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2863,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,c2434883dcdd85450ac73b7e69f3deed83fa5bf4,1483998598,2311,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2864,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/version/util/VerGen.java,8771ffdaacb87126a485ae740558f6a288ab980b,1485345656,131,,,,,,,,"            result.qualifier = null;",,,6461
2865,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,253,,,,,,,,"                        electionAddr = null;",,,6461
2866,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2867,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,634,,,,,,,,"            recvWorker = null;",,,6461
2868,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2869,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2870,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2871,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,1016,,,,,,,,"            jmxLocalPeerBean = null;",,,6461
2872,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,434abbbb7eef271fab02306bcc9c8ad29ec2fe2e,1486636823,1017,,,,,,,,"            jmxRemotePeerBean = null;",,,6461
2873,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,b3ef40bffe49c1e42aee23a600a775194f36bca0,1491844774,274,,,,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2874,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,b3ef40bffe49c1e42aee23a600a775194f36bca0,1491844774,754,,,,,,,,"                        bb = null;",,,6461
2875,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,3946f0b1dfaa847eaa73cae5634d7d28da94eec9,1492472252,492,,,,,,,,"        serverFactory = null;",,,6461
2876,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,3946f0b1dfaa847eaa73cae5634d7d28da94eec9,1492472252,514,,,,,,,,"            allClients = null;",,,6461
2877,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,3946f0b1dfaa847eaa73cae5634d7d28da94eec9,1492472252,531,,,,,,,,"        serverFactory = null;",,,6461
2878,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,1529,,,,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2879,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,1567,,,,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2880,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,1640,,,,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2881,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,1678,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2882,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,1772,,,,,,,,"        return getConfig(watch ? watchManager.defaultWatcher : null, stat);",,,6461
2883,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,1781,,,,,,,,"        getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2884,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,2141,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2885,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,2181,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2886,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,2266,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2887,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,acfc471eca0aab57707b59ed8d19221360d19b85,1493651955,2311,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2888,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,138,,,,,,,,"            this.clientAddr = null;",,,6461
2889,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,145,,,,,,,,"            this.clientAddr = null;",,,6461
2890,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,212,,,,,,,,"            this.clientAddr = null;",,,6461
2891,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2892,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2893,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2894,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,1016,,,,,,,,"            jmxLocalPeerBean = null;",,,6461
2895,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a680655a3569bfc546712cb85eeaea8c9b7de3ad,1494514782,1017,,,,,,,,"            jmxRemotePeerBean = null;",,,6461
2896,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,e358a808d172c31e114eee1cc2957fe92d0d142e,1496185319,253,,,,,,,,"                        electionAddr = null;",,,6461
2897,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,e358a808d172c31e114eee1cc2957fe92d0d142e,1496185319,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2898,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,e358a808d172c31e114eee1cc2957fe92d0d142e,1496185319,634,,,,,,,,"            recvWorker = null;",,,6461
2899,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,1f2eb3a0409ff4f3b09896f2148dfbcb9d4c5081,1496334882,1056,,,,,,,,"                rwServerAddress = null;",,,6461
2900,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,1038966e8289c09a6f3b863dd2713b9f1c83b4cf,1496937079,492,,,,,,,,"        serverFactory = null;",,,6461
2901,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,1038966e8289c09a6f3b863dd2713b9f1c83b4cf,1496937079,514,,,,,,,,"            allClients = null;",,,6461
2902,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,1038966e8289c09a6f3b863dd2713b9f1c83b4cf,1496937079,531,,,,,,,,"        serverFactory = null;",,,6461
2903,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,4517050510f8db354589d054c9ded4c78b36902f,1497026273,253,,,,,,,,"                        electionAddr = null;",,,6461
2904,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,4517050510f8db354589d054c9ded4c78b36902f,1497026273,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2905,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,4517050510f8db354589d054c9ded4c78b36902f,1497026273,634,,,,,,,,"            recvWorker = null;",,,6461
2906,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/DataTree.java,111ae5a5b67999925f1921736a14fcfbdb1b7348,1497806584,800,,,,,,,,"            rc.multiResult = null;",,,6461
2907,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/DataTreeTest.java,111ae5a5b67999925f1921736a14fcfbdb1b7348,1497806584,59,,,,,,,,"        dt=null;",,,6461
2908,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,8ec4c58eb37880a812bb2e23e8b3ec2a5e3b7f32,1498428426,166,0b65e3d4cbb7647ea692bfea59c02e5b24bf821c,1536189061,166,,,,,"            oa = null;",,,6461
2909,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,8ec4c58eb37880a812bb2e23e8b3ec2a5e3b7f32,1498428426,687,,,,,,,,"                ia = null;",,,6461
2910,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,8ec4c58eb37880a812bb2e23e8b3ec2a5e3b7f32,1498428426,688,,,,,,,,"                hdr = null;",,,6461
2911,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,a0eba7abd002498631da8d8127261c297c911590,1498428967,371,2a372fcdce3c0142c0bb23f06098a2c1a49f807e,1532745428,371,,,,,"                jmxDataTreeBean = null;",,,6461
2912,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,a0eba7abd002498631da8d8127261c297c911590,1498428967,375,,,,,,,,"            jmxServerBean = null;",,,6461
2913,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,a0eba7abd002498631da8d8127261c297c911590,1498428967,465,2a372fcdce3c0142c0bb23f06098a2c1a49f807e,1532745428,465,,,,,"        jmxDataTreeBean = null;",,,6461
2914,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,5c4e44332e55bbf21ca59583f3e8ca97fc4bb266,1501785690,686,,,,,,,,"                inputStream = null;",,,6461
2915,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,5c4e44332e55bbf21ca59583f3e8ca97fc4bb266,1501785690,687,,,,,,,,"                ia = null;",,,6461
2916,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,e104175bb47baeb800354078c015e78bfcb7c953,1502303481,274,,,,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2917,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,e104175bb47baeb800354078c015e78bfcb7c953,1502303481,754,,,,,,,,"                        bb = null;",,,6461
2918,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,0706b40afad079f19fe9f76c99bbb7ec69780dbd,1503030763,371,,,,,,,,"                jmxDataTreeBean = null;",,,6461
2919,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,0706b40afad079f19fe9f76c99bbb7ec69780dbd,1503030763,464,,,,,,,,"        jmxServerBean = null;",,,6461
2920,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,0706b40afad079f19fe9f76c99bbb7ec69780dbd,1503030763,465,,,,,,,,"        jmxDataTreeBean = null;",,,6461
2921,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,1529,,,,,,,,"        return exists(path, watch ? watchManager.defaultWatcher : null);",,,6461
2922,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,1567,,,,,,,,"        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2923,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,1640,,,,,,,,"        return getData(path, watch ? watchManager.defaultWatcher : null, stat);",,,6461
2924,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,1678,,,,,,,,"        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2925,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,1772,,,,,,,,"        return getConfig(watch ? watchManager.defaultWatcher : null, stat);",,,6461
2926,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,1781,,,,,,,,"        getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2927,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,2141,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null);",,,6461
2928,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,2181,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2929,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,2266,,,,,,,,"        return getChildren(path, watch ? watchManager.defaultWatcher : null,",,,6461
2930,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ZooKeeper.java,d7c192c1829cc657d3312f47ecb5b97519d1b30d,1503092124,2311,,,,,,,,"        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);",,,6461
2931,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,52aff3eca439bba70f2b4d175ce331754dcd03db,1503447387,253,,,,,,,,"                        electionAddr = null;",,,6461
2932,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,52aff3eca439bba70f2b4d175ce331754dcd03db,1503447387,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2933,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,52aff3eca439bba70f2b4d175ce331754dcd03db,1503447387,634,,,,,,,,"            recvWorker = null;",,,6461
2934,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java,f2cbcc7e0d7adff08bd73a27f2193b1198e4c7f7,1513383930,154,,,,,,,,"                currentThread = null;",,,6461
2935,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/ClientCnxn.java,e129e7a0b64d6555460d240be2d79e53aaa1bef9,1513708045,1056,,,,,,,,"                rwServerAddress = null;",,,6461
2936,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,069c3e4fccbd56307b19b57864fbf6312ace2219,1517527618,686,,,,,,,,"                inputStream = null;",,,6461
2937,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,069c3e4fccbd56307b19b57864fbf6312ace2219,1517527618,687,,,,,,,,"                ia = null;",,,6461
2938,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,2022766ec907f63b1b43fc5455e9e7761cd332f6,1525062897,865,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2939,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,2022766ec907f63b1b43fc5455e9e7761cd332f6,1525062897,1060,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2940,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,d6490d590725345638b5973a97e6e8d8bee67d22,1529041267,371,,,,,,,,"                jmxDataTreeBean = null;",,,6461
2941,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,d6490d590725345638b5973a97e6e8d8bee67d22,1529041267,375,,,,,,,,"            jmxServerBean = null;",,,6461
2942,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,d6490d590725345638b5973a97e6e8d8bee67d22,1529041267,464,,,,,,,,"        jmxServerBean = null;",,,6461
2943,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,d6490d590725345638b5973a97e6e8d8bee67d22,1529041267,465,,,,,,,,"        jmxDataTreeBean = null;",,,6461
2944,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,c2e7ed1e6f8f2de48778db7f3d63f9629c086ea8,1531281857,253,,,,,,,,"                        electionAddr = null;",,,6461
2945,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,c2e7ed1e6f8f2de48778db7f3d63f9629c086ea8,1531281857,257,,,,,,,,"                   electionAddr = null;                ",,,6461
2946,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,c2e7ed1e6f8f2de48778db7f3d63f9629c086ea8,1531281857,634,,,,,,,,"            recvWorker = null;",,,6461
2947,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,4d7b9e8f34775261fed517d232094f0247a4d3cf,1535516818,865,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2948,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,4d7b9e8f34775261fed517d232094f0247a4d3cf,1535516818,1060,,,,,,,,"            self.jmxLeaderElectionBean = null;",,,6461
2949,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,95557a30edbdfdf4479a1cb142e0d82a4ba6061d,1536280495,274,,,,,,,,"            sb = null; // clear out the ref to ensure no reuse",,,6461
2950,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,95557a30edbdfdf4479a1cb142e0d82a4ba6061d,1536280495,754,,,,,,,,"                        bb = null;",,,6461
2951,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,27db6bd28e3297cdafe19c204b42c3db20c45ad6,1536281350,492,,,,,,,,"        serverFactory = null;",,,6461
2952,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,27db6bd28e3297cdafe19c204b42c3db20c45ad6,1536281350,514,,,,,,,,"            allClients = null;",,,6461
2953,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/test/org/apache/zookeeper/test/ClientBase.java,27db6bd28e3297cdafe19c204b42c3db20c45ad6,1536281350,531,,,,,,,,"        serverFactory = null;",,,6461
2954,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java,4ebb847bceb5ebd5c9fa53574f266c204f6f8ab7,1537591693,161,,,,,,,,"                        cnxn.queuedBuffer = null;",,,6461
2955,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java,4ebb847bceb5ebd5c9fa53574f266c204f6f8ab7,1537591693,206,,,,,,,,"                            cnxn.queuedBuffer = null;",,,6461
2956,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,144,,,,,,,,"            this.electionAddr = null;",,,6461
2957,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,145,,,,,,,,"            this.clientAddr = null;",,,6461
2958,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,212,,,,,,,,"            this.clientAddr = null;",,,6461
2959,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,875,,,,,,,,"                        jmxLocalPeerBean = null;",,,6461
2960,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,889,,,,,,,,"            jmxQuorumBean = null;",,,6461
2961,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,1015,,,,,,,,"            jmxQuorumBean = null;",,,6461
2962,0373c58fd4be937e4c3bf347be1956f45d12950d9b93397478ad50d78479881426d7faf551126499c6d712823bb9d6fb62480a1e33096f6fd9aafe1e6d979e49190a48fc1c43edc0ff2b410eae09381d7965351dcf385205409adb2f5f0fe928a55f77d23f641fe61e1e3964272601012b895620a987134af362313860401024b7141489e66ee76af442eb76,6.25,category/java/errorprone.xml/NullAssignment,./TargetProjects/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,a8cf62678131626b778d0572290d582f70a2cbfc,1538367078,1016,,,,,,,,"            jmxLocalPeerBean = null;",,,6461
